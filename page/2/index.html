<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="daidai" />


    
    


<meta name="description" content="喜欢探索未知,保持好奇心">
<meta property="og:type" content="website">
<meta property="og:title" content="T9&#39;S Develop Blog">
<meta property="og:url" content="http://outofmemory.top/page/2/index.html">
<meta property="og:site_name" content="T9&#39;S Develop Blog">
<meta property="og:description" content="喜欢探索未知,保持好奇心">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="T9&#39;S Develop Blog">
<meta name="twitter:description" content="喜欢探索未知,保持好奇心">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="T9&#39;S Develop Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="https://s1.ax1x.com/2018/10/12/iNnhCV.gif">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>T9&#39;S Develop Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://s1.ax1x.com/2018/10/12/iNnhCV.gif" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">daidai</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不仅有工作，更有生活</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://daidazhao@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/dazhaoDai" title="GitHub"></a>
                            
                                <a class="fa CSDN" href="https://blog.csdn.net/dazhaoDai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android官方架构/">Android官方架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进阶/">Android进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git分支操作/">Git分支操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java进阶/">Java进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin学习/">Kotlin学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin开发/">Kotlin开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-aidl/">android aidl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-permission/">android permission</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-view/">android view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-开发错误/">android 开发错误</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-权限/">android 权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-自定义view/">android 自定义view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android触摸事件/">android触摸事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/privacy/">privacy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Developer</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">daidai</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://s1.ax1x.com/2018/10/12/iNnhCV.gif" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">daidai</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不仅有工作，更有生活</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://daidazhao@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/dazhaoDai" title="GitHub"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://blog.csdn.net/dazhaoDai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Java进阶 ——— HTTP概述" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java进阶 ——— HTTP概述/" class="article-date">
      <time datetime="2018-08-24T07:17:32.860Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java进阶 ——— HTTP概述/">Java进阶 ——— HTTP概述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>Web浏览器、服务器和相关的Web应用程序都是通过HTTP相互通信。HTTP是现代全球因特网中使用的公共语言。</p>
<h4 id="HTTP-因特网的多媒体信使"><a href="#HTTP-因特网的多媒体信使" class="headerlink" title="HTTP-因特网的多媒体信使"></a>HTTP-因特网的多媒体信使</h4><hr>
<p>每天都有数亿JPEG图片、HTML页面、文本文件、MPEG电影、WAV音频文件、java小程序和其他资源在因特网游弋。HTTP可以从全世界的Web服务器上将这些信息迅速、便捷、可靠的传输到Web浏览器上。<br>HTTP使用的是可靠的数据传输协议，它能够确保数据在传输过程中不会被损坏或者产生混乱。对开发人员来说，无需担心HTTP通信会在传输过程中被破坏、复制或者产生畸变。开发人员可以专注于程序特有细节的编写，而不是考虑因特网中存在的一些缺陷和问题。</p>
<h4 id="Web客户端和服务器"><a href="#Web客户端和服务器" class="headerlink" title="Web客户端和服务器"></a>Web客户端和服务器</h4><hr>
<p>Web内容都是存储在Web服务器上。Web服务器使用HTTP协议，因此还可以称为HTTP服务器。HTTP客户端向服务器发出请求，服务器会在HTTP响应中回送所请求的数据。</p>
<p><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519114733310-2080783655.jpg" alt=""></p>
<p>最常见的HTTP客户端就是浏览器。浏览器向服务器请求HTTP对象，并将对象显示在屏幕上。</p>
<h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><hr>
<p>因特网有很多的数据类型，HTTP给每种要通过Web传输的对象都打上MIME类型（MIME type）的数据格式标签。最初设计MIME(Multipurpose Internet Mail Extension,多用途因特网邮件扩展)是为了解决不同电子邮件系统之家搬移报文时存在的问题。<br>Web服务器会为所有的HTTP对象数据附一个MIME类型。当Web浏览器从服务器取回一个对象时，会去查看相关的MIME类型，看看它是否知道应该如何处理这个对象。大多数浏览器都可以处理上百种常见对象：显示图片、解析并格式化HTML文件、播放音频文件、或者运行外部软件来处理特殊格式数据。<br>MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。<br>例如：HTML格式的文本文档 text/html类型来标记。</p>
<h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><hr>
<p>每个Web服务器都有一个名字，这样客户端就可以说明它们感兴趣的资源是什么。服务器资源名被统一称为统一资源标识符（Uniform Resource Identifier，URI）。URI有两种形式：分别是URL和URN。</p>
<ul>
<li>URL<blockquote>
<p>统一资源定位符（URL,Uniform Resource Locator）是资源标识符最常见的形式。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112010341-493649336.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>大部分URL都遵循一种标准格式，这种格式包含三个部分。<br>1.URL的第一部分称为方案（scheme），说明访问资源所使用的协议类型。这部分通常是HTTP或者HTTPS（<a href="http://)。" target="_blank" rel="external">http://)。</a><br>2.第二部分给出了服务器的因特网地址（www.joes-hardware.com）。<br>3.其余部分指定了Web服务器上的某个资源（比如，/specials/saw-blade.gif）。<br>现在几乎所有的URI都是URL。</p>
</blockquote>
<ul>
<li>URN</li>
</ul>
<blockquote>
<p>URI的第二种形式就是URN（统一资源名）。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与&gt;位置无关的URN，就可以将资源四处搬动。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。<br>URN仍然处于试验阶段，还未大范围使用。除非特殊说明，否则这里的都是用URL来指定URI。</p>
</blockquote>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><hr>
<p>一个HTTP事务由一条请求命令和一个响应结果组成。这种通信通过名为HTTP报文（HTTP message）的格式化数据块进行。</p>
<ul>
<li>方法</li>
</ul>
<blockquote>
<p>HTTP支持几种几种不同的请求命令，这些命令被称为HTTP方法（HTTP method）。每条HTTP请求报文都包含一个方法。这个方法会告诉服务器要执行什么动作（获取一个Web页面、运行一个网关程序、删除一个文件等）。</p>
</blockquote>
<p>常见的HTTP方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">HTTP方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">从服务器向客户端发送命名资源</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:center">将来自客户端的数据存储到一个命名的资源服务器中</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">从服务器中删除命名资源</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">将客户端数据发送到一个服务器网关应用程序</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">仅发送命名资源响应中的HTTP首部</td>
</tr>
</tbody>
</table>
<ul>
<li>状态码<blockquote>
<p>每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作。</p>
</blockquote>
</li>
</ul>
<p>常见的HTTP状态码：<br>|HTTP状态码|    描述|<br>|—-|—-|<br>|200    |OK, 文档正确返回|<br>|302    |Redirect（重定向）。到其他地方去获取资源|<br>|404    |Not Found（没找到），无法找到这个资源|</p>
<ul>
<li>Web页面可以包含多个对象<blockquote>
<p>应用程序完成一项任务时通常会发布多个HTTP事务。比如，Web浏览器会发布一系列的HTTP事务来获取并显示一个包含丰富图片的Web页面。浏览器会执行一个事务来获取描述页面布局的HTML”框架“，然后发布另外的HTTP事务来获取每个嵌入式图片、图像面板、Java小程序等。这些嵌入式资源甚至可能位于不同的服务器。因此，一个Web页面通常并不是单个资源，而是一组资源的集合。</p>
</blockquote>
</li>
</ul>
<h4 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h4><hr>
<p>HTTP报文都是由一行行的简单字符串组成。HTTP报文都是纯文本，不是二进制代码。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519114829357-917648896.jpg" alt=""></p>
<p>从Web客户端发往Web服务器的HTTP报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文（reponse message），此外没有其他类型的HTTP报文。请求报文和响应报文格式类似。<br>HTTP报文包括以下三部分：</p>
<ul>
<li>起始行</li>
</ul>
<blockquote>
<p>报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。</p>
</blockquote>
<ul>
<li>首部字段</li>
</ul>
<blockquote>
<p>起始行后面有0个或者多个首部字段。每个字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（：）分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。</p>
</blockquote>
<ul>
<li>主体</li>
</ul>
<blockquote>
<p>空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发给Web服务器的数据，响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体可以包含任意的二进制数据（图片、视频、音频、软件程序）。当然，主体还可以包含文本。</p>
</blockquote>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><hr>
<ul>
<li>TCP/IP</li>
</ul>
<blockquote>
<p>HTTP是个应用层协议。HTTP无需关心网络通信的具体细节；它把联网的细节都给了通用、可靠的因特网传输协议TCP/IP。<br>TCP提供了：</p>
<ul>
<li>无差错的数据传输。</li>
<li>按序传输（数据总是按照发送的顺序到达）；</li>
<li>分段的数据流（可以在任意时刻以任意大小将数据发送出去）。<br>因特网自身是基于TCP/IP的，它是全世界计算机网络常用的层次化分组交换网络协议集。TCP/IP 隐藏了各种网络和硬件的特点及弱点，使各种类型的计算机和网络都能够进行可靠地通信。<br>只要建立了TCP连接，客户端和服务器之间的报文交换就不会丢失、被破坏、也不会出现接收时乱序。HTTP协议位于TCP的上层。HTTP使用TCP来传输其报文数据。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112140466-1638988931.jpg" alt=""></li>
</ul>
</blockquote>
<ul>
<li>连接、IP地址及端口号</li>
</ul>
<blockquote>
<p>在HTTP客户端向服务器发送报文之前，需要用网际协议（Internet Prococol，IP）地址和端口号在客户端和服务器之间建立一条TCP/IP连接。<br>建立一条TCP连接的过程与给公司办公室的某个人打电话的过程类似。首先，要拨打公司的电话号码。这样就能进入正确的机构了。其次，拨打要联系的那个人的分机号。<br>最初怎么获取服务器的IP地址呢？当然是通过URL。<br>先看几个URL:<br><a href="http://207.200.83.29:80/index.html" target="_blank" rel="external">http://207.200.83.29:80/index.html</a><br><a href="http://www.netscape.com:80/index.html" target="_blank" rel="external">http://www.netscape.com:80/index.html</a><br><a href="http://www.netscape.com/index.html" target="_blank" rel="external">http://www.netscape.com/index.html</a><br>第一个 URL 使用了机器的 IP 地址，207.200.83.29 以及端口.第二个 URL 没有使用数字形式的 IP 地址，它使用的是文本形式的域名，或者称为主机名（www.netscape.com） 。主机名就是 IP 地址比较人性化的别称。可以通过一<br>种称为域名服务（Domain Name Service，DNS）的机制方便地将主机名转换为 IP地址，这样所有问题就都解决了。<br>最后一个 URL 没有端口号。HTTP 的 URL 中没有端口号时，可以假设默认端口号是 80。有了 IP 地址和端口号，客户端就可以很方便地通过 TCP/IP 进行通信了。</p>
</blockquote>
<ul>
<li>连接、IP地址及端口号</li>
</ul>
<blockquote>
<p>在HTTP客户端向服务器发送报文之前，需要用网际协议（Internet Prococol，IP）地址和端口号在客户端和服务器之间建立一条TCP/IP连接。<br>建立一条TCP连接的过程与给公司办公室的某个人打电话的过程类似。首先，要拨打公司的电话号码。这样就能进入正确的机构了。其次，拨打要联系的那个人的分机号。<br>最初怎么获取服务器的IP地址呢？当然是通过URL。<br>先看几个URL:<br><a href="http://207.200.83.29:80/index.html" target="_blank" rel="external">http://207.200.83.29:80/index.html</a><br><a href="http://www.netscape.com:80/index.html" target="_blank" rel="external">http://www.netscape.com:80/index.html</a><br><a href="http://www.netscape.com/index.html" target="_blank" rel="external">http://www.netscape.com/index.html</a><br>第一个 URL 使用了机器的 IP 地址，207.200.83.29 以及端口.第二个 URL 没有使用数字形式的 IP 地址，它使用的是文本形式的域名，或者称为主机名（www.netscape.com） 。主机名就是 IP 地址比较人性化的别称。可以通过一<br>种称为域名服务（Domain Name Service，DNS）的机制方便地将主机名转换为 IP地址，这样所有问题就都解决了。<br>最后一个 URL 没有端口号。HTTP 的 URL 中没有端口号时，可以假设默认端口号是 80。有了 IP 地址和端口号，客户端就可以很方便地通过 TCP/IP 进行通信了。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112159576-752772932.jpg" alt=""></p>
</blockquote>
<p>步骤如下：</p>
<p>(a) 浏览器从 URL 中解析出服务器的主机名；</p>
<p>(b) 浏览器将服务器的主机名转换成服务器的 IP 地址；</p>
<p>(c) 浏览器将端口号（如果有的话）从 URL 中解析出来；</p>
<p>(d) 浏览器建立一条与 Web 服务器的 TCP 连接；</p>
<p>(e) 浏览器向服务器发送一条 HTTP 请求报文；</p>
<p>(f) 服务器向浏览器回送一条 HTTP 响应报文；</p>
<p>(g) 关闭连接，浏览器显示文档。</p>
<ul>
<li>使用Telnet实例<blockquote>
<p>Telnet程序可以将键盘连接到某个目标TCP端口，并将此TCP端口的输出回送到显示屏上。Telnet常用于远程终端会话，但它几乎可以连接所有的TCP服务器，包括HTTP服务器。<br>可以通过Telnet程序直接与Web服务器进行对话。通过Telnet可以打开一条到某台机器上某个端口的TCP连接，然后直接向端口输入一些字符。Web服务器会将Telnet程序作为一个Web客户端来处理，然后回送给TCP连接的数据会显示在屏幕上。<br>实际例子：Telnet获取URL <a href="http://www.joes-hardware.com:80/tools.html" target="_blank" rel="external">http://www.joes-hardware.com:80/tools.html</a> 所指向的文档<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112210466-1338515722.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Telnet 会查找主机名并打开一条连接，连接到在 www.joes-hardware.com 的端口 80上监听的 Web 服务器。这条命令之后的三行内容是 Telnet 的输出，告诉我们它已经建立了连接。<br>然后我们输入最基本的请求命令 GET/tools.html HTTP/1.1 ，发送一个提供了源端主机名的 Host 首部，后面跟上一个空行，请求从服务器 www.joes-hardware.com 上获取资源 tools.html。随后，服务器会以一个响应行、几个响应首部、一个空行和最后面的 HTML 文档主体来应答。<br>要明确的是，Telnet 可以很好地模拟 HTTP 客户端，但不能作为服务器使用。而且对 Telnet 做脚本自动化是很繁琐乏味的。如果想要更灵活的工具，可以去看看 nc（netcat） 。通过 nc 可以很方便地操纵基于 UDP 和 TCP 的流量（包括 HTTP） ，还可以为其编写脚本。更多细节参见 <a href="http://www.bgw.org/tutorials/utilities/nc.php" target="_blank" rel="external">http://www.bgw.org/tutorials/utilities/nc.php</a></p>
</blockquote>
<h4 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h4><hr>
<p>目前HTTP有几个协议版本。</p>
<ul>
<li>HTTP/0.9</li>
</ul>
<blockquote>
<p>HTTP 的 1991 原型版本称为 HTTP/0.9。这个协议有很多严重的设计缺陷，只应该用于与老客户端的交互。HTTP/0.9 只支持 GET 方法，不支持多媒体内容的MIME 类型、各种 HTTP 首部，或者版本号。HTTP/0.9 定义的初衷是为了获取简单的 HTML 对象，它很快就被 HTTP/1.0 取代了。</p>
</blockquote>
<ul>
<li>HTTP/1.0</li>
</ul>
<blockquote>
<p>1.0 是第一个得到广泛使用的 HTTP 版本。HTTP/1.0 添加了版本号、各种 HTTP首部、一些额外的方法，以及对多媒体对象的处理。HTTP/1.0 使得包含生动图片的 Web 页面和交互式表格成为可能，而这些页面和表格促使万维网为人们广泛地接受。这个规范从未得到良好地说明。在这个 HTTP 协议的商业演进和学术研究都在快速进行的时代，它集合了一系列的最佳实践。</p>
</blockquote>
<ul>
<li>HTTP/1.0+</li>
</ul>
<blockquote>
<p>在 20 世纪 90 年代中叶，很多流行的 Web 客户端和服务器都在飞快地向 HTTP中添加各种特性，以满足快速扩张且在商业上十分成功的万维网的需要。其中很多特性，包括持久的 keep-alive 连接、虚拟主机支持，以及代理连接支持都被加入到 HTTP 之中，并成为非官方的事实标准。这种非正式的 HTTP 扩展版本通常称为 HTTP/1.0+。</p>
</blockquote>
<ul>
<li>HTTP/1.1</li>
</ul>
<blockquote>
<p>HTTP/1.1 重点关注的是校正 HTTP 设计中的结构性缺陷，明确语义，引入重要的性能优化措施，并删除一些不好的特性。HTTP/1.1 还包含了对 20 世纪 90 年代末正在发展中的更复杂的 Web 应用程序和部署方式的支持。HTTP/1.1 是当前使用的 HTTP 版本。</p>
</blockquote>
<ul>
<li>HTTP-NG（又名 HTTP/2.0）</li>
</ul>
<blockquote>
<p>HTTP-NG 是 HTTP/1.1 后继结构的原型建议，它重点关注的是性能的大幅优化，以及更强大的服务逻辑远程执行框架。HTTP-NG 的研究工作终止于 1998 年，编写本书时，还没有任何要用此建议取代 HTTP/1.1 的推广计划。</p>
</blockquote>
<h4 id="Web结构组件"><a href="#Web结构组件" class="headerlink" title="Web结构组件"></a>Web结构组件</h4><hr>
<p>前面重点介绍了Web应用程序（Web客户端和Web服务器）是如何相互发送报文来实现基本事务处理的。因特网上还有一些其他的应用程序。下面一一介绍。</p>
<ul>
<li>代理</li>
</ul>
<blockquote>
<p>代理位于客户端和服务器之间的HTTP中间实体。接收所有客户端的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发） 。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112229279-96424183.jpg" alt=""></p>
</blockquote>
<p>出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。</p>
<ul>
<li>缓存<blockquote>
<p>Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了.<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112238310-462215583.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<p>客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。HTTP 定义了很多功能，使得缓存更加高效，并规范了文档的新鲜度和缓存内容的隐私性。</p>
<ul>
<li>网关</li>
</ul>
<blockquote>
<p>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。<br>例如，一个 HTTP/FTP 网关会通过 HTTP 请求接收对 FTP URI 的请求，但通过 FTP协议来获取文档 。得到的文档会被封装成一条 HTTP 报文，发送给客户端。第 8 章将探讨网关。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112338576-179894136.jpg" alt=""></p>
</blockquote>
<ul>
<li>隧道</li>
</ul>
<blockquote>
<p>隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。<br>HTTP 隧道的一种常见用途是通过 HTTP 连接承载加密的安全套接字层（SSL，Secure Sockets Layer）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。如图所示，HTTP/SSL 隧道收到一条 HTTP 请求，要求建立一条到目的地址和端口的输出连接，然后在 HTTP 信道上通过隧道传输加密的 SSL 流量，这样就可以将其盲转发到目的服务器上去了。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112347044-225510358.jpg" alt=""></p>
</blockquote>
<ul>
<li>Agent代理</li>
</ul>
<blockquote>
<p>用户 Agent 代理（或者简称为 Agent 代理）是代表用户发起 HTTP 请求的客户端程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。到目前为止，我们只提到过一种 HTTP Agent 代理：Web 浏览器，但用户 Agent 代理还有很多其他类型。用fiddler抓包找头部信息会发现类似User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36<br>比如，有些自己会在 Web 上闲逛的自动用户 Agent 代理，可以在无人监视的情况下发布 HTTP 事务并获取内容。这些自动代理的名字通常都很生动，比如“网络蜘蛛”（spiders）或者“Web 机器人” （Web robots） 。网络蜘蛛会在 Web 上闲逛，搜集信息以构建有效的 Web 内容档案，比如一个搜索引擎的数据库或者为比较购物机器人生成的产品目录。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112356466-407427538.jpg" alt=""></p>
</blockquote>
<h2 id="URL和资源"><a href="#URL和资源" class="headerlink" title="URL和资源"></a>URL和资源</h2><h4 id="因特网资源"><a href="#因特网资源" class="headerlink" title="因特网资源"></a>因特网资源</h4><p>URL是浏览器寻找信息所需的资源位置。URI是一类更通用的资源标识符，URL是URI的一个子集。URI包括URL和URN。</p>
<h4 id="URL语法"><a href="#URL语法" class="headerlink" title="URL语法"></a>URL语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</div></pre></td></tr></table></figure>
<ul>
<li>scheme<br>访问服务器以获取资源时要使用的协议 默认值 无</li>
<li>user<br>一些方案访问资源时需要的用户名 默认值 匿名</li>
<li>password<br>用户名后面可能要包含密码,中间由冒号分隔 默认值 </li>
<li>host<br>资源宿主服务器的主机名或点分IP地址 默认值 无</li>
<li>port<br>资源宿主服务器正在监听的端口号,很多方案都有默认端口号(HTTP默认端口号为80) 默认值 每个方案特有</li>
<li>path<br>服务器上资源的本地名,由一个”/“将其与前面的URL组件分隔开来.路径组件的语法与服务器和方案有关 默认值 无</li>
<li>params<br>一些方案会用这个组件指定输入参数. 参数为名/值对. URL中可以包含多个参数字段,它们相互以及与路径的其余部分之间用分号(;)分隔 默认值 无</li>
<li>query<br>一些方案会用这个组件传递参数以激活应用程序.查询组件的内容没有通用格式.用符号”?”将其与URL的其余部分分隔开来 默认值 无</li>
<li>frag<br>一小片或一部分资源的名字.引用对象时,不会将frag字段传送给服务器。这个字段是在客户端内部使用的.通过字符”#”将其与URL其余部分分隔开来 默认值 无</li>
</ul>
<p><a href="http://www.joes-hardware.com/hammers;sale=false/index.html;graphic=ture" target="_blank" rel="external">http://www.joes-hardware.com/hammers;sale=false/index.html;graphic=ture</a><br>这个例子就有两个路径段，hammers和index.html。hammers路径段的参数是sale，值为false。index.html段有参数graphics，值为true。<br><a href="http://www.joes-hardware.com/inventory-check.cgi?item=12731" target="_blank" rel="external">http://www.joes-hardware.com/inventory-check.cgi?item=12731</a><br>问号右边的内容称为查询组件。URL的查询组件和标志网关资源的URL路径组件一起被发送给网关资源。基本上可以将网关当作访问其他应用程序的访问点。<br>HTTP服务器只处理整个对象，而不是对象的片段，客户端不能将片段传送给服务器，浏览器获得整个资源后，会根据片段来显示你感兴趣的内容。</p>
<h2 id="TCP-IP的三次握手，四次分手"><a href="#TCP-IP的三次握手，四次分手" class="headerlink" title="TCP/IP的三次握手，四次分手"></a>TCP/IP的三次握手，四次分手</h2><p>首先我们先来了解TCP报文段</p>
<p><img src="https://img-blog.csdn.net/20150830163219709" alt=""></p>
<p>重要的标志我在图中也有标记，重点了解标志位<br>ACK：确认序号有效<br>RST：重置连接<br>SYN：发起了一个新连接<br>FIN：释放一个连接</p>
<h4 id="三次握手的过程（客户端我们用A表示，服务器端用B表示）"><a href="#三次握手的过程（客户端我们用A表示，服务器端用B表示）" class="headerlink" title="三次握手的过程（客户端我们用A表示，服务器端用B表示）"></a>三次握手的过程（客户端我们用A表示，服务器端用B表示）</h4><p>前提：A主动打开，B被动打开<br><img src="https://img-blog.csdn.net/20150830163536721" alt=""></p>
<ol>
<li>在建立连接之前，B先创建TCB（传输控制块），准备接受客户进程的连接请求，处于LISTEN（监听）状态</li>
<li>A首先创建TCB，然后向B发出连接请求，SYN置1，同时选择初始序号seq=x，进入SYN-SEND（同步已发送）状态</li>
<li>B收到连接请求后向A发送确认，SYN置1，ACK置1，同时产生一个确认序号ack=x+1。同时随机选择初始序号seq=y，进入SYN-RCVD（同步收到）状态</li>
<li>A收到确认连接请求后，ACK置1，确认号ack=y+1，seq=x+1，进入到ESTABLISHED（已建立连接）状态。向B发出确认连接，最后B也进入到ESTABLISHED（已建立连接）状态。</li>
</ol>
<p>简单来说，就是</p>
<ol>
<li>建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认</li>
<li>服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态</li>
<li>客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
</ol>
<p>在此穿插一个知识点就是SYN攻击，那么什么是SYN攻击？发生的条件是什么？怎么避免？<br>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是 Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址 是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网 络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：</p>
<p>  #netstat -nap | grep SYN_RECV</p>
<h4 id="四次分手的过程（客户端我们用A表示，服务器端用B表示）"><a href="#四次分手的过程（客户端我们用A表示，服务器端用B表示）" class="headerlink" title="四次分手的过程（客户端我们用A表示，服务器端用B表示）"></a>四次分手的过程（客户端我们用A表示，服务器端用B表示）</h4><p>由于TCP连接时是全双工的，因此每个方向都必须单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的链接。收到一个FIN只是意味着这一方向上没有数据流动，既不会在收到数据，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p>前提：A主动关闭，B被动关闭<br><img src="https://img-blog.csdn.net/20150830170207281" alt=""></p>
<p>有人可能会问，为什么连接的时候是三次握手，而断开连接的时候需要四次挥手？<br>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再 发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<ol>
<li>A发送一个FIN，用来关闭A到B的数据传送，A进入FIN_WAIT_1状态。</li>
<li>B收到FIN后，发送一个ACK给A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），B进入CLOSE_WAIT状态。</li>
<li>B发送一个FIN，用来关闭B到A的数据传送，B进入LAST_ACK状态。</li>
<li>A收到FIN后，A进入TIME_WAIT状态，接着发送一个ACK给B，确认序号为收到序号+1，B进入CLOSED状态，完成四次挥手。</li>
</ol>
<p>简单来说就是</p>
<ol>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。</li>
</ol>
<p>A在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），A才进入到CLOSED状态。为什么？<br>为了保证A发送的最后一个ACK报文段能够到达B<br>防止“已失效的连接请求报文段”出现在本连接中</p>
<p>OK~是不是很难懂的感觉？那我们来说的“人性化点的”吧</p>
<p>三次握手流程</p>
<ol>
<li>客户端发个请求“开门呐，我要进来”给服务器</li>
<li>服务器发个“进来吧，我去给你开门”给客户端</li>
<li>客户端有很客气的发个“谢谢，我要进来了”给服务器</li>
</ol>
<p>四次挥手流程</p>
<ol>
<li>客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他</li>
<li>服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走</li>
<li>服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）</li>
<li>客户端发个“我知道了，我走了”，之后自己就走了</li>
</ol>
<hr>
<p>参考<br><a href="http://www.cnblogs.com/qcssmd/p/5508150.html" target="_blank" rel="external">http://www.cnblogs.com/qcssmd/p/5508150.html</a><br><a href="https://blog.csdn.net/u011318165/article/details/48102939" target="_blank" rel="external">https://blog.csdn.net/u011318165/article/details/48102939</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java设计模式  ------ 代理模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java设计模式  ------ 代理模式/" class="article-date">
      <time datetime="2018-08-24T07:16:54.381Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java设计模式  ------ 代理模式/">Java设计模式  ------ 代理模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>代理模式是常用的Java设计模式，它的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。按照代理类的创建时期，代理类可分为两种。</p>
<p>静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。实现类和代理类实现同一个接口，将实现类对象传递给代理类，代理类的实现方法实际是由实现类完成操作的。</p>
<p>动态代理类：在程序运行时，运用反射机制动态创建而成。</p>
<p>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。<br> 静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。</p>
<p>动态代理是实现JDK里的InvocationHandler接口的invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。</p>
<p>还有一种动态代理CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行时，动态修改字节码达到修改类的目的。<br>静态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>动态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java 进阶  ------ 垃圾回收机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java 进阶  ------ 垃圾回收机制/" class="article-date">
      <time datetime="2018-08-24T07:15:25.786Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java 进阶  ------ 垃圾回收机制/">Java 进阶  ------ 垃圾回收机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h3><ul>
<li><p>垃圾回收的意义<br>当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾，JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。</p>
</li>
<li><p>垃圾收集的算法分析<br>1.为什么会有年轻代</p>
<p>我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p>  2.年轻代中的GC</p>
<p>  HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p>
<p>  因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>  在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p>  <img src="http://ifeve.com/wp-content/uploads/2014/07/young_gc.png" alt=""></p>
<p>  3.一个对象的这一辈子<br>我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p>
</li>
</ul>
<hr>
<pre><code>JVM 新生代老年代
https://www.cnblogs.com/E-star/p/5556188.html
</code></pre><hr>
<h3 id="2-常见编码方式"><a href="#2-常见编码方式" class="headerlink" title="2. 常见编码方式"></a>2. 常见编码方式</h3><ul>
<li>1.ASCII<br>共有128个，用一个字节的低7位表示<br>0~31 控制字符 如换行、回车、删除<br>32~126 打印字符</li>
<li>2.GB2312</li>
<li>3.GBK</li>
<li>4.UTF-16</li>
<li>5.UTF-8</li>
</ul>
<h3 id="3-静态代理和动态代理的区别，以及使用场景"><a href="#3-静态代理和动态代理的区别，以及使用场景" class="headerlink" title="3. 静态代理和动态代理的区别，以及使用场景"></a>3. 静态代理和动态代理的区别，以及使用场景</h3><p>原因是采用代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部</p>
<ul>
<li>1.静态代理<br>静态代理是在编译时就将接口、实现类、代理类一股脑儿全部手动完成，但如果我们需要很多的代理，每一个都这么手动的去创建实属浪费时间，而且会有大量的重复代码，此时我们就可以采用动态代理，动态代理可以在程序运行期间根据需要动态的创建代理类及其实例，来完成具体的功能</li>
<li>2.动态代理<br>动态代理类：在程序运行时，运用反射机制动态创建而成。</li>
</ul>
<p>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。<br>静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。</p>
<p>静态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>动态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-如何将一个Java对象序列化到文件"><a href="#4-如何将一个Java对象序列化到文件" class="headerlink" title="4. 如何将一个Java对象序列化到文件"></a>4. 如何将一个Java对象序列化到文件</h3><p>让对象实现Serializable接口或者Parcelable接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public void saveObjToFile(Person p)&#123;  </div><div class="line">     try &#123;  </div><div class="line">         //写对象流的对象  </div><div class="line">         ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(fileName));  </div><div class="line">           </div><div class="line">         oos.writeObject(p);                 //将Person对象p写入到oos中  </div><div class="line">           </div><div class="line">         oos.close();                        //关闭文件流  </div><div class="line">     &#125; catch (FileNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (IOException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125;   </div><div class="line"> &#125;  </div><div class="line">   </div><div class="line"> /* </div><div class="line">  * 从文件中读出对象，并且返回Person对象 </div><div class="line">  */  </div><div class="line"> public Person getObjFromFile()&#123;  </div><div class="line">     try &#123;  </div><div class="line">         ObjectInputStream ois=new ObjectInputStream(new FileInputStream(fileName));  </div><div class="line">           </div><div class="line">         Person person=(Person)ois.readObject();              //读出对象  </div><div class="line">           </div><div class="line">         return person;                                       //返回对象  </div><div class="line">     &#125; catch (FileNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (IOException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (ClassNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125;  </div><div class="line">       </div><div class="line">     return null;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-Java反射的理解"><a href="#5-Java反射的理解" class="headerlink" title="5. Java反射的理解"></a>5. Java反射的理解</h3><h4 id="反射的含义"><a href="#反射的含义" class="headerlink" title="反射的含义"></a>反射的含义</h4><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性</p>
<p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br> 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类；</li>
<li>2.在运行时构造任意一个类的对象；</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>4.在运行时调用任意一个对象的方法<blockquote>
<p>重点：是运行时而不是编译时</p>
</blockquote>
</li>
</ul>
<h4 id="反射的运用"><a href="#反射的运用" class="headerlink" title="反射的运用"></a>反射的运用</h4><p>1、获得Class对象</p>
<hr>
<p>方法有三种</p>
<ul>
<li><p>(1)使用Class类的forName静态方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static Class&lt;?&gt; forName(String className)</div></pre></td></tr></table></figure>
<ul>
<li>(2)直接获取某一个对象的class，比如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> Class&lt;?&gt; klass = int.class;</div><div class="line">Class&lt;?&gt; classInt = Integer.TYPE;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(3)调用某个对象的getClass()方法,比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuilder str = new StringBuilder(&quot;123&quot;);</div><div class="line">Class&lt;?&gt; klass = str.getClass();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>2、判断是否为某个类的实例</p>
<hr>
<p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public native boolean isInstance(Object obj);</div></pre></td></tr></table></figure></p>
<p>3、创建实例</p>
<hr>
<p>通过反射来生成对象主要有两种方式。</p>
<ul>
<li><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">Object str = c.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//获取String所对应的Class对象</div><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">//获取String类带一个String参数的构造器</div><div class="line">Constructor constructor = c.getConstructor(String.class);</div><div class="line">//根据构造器创建实例</div><div class="line">Object obj = constructor.newInstance(&quot;23333&quot;);</div><div class="line">System.out.println(obj);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>4、获取方法</p>
<hr>
<p>获取某个Class对象的方法集合，主要有以下几个方法：<br>getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public Method[] getDeclaredMethods() throws SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Method[] getMethods() throws SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>getMethod 中方法 需要是public，才能获取到</p>
</blockquote>
<p>用例子说明一下，加深理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void testReflect()&#123;</div><div class="line">    try &#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(&quot;hard.uistudy.dai.uifinaltest.main.view.activity.MainActivity6&quot;);</div><div class="line">        try &#123;</div><div class="line">            Object object =  cls.newInstance();</div><div class="line">          Method[] methods =  cls.getMethods();</div><div class="line">          Method[] declaredMethods = cls.getDeclaredMethods();</div><div class="line">            for (Method m: methods) &#123;</div><div class="line">                Log.e(&quot;method&quot;,m.toString());</div><div class="line">            &#125;</div><div class="line">            for (Method m: declaredMethods) &#123;</div><div class="line">                Log.e(&quot;declaredMethods&quot;,m.toString());</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、获取构造器信息</p>
<hr>
<p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public T newInstance(Object ... initargs)</div></pre></td></tr></table></figure></p>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</p>
<p>6、获取类的成员变量（字段）信息</p>
<hr>
<p>主要是这几个方法，在此不再赘述：<br>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void testReflect()&#123;</div><div class="line">       try &#123;</div><div class="line">           Class&lt;?&gt; cls = Class.forName(&quot;hard.uistudy.dai.uifinaltest.main.view.activity.MainActivity6&quot;);</div><div class="line">           try &#123;</div><div class="line">             Object object =  cls.newInstance();</div><div class="line">             Method[] methods =  cls.getMethods();</div><div class="line">             Field[] fields = cls.getDeclaredFields();</div><div class="line">             for (Field field: fields ) &#123;</div><div class="line">                   Log.e(&quot;Field&quot;,field.toString());</div><div class="line">             &#125;</div><div class="line">           &#125; catch (InstantiationException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125; catch (IllegalAccessException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125;</div><div class="line">       &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>7、调用方法</p>
<hr>
<p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Object invoke(Object obj, Object... args)</div><div class="line">        throws IllegalAccessException, IllegalArgumentException,</div><div class="line">           InvocationTargetException</div></pre></td></tr></table></figure></p>
<p>参考下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class test1 &#123;</div><div class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</div><div class="line">        Class&lt;?&gt; klass = methodClass.class;</div><div class="line">        //创建methodClass的实例</div><div class="line">        Object obj = klass.newInstance();</div><div class="line">        //获取methodClass类的add方法</div><div class="line">        Method method = klass.getMethod(&quot;add&quot;,int.class,int.class);</div><div class="line">        //调用method对应的方法 =&gt; add(1,4)</div><div class="line">        Object result = method.invoke(obj,1,4);</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class methodClass &#123;</div><div class="line">    public final int fuck = 3;</div><div class="line">    public int add(int a,int b) &#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">    public int sub(int a,int b) &#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>8、利用反射创建数组</p>
<hr>
<p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void testArray() throws ClassNotFoundException &#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;);</div><div class="line">        Object array = Array.newInstance(cls,25);</div><div class="line">        //往数组里添加内容</div><div class="line">        Array.set(array,0,&quot;hello&quot;);</div><div class="line">        Array.set(array,1,&quot;Java&quot;);</div><div class="line">        Array.set(array,2,&quot;fuck&quot;);</div><div class="line">        Array.set(array,3,&quot;Scala&quot;);</div><div class="line">        Array.set(array,4,&quot;Clojure&quot;);</div><div class="line">        //获取某一项的内容</div><div class="line">        System.out.println(Array.get(array,3));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。<br>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>
<hr>
<pre><code>原文: http://www.sczyh30.com/posts/Java/java-reflection-1/　　作者: sczyh30
</code></pre><hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java 进阶  ------ 时间复杂度对比" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java 进阶  ------ 时间复杂度对比/" class="article-date">
      <time datetime="2018-08-24T07:14:50.300Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java 进阶  ------ 时间复杂度对比/">Java 进阶  ------ 时间复杂度对比</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>  通常，对于一个给定的算法，我们要做 两项分析。第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。而在证明算法是正确的基础上，第二部就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。因此，作为程序员，掌握基本的算法时间复杂度分析方法是很有必要的。<br>       算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。</p>
<h3 id="1-算法的效率"><a href="#1-算法的效率" class="headerlink" title="1.算法的效率"></a>1.算法的效率</h3><p>虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率。<br>算法的效率主要由以下两个复杂度来评估：<br>时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。<br>空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。</p>
<p>设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。</p>
<h3 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h3><p>时间频度<br>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p>时间复杂度<br>前面提到的时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。</p>
<h3 id="3-大O表示法"><a href="#3-大O表示法" class="headerlink" title="3.大O表示法"></a>3.大O表示法</h3><p>像前面用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。<br>算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度。<br>大O表示法O(f(n)中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。</p>
<h4 id="推导大O阶"><a href="#推导大O阶" class="headerlink" title="推导大O阶"></a>推导大O阶</h4><p>推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法：<br>1.用常数1来取代运行时间中所有加法常数。<br>2.修改后的运行次数函数中，只保留最高阶项<br>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p>
<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>先举了例子，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int sum = 0,n = 100; //执行一次  </div><div class="line">sum = (1+n)*n/2; //执行一次  </div><div class="line">System.out.println (sum); //执行一次</div></pre></td></tr></table></figure></p>
<p>上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。如果sum = （1+n）*n/2这条语句再执行10遍，因为这与问题大小n的值并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶。</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>线性阶主要要分析循环结构的运行情况，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;n;i++)&#123;</div><div class="line">//时间复杂度为O(1)的算法</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面算法循环体中的代码执行了n次，因此时间复杂度为O(n)。</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><p>接着看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int number=1;</div><div class="line">while(number&lt;n)&#123;</div><div class="line">number=number*2;</div><div class="line">//时间复杂度为O(1)的算法</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>下面的代码是循环嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;n;i++)&#123;   </div><div class="line">    for(int j=0;j&lt;n;i++)&#123;</div><div class="line">       //复杂度为O(1)的算法</div><div class="line">       ... </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内层循环的时间复杂度在讲到线性阶时就已经得知是O(n)，现在经过外层循环n次，那么这段算法的时间复杂度则为O(n²)。<br>接下来我们来算一下下面算法的时间复杂度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;n;i++)&#123;   </div><div class="line">    for(int j=i;j&lt;n;i++)&#123;</div><div class="line">       //复杂度为O(1)的算法</div><div class="line">       ... </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是内循环中int j=i，而不是int j=0。当i=0时，内循环执行了n次；i=1时内循环执行了n-1次，当i=n-1时执行了1次，我们可以推算出总的执行次数为：</p>
<p>n+(n-1)+(n-2)+(n-3)+……+1<br>=(n+1)+[(n-1)+2]+[(n-2)+3]+[(n-3)+4]+……<br>=(n+1)+(n+1)+(n+1)+(n+1)+……<br>=(n+1)n/2<br>=n(n+1)/2<br>=n²/2+n/2</p>
<p>根据此前讲过的推导大O阶的规则的第二条：只保留最高阶，因此保留n²/2。根据第三条去掉和这个项的常数，则去掉1/2,最终这段代码的时间复杂度为O(n²)。</p>
<h4 id="其他常见复杂度"><a href="#其他常见复杂度" class="headerlink" title="其他常见复杂度"></a>其他常见复杂度</h4><p>除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度： </p>
<ul>
<li>f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。 </li>
<li>f(n)=n³时，时间复杂度为O(n³)，可以称为立方阶。 </li>
<li>f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。 </li>
<li>f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。 </li>
<li>f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶。</li>
</ul>
<h3 id="4-复杂度的比较"><a href="#4-复杂度的比较" class="headerlink" title="4.复杂度的比较"></a>4.复杂度的比较</h3><p>下面将算法中常见的f(n)值根据几种典型的数量级来列成一张表，根据这种表，我们来看看各种算法复杂度的差异。</p>
<table>
<thead>
<tr>
<th>n</th>
<th>logn</th>
<th>√n</th>
<th>nlogn</th>
<th>n²</th>
<th>2ⁿ</th>
<th>n!</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>2</td>
<td>2</td>
<td>10</td>
<td>25</td>
<td>32</td>
<td>120</td>
</tr>
<tr>
<td>10</td>
<td>3</td>
<td>3</td>
<td></td>
<td>30</td>
<td>100</td>
<td>1024</td>
<td>3628800</td>
</tr>
<tr>
<td>50</td>
<td>5</td>
<td>7</td>
<td>250</td>
<td>2500</td>
<td>约10^15</td>
<td>约3.0*10^64</td>
</tr>
<tr>
<td>100</td>
<td>6</td>
<td>10</td>
<td>600</td>
<td>10000</td>
<td>约10^30</td>
<td>约9.3*10^157</td>
</tr>
<tr>
<td>1000</td>
<td>9</td>
<td>31</td>
<td>9000</td>
<td>1000 000</td>
<td>约10^300</td>
<td>约4.0*10^2567</td>
</tr>
</tbody>
</table>
<p>从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。</p>
<p>下面给出一个更加直观的图：<br>这里写图片描述</p>
<p>其中x轴代表n值，y轴代表T(n)值（时间复杂度）。T(n)值随着n的值的变化而变化，其中可以看出O(n!)和O(2ⁿ)随着n值的增大，它们的T(n)值上升幅度非常大，而O(logn)、O(n)、O(nlogn)随着n值的增大，T(n)值上升幅度则很小。<br>常用的时间复杂度按照耗费的时间从小到大依次是：</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/itachi85/article/details/54882603" target="_blank" rel="external">https://blog.csdn.net/itachi85/article/details/54882603</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JVM DVM ART对比" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/JVM DVM ART对比/" class="article-date">
      <time datetime="2018-08-24T07:14:07.614Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/JVM DVM ART对比/">Android 进阶  ------ JVM DVM ART对比</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Android系统使用Dalvik Virtual Machine (DVM)作为其虚拟机，所有安卓程序都运行在安卓系统进程里，每个进程对应着一个Dalvik虚拟机实例。他们都提供了对象生命周期管理、堆栈管理、线程管理、安全和异常管理以及垃圾回收等重要功能，各自拥有一套完整的指令系统。</p>
<p>Android之所以不直接使用JVM作为其虚拟机的原因有很多，版权问题我们暂且搁置一边，本文将首先在技术上对DVM和JVM进行比较，然后重点对Dalvik虚拟机的垃圾回收机制进行介绍，文章末尾再对Android5.0之后使用的新型虚拟机——ART虚拟机进行简单介绍</p>
<h3 id="DVM-vs-JVM"><a href="#DVM-vs-JVM" class="headerlink" title="DVM vs JVM"></a>DVM vs JVM</h3><h5 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h5><ul>
<li>都是解释执行</li>
<li>都是每个 OS 进程运行一个 VM，并运行一个单独的程序</li>
<li>在较新版本中（Froyo / Sun JDK 1.5）都实现了相当程度的 JIT compiler（即时编译） 用于提速。<ul>
<li>JIT（Just In Time，即时编译技术）对于热代码（使用频率高的字节码）直接转换成汇编代码；</li>
</ul>
</li>
</ul>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><ul>
<li><p>dvm执行的是.dex格式文件，jvm执行的是.class文件。class文件和dex之间可以相互转换具体流程如下图，多个class文件转变成一个dex文件会引发一些问题，具体如下：</p>
<ul>
<li>方法数受限：多个class文件变成一个dex文件所带来的问题就是方法数超过65535时报错，由此引出MultiDex技术，具体资料同学可以google下。</li>
<li>class文件去冗余：class文件存在很多的冗余信息，dex工具会去除冗余信息(多个class中的字符串常量合并为一个，比如对于Ljava/lang/Oject字符常量，每个class文件基本都有该字符常量，存在很大的冗余)，并把所有的.class文件整合到.dex文件中。减少了I/O操作，提高了类的查找速度。</li>
</ul>
</li>
<li><p>许多GC实现都是在对象开头的地方留一小块空间给GC标记用。Dalvik VM则不同，在进行GC的时候会单独申请一块空间，以位图的形式来保存整个堆上的对象的标记，在GC结束后就释放该空间。 （关于这一点后面的Dalvik垃圾回收机制还会更加深入的介绍）</p>
</li>
<li>dvm是基于寄存器的虚拟机 而jvm执行是基于虚拟栈的虚拟机。这类的不同是最要命的，因为它将导致一系列的问题，具体如下：<ul>
<li>dvm速度快！寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。JAVA虚拟机基于栈结构，程序在运行时虚拟机需要频繁的从栈上读取写入数据，这个过程需要更多的指令分派与内存访问次数，会耗费很多CPU时间。<ul>
<li>指令数小！dvm基于寄存器，所以它的指令是二地址和三地址混合，指令中指明了操作数的地址；jvm基于栈，它的指令是零地址，指令的操作数对象默认是操作数栈中的几个位置。这样带来的结果就是dvm的指令数相对于jvm的指令数会小很多，jvm需要多条指令而dvm可能只需要一条指令。 </li>
<li>jvm基于栈带来的好处是可以做的足够简单，真正的跨平台，保证在低硬件条件下能够正常运行。而dvm操作平台一般指明是ARM系统，所以采取的策略有所不同。需要注意的是dvm基于寄存器，但是这也是个映射关系，如果硬件没有足够的寄存器，dvm将多出来的寄存器映射到内存中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h3><p>谈到垃圾回收自然而然的想到了堆，Dalvik的堆结构相对于JVM的堆结构有所区别，这主要体现在Dalvik将堆分成了Active堆和Zygote堆，这里大家只要知道Zygote堆是Zygote进程在启动的时候预加载的类、资源和对象(具体gygote进程预加载了哪些类，详见文末的附录)，除此之外的所有对象都是存储在Active堆中的。对于为何要将堆分成gygote和Active堆，这主要是因为Android通过fork方法创建到一个新的gygote进程，为了尽可能的避免父进程和子进程之间的数据拷贝，fork方法使用写时拷贝技术，写时拷贝技术简单讲就是fork的时候不立即拷贝父进程的数据到子进程中，而是在子进程或者父进程对内存进行写操作时是才对内存内容进行复制，Dalvik的gygote堆存放的预加载的类都是Android核心类和java运行时库，这部分内容很少被修改，大多数情况父进程和子进程共享这块内存区域。通常垃圾回收重点对Active堆进行回收操作，Dalvik为了对堆进行更好的管理创建了一个Card Table、两个Heap Bitmap和一个Mark Stack数据结构。</p>
<ul>
<li><p>关于 Zygote,有一些参考资料<br><a href="https://www.cnblogs.com/bRAyKpoyNt/p/3649417.html" target="_blank" rel="external">ZYGOTE浅谈</a></p>
<h5 id="Dalvik创建对象流程"><a href="#Dalvik创建对象流程" class="headerlink" title="Dalvik创建对象流程"></a>Dalvik创建对象流程</h5><p>当Dalvik虚拟机的解释器遇到一个new指令时，它就会调用函数Object<em> dvmAllocObject(ClassObject</em> clazz, int flags)。期间完成的动作有( 注意：Java堆分配内存前后，要对Java堆进行加锁和解锁，避免多个线程同时对Java堆进行操作。下面所说的堆指的是Active堆)：</p>
<p>1.调用函数dvmHeapSourceAlloc在Java堆上分配指定大小的内存，成功则返回，否则下一步。<br>2.执行一次GC， GC执行完毕后，再次调用函数dvmHeapSourceAlloc在Java堆上分配指定大小的内存，成功则返回，否则下一步。<br>3.首先将堆的当前大小设置为Dalvik虚拟机启动时指定的Java堆最大值，然后进行内存分配，成功返回失败下一步。这里调用的函数是dvmHeapSourceAllocAndGrow<br>4.调用函数gcForMalloc来执行GC，这里的GC和第二步的GC，区别在于这里回收软引用对象引用的对象，如果还是失败抛出OOM异常。这里调用的函数是dvmHeapSourceAllocAndGrow</p>
</li>
</ul>
<h4 id="Dalvik回收对象流程"><a href="#Dalvik回收对象流程" class="headerlink" title="Dalvik回收对象流程"></a>Dalvik回收对象流程</h4><p>Dalvik的垃圾回收策略默认是标记擦除回收算法，即Mark和Sweep两个阶段。标记与清理的回收算法一个明显的区别就是会产生大量的垃圾碎片，因此程序中应该避免有大量不连续小碎片的时候分配大对象，同时为了解决碎片问题，Dalvik虚拟机通过使用dlmalloc技术解决，关于后者读者另行google。下面我们对Mark阶段进行简单介绍。</p>
<p>Mark阶段使用了两个Bitmap来描述堆的对象，一个称为Live Bitmap，另一个称为Mark Bitmap。Live Bitmap用来标记上一次GC时被引用的对象，也就是没有被回收的对象，而Mark Bitmap用来标记当前GC有被引用的对象。当Live Bitmap被标记为1，但是在Mark Bitmap中标记为0的对象表明该对象需要被回收。</p>
<p>此外在Mark阶段往往要求其它线程处于停止状态，因此Mark又分为并行和串行两种方式，并行的Mark分为两个阶段：1)、只标记gc_root对象，即在GC开始的瞬间被全局变量、栈变量、寄存器等所引用的对象，该阶段不允许垃圾回收线程之外的线程处于运行状态。2)、有条件的并行运行其它线程，使用Card<br> Table记录在垃圾收集过程中对象的引用情况。整个Mark 阶段都是通过Mark Stack来实现递归检查被引用的对象，即在当前GC中存活的对象。标记过程类似用一个栈把第一阶段得到的gc_root放入栈底，然后依次遍历它们所引用的对象(通过出栈入栈)，即用栈数据结构实现了对每个gc_root的递归。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Handler系列之创建子线程Handler" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Handler系列之创建子线程Handler/" class="article-date">
      <time datetime="2018-08-24T07:12:46.105Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Handler系列之创建子线程Handler/">Android 进阶  ------ Handler系列之创建子线程Handler</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>上一篇我介绍了Handler机制的工作原理，默认情况下，ActivityThread类为我们创建的了主线程的Looper和消息队列，所以当你创建Handler之后发送消息的时候，消息的轮训和handle都是在ui线程进行的。这种情况属于子线程给主线程发消息，通知主线程更新ui…等，那么反过来，怎么才能让主线程给子线程发消息，通知子线程做一些耗时逻辑？？</p>
<p>　　之前的学习我们知道，Android的消息机制遵循三个步骤：</p>
<ul>
<li><p>1　创建当前线程的Looper　　</p>
</li>
<li><p>2　创建当前线程的Handler　</p>
</li>
<li><p>3　调用当前线程Looper对象的loop方法</p>
</li>
</ul>
<p>　　看过之前文章的朋友会注意到，本篇我特意强调了“当前线程”。是的之前我们学习的很多都是Android未我们做好了的，譬如：创建主线程的Looper、主线程的消息队列…就连我们使用的handler也是主线程的。那么如果我想创建非主线程的Handler并且发送消息、处理消息，这一系列的操作我们应该怎么办那？？？不怎么办、凉拌～～～什么意思？？？依葫芦画瓢，依然遵循上面的三步走，直接上代码！！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class ChildThreadHandlerActivity extends Activity &#123;</div><div class="line">    private MyThread childThread;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler);</div><div class="line"></div><div class="line">        childThread = new MyThread();</div><div class="line">        childThread.start();</div><div class="line"></div><div class="line">        Handler childHandler = new Handler(childThread.childLooper)&#123;//这样之后，childHandler和childLooper就关联起来了。</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                </div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class MyThread extends Thread&#123;</div><div class="line">        public Looper childLooper;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            Looper.prepare();//创建与当前线程相关的Looper</div><div class="line">            childLooper = Looper.myLooper();//获取当前线程的Looper对象</div><div class="line">            Looper.loop();//调用此方法，消息才会循环处理</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码如上，我们依然循序Android的三步走战略，完成了子线程Handler的创建，难道这样创建完了，就可以发消息了么？发的消息在什么线程处理？一系列的问题，怎么办？看代码！！！运行上述代码，我们发现一个问题，就是此代码一会崩溃、一会不崩溃，通过查看日志我们看到崩溃的原因是空指针。谁为空？？？查到是我们的Looper对象，怎么会那？我不是在子线程的run方法中初始化Looper对象了么？话是没错，但是你要知道，当你statr子线程的时候，虽然子线程的run方法得到执行，但是主线程中代码依然会向下执行，造成空指针的原因是当我们new Handler(childThread.childLooper)的时候，run方法中的Looper对象还没初始化。当然这种情况是随机的，所以造成偶现的崩溃。</p>
<p>　　那怎么办？难道我们不能创建子线程Handler ？？？No!!!No!!!No!!!，你能想到的Android早就为我们实现好了，HandlerThread类就是解决这个问题的关键所在，看代码！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class HandlerThreadActivity extends Activity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler);</div><div class="line">        TextView textView = (TextView) findViewById(R.id.tv);</div><div class="line">        textView.setText(&quot;HandlerThreadActivity.class&quot;);</div><div class="line"></div><div class="line">        HandlerThread handlerThread = new HandlerThread(&quot;HandlerThread&quot;);</div><div class="line">        handlerThread.start();</div><div class="line"></div><div class="line">        Handler mHandler = new Handler(handlerThread.getLooper())&#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                super.handleMessage(msg);</div><div class="line">                Log.d(&quot;HandlerThreadActivity.class&quot;,&quot;uiThread2------&quot;+Thread.currentThread());//子线程</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Log.d(&quot;HandlerThreadActivity.class&quot;,&quot;uiThread1------&quot;+Thread.currentThread());//主线程</div><div class="line">        mHandler.sendEmptyMessage(1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建HandlerThread对象的时候，有个参数，是指定线程名字的。上面的代码不管运行多少次都不会奔溃！！！并且这种方法创建的handler的handleMessage方法运行在子线程中。所以我们可以在这里处理一些耗时的逻辑。到此我们完成了主线程给子线程发通知，在子线程做耗时逻辑的操作。</p>
<p>　　下面我们去看看源码，看看为什么使用HandlerThread就可以避免空指针那？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public Looper getLooper() &#123;</div><div class="line">    if (!isAlive()) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // If the thread has been started, wait until the looper has been created.</div><div class="line">    synchronized (this) &#123;</div><div class="line">        while (isAlive() &amp;&amp; mLooper == null) &#123;</div><div class="line">            try &#123;</div><div class="line">                wait();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return mLooper;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HandlerThread类的getLooper方法如上，我们看到当我们获取当前线程Looper对象的时候，会先判断当前线程是否存活，然后还要判断Looper对象是否为空，都满足之后才会返回给我Looper对象，否则处于等待状态！！既然有等待，那就有唤醒的时候，在那里那？？？我们发现HandlerThread的run方法中，有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明了什么那？？？HandlerThread类start的时候，Looper对象就初始化了，并唤醒之前等待的。所以HandlerThread很好的避免了之前空指针的产生。所以以后要想创建非主线程的Handler时，我们用HandlerThread类提供的Looper对象即可。</p>
<hr>
<p>参考<br><a href="https://www.cnblogs.com/lang-yu/p/6228832.html" target="_blank" rel="external">https://www.cnblogs.com/lang-yu/p/6228832.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶 ——— 使用SparseArray和ArrayMap代替HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android进阶 ——— 使用SparseArray和ArrayMap代替HashMap/" class="article-date">
      <time datetime="2018-08-24T07:06:38.651Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android进阶 ——— 使用SparseArray和ArrayMap代替HashMap/">Android进阶 ——— 使用SparseArray和ArrayMap代替HashMap</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Android开发时，我们使用的大部分都是Java的api，比如HashMap这个api，使用率非常高，但是对于Android这种对内存非常敏感的移动平台，很多时候使用一些java的api并不能达到更好的性能，相反反而更消耗内存，所以针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray、ArrayMap用来代替HashMap在有些情况下能带来更好的性能提升。</p>
<p>介绍它们之前先来介绍一下HashMap的内部存储结构，就明白为什么推荐使用SparseArray和ArrayMap</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap内部是使用一个默认容量为16的数组来存储数据的，而数组中每一个元素却又是一个链表的头结点，所以，更准确的来说，HashMap内部存储结构是使用哈希表的拉链结构（数组+链表），如图：<br>这种存储数据的方法叫做拉链法 </p>
<p><img src="https://img-blog.csdn.net/20150820130200565" alt=""></p>
<p>且每一个结点都是Entry类型，那么Entry是什么呢？我们来看看HashMap中Entry的属性：</p>
<blockquote>
<p>final K key;<br>V value;<br>final int hash;<br>HashMapEntry<k, v=""> next;</k,></p>
</blockquote>
<p>从中我们得知Entry存储的内容有key、value、hash值、和next下一个Entry，那么，这些Entry数据是按什么规则进行存储的呢？就是通过计算元素key的hash值，然后对HashMap中数组长度取余得到该元素存储的位置，计算公式为hash(key)%len，比如：假设hash(14)=14,hash(30)=30,hash(46)=46，我们分别对len取余，得到<br>hash(14)%16=14，hash(30)%16=14，hash(46)%16=14，所以key为14、30、46的这三个元素存储在数组下标为14的位置，如：</p>
<p><img src="https://img-blog.csdn.net/20150820133048242" alt=""></p>
<p>从中可以看出，如果有多个元素key的hash值相同的话，后一个元素并不会覆盖上一个元素，而是采取链表的方式，把之后加进来的元素加入链表末尾，从而解决了hash冲突的问题，由此我们知道HashMap中处理hash冲突的方法是链地址法，在此补充一个知识点，处理hash冲突的方法有以下几种：</p>
<ul>
<li>开放地址法</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区</li>
</ul>
<p>讲到这里，重点来了，我们知道HashMap中默认的存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap对象时，即使里面没有任何元素，也要分别一块内存空间给它，而且，我们再不断的向HashMap里put数据时，当达到一定的容量限制时（这个容量满足这样的一个关系时候将会扩容：HashMap中的数据量&gt;容量*加载因子，而HashMap中默认的加载因子是0.75），HashMap的空间将会扩大，而且扩大后新的空间一定是原来的2倍，我们可以看put()方法中有这样的一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int newCapacity = oldCapacity * 2;</div></pre></td></tr></table></figure></p>
<p>所以，重点就是这个，只要一满足扩容条件，HashMap的空间将会以2倍的规律进行增大。假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费，而且HashMap获取数据是通过遍历Entry[]数组来得到对应的元素，在数据量很大时候会比较慢，所以在Android中，HashMap是比较费内存的，我们在一些情况下可以使用SparseArray和ArrayMap来代替HashMap。</p>
<h3 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h3><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源码中可以看到key和value分别是用数组表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private int[] mKeys;</div><div class="line">private Object[] mValues;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，SparseArray只能存储key为int类型的数据，同时，SparseArray在存储和读取数据时候，使用的是二分查找法，我们可以看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void put(int key, E value) &#123;</div><div class="line">       int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</div><div class="line">       ...</div><div class="line">       &#125;</div><div class="line">public E get(int key, E valueIfKeyNotFound) &#123;</div><div class="line">       int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</div><div class="line">       ...</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从小到大的顺序排列好，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。 </p>
<p>而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。</p>
<h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void put(int key, E value)</div></pre></td></tr></table></figure>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void remove(int key)</div></pre></td></tr></table></figure>
<p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void delete(int key)</div></pre></td></tr></table></figure></p>
<p>其实remove内部还是通过调用delete来删除数据的</p>
<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public E get(int key)</div></pre></td></tr></table></figure>
<p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public E get(int key, E valueIfKeyNotFound)</div></pre></td></tr></table></figure></p>
<p>该方法可设置如果key不存在的情况下默认返回的value</p>
<h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p>在此之外，SparseArray还提供了两个特有方法，更方便数据的查询：<br>获取对应的key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public int keyAt(int index)</div></pre></td></tr></table></figure></p>
<p>获取对应的value：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public E valueAt(int index)</div></pre></td></tr></table></figure></p>
<p>SparseArray应用场景：<br>虽说SparseArray性能比较好，但是由于其添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%。</p>
<p>满足下面两个条件我们可以使用SparseArray代替HashMap：</p>
<p>数据量不大，最好在千级以内<br>key必须为int类型，这中情况下的HashMap可以用SparseArray代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;();</div><div class="line">用SparseArray代替:</div><div class="line">SparseArray&lt;Object&gt; array = new SparseArray&lt;&gt;();</div></pre></td></tr></table></figure></p>
<h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><p>这个api的资料在网上可以说几乎没有，然并卵，只能看文档了<br>ArrayMap是一个<key,value>映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。</key,value></p>
<h4 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value)</div></pre></td></tr></table></figure>
<h4 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public V get(Object key)</div></pre></td></tr></table></figure>
<h4 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public V remove(Object key)</div></pre></td></tr></table></figure>
<h4 id="特有方法-1"><a href="#特有方法-1" class="headerlink" title="特有方法"></a>特有方法</h4><p>它和SparseArray一样同样也有两个更方便的获取数据方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public K keyAt(int index)</div><div class="line">public V valueAt(int index)</div></pre></td></tr></table></figure></p>
<p>ArrayMap应用场景<br>数据量不大，最好在千级以内<br>数据结构类型为Map类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayMap&lt;Key, Value&gt; arrayMap = new ArrayMap&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>【注】：如果我们要兼容aip19以下版本的话，那么导入的包需要为v4包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import android.support.v4.util.ArrayMap;</div></pre></td></tr></table></figure></p>
<p>总结<br>SparseArray和ArrayMap都差不多，使用哪个呢？<br>假设数据量都在千级以内的情况下：</p>
<blockquote>
<p>1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用<br>2、如果key类型为其它的类型，则使用ArrayMap</p>
</blockquote>
<p>参考</p>
<hr>
<p><a href="https://blog.csdn.net/u010687392/article/details/47809295" target="_blank" rel="external">https://blog.csdn.net/u010687392/article/details/47809295</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java设计模式 ——— 工厂模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java设计模式 ——— 工厂模式/" class="article-date">
      <time datetime="2018-08-24T07:05:45.715Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java设计模式 ——— 工厂模式/">Java设计模式 ——— 工厂模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式的模型非常简单，定义一个抽象类及抽象方法，具体产品类继承抽象类，在简单工厂类中提供具体产品，供给客户端使用<br><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160818224552500-264215677.png" alt=""></p>
<p>例如，一家餐馆，可以提供多种食品，供用户选择：</p>
<ul>
<li><p>定义抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">抽象类</div><div class="line">*/</div><div class="line">public abstract class SimpleFood &#123;</div><div class="line">	/**</div><div class="line">	 * 提供食物</div><div class="line">	 */</div><div class="line">	public abstract void food();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>提供面条–具体产品类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 具体产品类</div><div class="line"> */</div><div class="line">public class Noodles extends SimpleFood &#123;</div><div class="line">	@Override</div><div class="line">	public void food() &#123;</div><div class="line">		System.out.println(&quot;面条&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>提供米饭–具体产品类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 具体产品类</div><div class="line"> */</div><div class="line">public class Rice extends SimpleFood &#123;</div><div class="line">	@Override</div><div class="line">	public void food() &#123;</div><div class="line">		System.out.println(&quot;米饭&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>准备工作结束，创建餐馆–简单工厂类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SimpleFoodFactory &#123;</div><div class="line"></div><div class="line">	public static final int TYPE_NOODLES = 1;//面条</div><div class="line">	public static final int TYPE_RICE = 2;//米饭</div><div class="line"></div><div class="line"></div><div class="line">	public static SimpleFood createFood(int type) &#123;</div><div class="line">		switch (type) &#123;</div><div class="line">			case TYPE_NOODLES:</div><div class="line">				return new Noodles();</div><div class="line">			case TYPE_RICE:</div><div class="line">				return new Rice();</div><div class="line">			default:</div><div class="line">				return new Rice();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>客人点餐，指明要吃的食物，只要有原料，就可以提供：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SimpleFood food =  SimpleFoodFactory.createFood(SimpleFoodFactory.TYPE_RICE);</div><div class="line">food.food();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>这个和简单工厂有区别，简单工厂模式只有一个工厂，工厂方法模式对每一个产品都有相应的工厂。<br><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160818230715265-504425871.png" alt=""></p>
<p>同样是一家餐馆，可以提供食物</p>
<ul>
<li><p>创建基类，声明创建食物的方法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract class Food &#123;</div><div class="line">	public abstract void createFood();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>声明工厂类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract class FoodStore &#123;</div><div class="line">	public abstract Food createFood(String type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>构建两个窗口，一个卖面工厂，一个卖盖饭工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class NoodlesStore extends FoodStore &#123;</div><div class="line">	@Override</div><div class="line">	public Food createFood(String type) &#123;</div><div class="line">		if (type.equals(&quot;lznoodles&quot;)) &#123;</div><div class="line">			return new LZNoodles();</div><div class="line">		&#125; else if (type.equals(&quot;cqnoodles&quot;)) &#123;</div><div class="line">			return new CQNoodles();</div><div class="line">		&#125; else return null;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class RiceStore extends FoodStore &#123;</div><div class="line">	@Override</div><div class="line">	public Food createFood(String type) &#123;</div><div class="line">		if (type.equals(&quot;yuxiangrousi&quot;)) &#123;</div><div class="line">			return new YXRSRice();</div><div class="line">		&#125; else if (type.equals(&quot;huiguorou&quot;)) &#123;</div><div class="line">			return new HGRRice();</div><div class="line">		&#125; else return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>客户端，点餐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> RiceStore store = new RiceStore();</div><div class="line"> Food food = store.createFood(&quot;YXRS&quot;);</div><div class="line"></div><div class="line">NoodlesStore noodlesStore = new NoodlesStore();</div><div class="line">Food food1 =  noodlesStore.createFood(&quot;CQNoodles&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h3><p>定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p>
<p><img src="http://hi.csdn.net/attachment/201203/16/0_13318591595Q24.gif" alt=""></p>
<p>现在餐馆不仅有食物，还有饮料，提供饮料抽象类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public abstract class IDrinks &#123;</div><div class="line">	/**</div><div class="line">	 * 饮料价格</div><div class="line">	 */</div><div class="line">	public abstract void prices();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>具体产品类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ColaDrinks extends IDrinks &#123;</div><div class="line">	@Override</div><div class="line">	public void prices() &#123;</div><div class="line">		System.out.println(&quot;可乐三块五&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class WaterDrinks extends IDrinks &#123;</div><div class="line">	@Override</div><div class="line">	public void prices() &#123;</div><div class="line">		System.out.println(&quot;开水免费！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>为食物和饮料创建总工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class RestaurantFactory &#123;</div><div class="line">	public abstract Food getFood(String type);</div><div class="line">	public abstract IDrinks getDrink(String price) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>具体的食物工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FoodFactory extends RestaurantFactory &#123;</div><div class="line">	@Override</div><div class="line">	public Food getFood(String type) &#123;</div><div class="line">		if (type.equals(&quot;yuxiangrousi&quot;)) &#123;</div><div class="line">			return new YXRSRice();</div><div class="line">		&#125; else if (type.equals(&quot;huiguorou&quot;)) &#123;</div><div class="line">			return new HGRRice();</div><div class="line">		&#125; else if (type.equals(&quot;lznoodles&quot;)) &#123;</div><div class="line">			return new LZNoodles();</div><div class="line">		&#125; else if (type.equals(&quot;cqnoodles&quot;)) &#123;</div><div class="line">			return new CQNoodles();</div><div class="line">		&#125; else return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public IDrinks getDrink(String price) &#123;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>饮料工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class DrinkFactory extends RestaurantFactory &#123;</div><div class="line">	@Override</div><div class="line">	public Food getFood(String type) &#123;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public IDrinks getDrink(int price) &#123;</div><div class="line">		if(price &lt; 3 )&#123;</div><div class="line">			return new WaterDrinks();</div><div class="line">		&#125;else  if (price &gt;= 3)&#123;</div><div class="line">			return new ColaDrinks();</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶 ——— Android官方架构组件Lifecycle" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android进阶 ——— Android官方架构组件Lifecycle/" class="article-date">
      <time datetime="2018-08-24T06:15:50.616Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android进阶 ——— Android官方架构组件Lifecycle/">Android进阶 ——— Android官方架构组件Lifecycle</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>Lifecycle是Android官方推出的架构组件，在谷歌开发者官微发布的<a href="https://mp.weixin.qq.com/s/9rC_5GhdAA_EMEbWKJT5vQ" target="_blank" rel="external">正式发布 Android 架构组件 1.0 稳定版 | 附带中文介绍视频</a><br>简明扼要的阐述了推出的架构组件的作用及使用，也可以查看<a href="https://developer.android.com/reference/androidx/lifecycle/package-summary" target="_blank" rel="external">Android开发者官网</a>。</p>
<p>先来看看架构组件的第一部分Lifecycle。<br>在长篇大论之前，先要了解它的作用，为什么谷歌要推出Lifecycle？</p>
<p>就是为了解决常见架构模式中，声明周期管理的痛点，例如MVP模式：<br>为了管理声明周期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public interface IPresenter &#123;</div><div class="line"></div><div class="line">	void onCreate();</div><div class="line"></div><div class="line">	void onStart();</div><div class="line"></div><div class="line">	void onResume();</div><div class="line"></div><div class="line">	void onPause();</div><div class="line"></div><div class="line">	void onStop();</div><div class="line"></div><div class="line">	void onDestroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继承Ipresenter接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class MainPresenter implements IPresenter &#123;</div><div class="line"></div><div class="line">	public void xxx()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onCreate() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onStart() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onResume() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onPause() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onStop() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onDestroy() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Activity或Fragment中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/8/20</div><div class="line"> * function:lifecycle.example.com.lifecycleexample</div><div class="line"> */</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">	private MainPresenter presenter;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">		presenter = new MainPresenter();</div><div class="line">		presenter.onCreate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onStart() &#123;</div><div class="line">		super.onStart();</div><div class="line">		presenter.onStart();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onResume() &#123;</div><div class="line">		super.onResume();</div><div class="line">		presenter.onResume();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onPause() &#123;</div><div class="line">		super.onPause();</div><div class="line">		presenter.onPause();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onStop() &#123;</div><div class="line">		super.onStop();</div><div class="line">		presenter.onStop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onDestroy() &#123;</div><div class="line">		super.onDestroy();</div><div class="line">		presenter.onDestroy();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要在Activity的每个声明周期中，依次调用接口IPresenter定义的方法，无疑影响开发效率，更麻烦的是，如果忘记调用声明周期的方法，例如APP被销毁，presenter中依然调用UI层，这必然产生严重后果。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Lifecycle就是为了解决这种重复工作的。先来看看如何使用：<br>导入Java8依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &quot;android.arch.lifecycle:common-java8:1.1.1&quot;</div></pre></td></tr></table></figure></p>
<p>继承DefaultLifecycleObserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IPresenter extends DefaultLifecycleObserver &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现生命周期方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MainPresenter implements IPresenter &#123;</div><div class="line"></div><div class="line">	private final String TAG = this.getClass().getSimpleName();</div><div class="line">	public void xxx()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onCreate(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;oncreate&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onStart(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;start&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onResume(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;resume &quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onPause(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;pause&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onStop(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;stop&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onDestroy(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;destory&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Activity中，只需要注册一下，就能完成生命周期的监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">	private MainPresenter presenter;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		presenter = new MainPresenter();</div><div class="line">        //注册</div><div class="line">		getLifecycle().addObserver(presenter);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IPrestener继承DefaultLifecycleObserver,MainPresenter实现IPresenter接口，并实现DefaultLifecycleObserver中定义的方法，可以全部实现，也可以选择需要的生命周期去实现。</p>
<p>了解了Lifecycle的使用，当然也要简单了解一下实现原理，知其然而不知其所以然，不是我们的目的。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h4 id="1-先了解几个重要的类和接口"><a href="#1-先了解几个重要的类和接口" class="headerlink" title="1.先了解几个重要的类和接口"></a>1.先了解几个重要的类和接口</h4><ul>
<li>Lifecycle<br>Lifecycle是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。</li>
<li>Event ：从框架和Lifecycle类派发的生命周期事件。这些事件映射到活动和片段中的回调事件。</li>
<li>State ：由Lifecycle对象跟踪的组件的当前状态。</li>
<li>LifecycleOwner （重要）Lifecycle持有者 （例如Activity、Fragment）<br>实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</li>
<li>LifecycleObserver（重要）Lifecycle观察者<br>实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。</li>
</ul>
<h4 id="2-LifecycleOwner（Lifecycle持有者）"><a href="#2-LifecycleOwner（Lifecycle持有者）" class="headerlink" title="2.LifecycleOwner（Lifecycle持有者）"></a>2.LifecycleOwner（Lifecycle持有者）</h4><blockquote>
<p>官网介绍：LifecycleOwner是一个单一的方法接口，表示该类有一个 Lifecycle。它有一个方法，getLifecycle()这个方法 必须由这个类来实现。如果您试图管理整个应用程序进程的生命周期，请参阅 ProcessLifecycleOwner。该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口<br>实现LifecycleObserver的组件与实现LifecycleOwner的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册以观看</p>
</blockquote>
<p>简单理解：LifecycleOwner就是一个接口，谁继承了它，就持有了lifecycle对象，可以提供生命周期。<br>然后可以调用getLifecycle()方法获取继承了抽象类Lifecycle的LifecycleRegistry，然后调用addObserver(@NonNull LifecycleObserver observer) 方法来注册监听。<br>总而言之：<br><strong>实现该接口的持有者，其生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件</strong></p>
<p><strong>注意：Support Library 26.1.0 及其以后的版本，Activity 和Fragment 已经实现了LifecycleOwner 接口，所以，我们可以直接在Activity 和Fragment中使用getLifecycle()方法来获取lifecycle对象，来添加观察者监听。</strong></p>
<h4 id="3-LifecycleObserver（Lifecycle观察者）"><a href="#3-LifecycleObserver（Lifecycle观察者）" class="headerlink" title="3.LifecycleObserver（Lifecycle观察者）"></a>3.LifecycleObserver（Lifecycle观察者）</h4><blockquote>
<p>LifecycleObserver 是一个观察者接口，实现了它，可以通过注解或者继承的方式，来管理声明周期的监听。只要在持有lifecycle的类中注册了它，当声明周期发生变化时，它就能收到，进行我们自定义的操作。</p>
</blockquote>
<p>简单理解：任何注解或继承实现了该接口，只要在持有Lifecycle的类中注册了，就可以监听到生命周期的变化</p>
<p>两种实现方式：<br>1）、实现DefultLifecyceObserver接口，然后重写里面生命周期方法；<br>2）、直接实现LifecycleObserver接口，然后通过注解的方式来接收生命周期的变化；<br>Lifecycle.java文档中是建议使用第一种方式，因为文档中说明了，随着Java8成为主流，注解的方式会被弃用。DefaultLifecycleObserver是需要另外声明的java8 ，所以上面我们添加了Java8的依赖，再回顾上面的例子：</p>
<p>IPrestener继承<code>DefaultLifecycleObserver</code>,MainPresenter实现IPresenter接口，并实现<code>DefaultLifecycleObserver</code>中定义的方法，而Activity默认实现了<code>LifecycleOwner</code>接口，持有声明周期，最后调用<code>getLifecycle().addObserver(presenter)</code>注册了LifecycleObserver。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android官方架构/">Android官方架构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶 ——— Android官方架构组件LiveData" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android进阶 ——— Android官方架构组件LiveData/" class="article-date">
      <time datetime="2018-08-24T06:15:06.506Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android进阶 ——— Android官方架构组件LiveData/">Android进阶 ——— Android官方架构组件LiveData</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>上一篇文章，学习了Android官方架构组件的第一部分<a href="https://blog.csdn.net/dazhaoDai/article/details/81902704" target="_blank" rel="external">Android进阶 ——— Android官方架构组件Lifecycle</a></p>
</blockquote>
<h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>LiveData 是一个可以感知 Activity 、Fragment生命周期的数据容器。当 LiveData 所持有的数据改变时，它会通知相应的界面代码进行更新。同时，LiveData 持有界面代码 Lifecycle 的引用，这意味着它会在界面代码（LifecycleOwner）的生命周期处于 started 或 resumed 时作出相应更新，而在 LifecycleOwner 被销毁时停止更新。</p>
<blockquote>
<ul>
<li>意味着LiveData可以被观察者订阅，并且感知LifeCycleOwner组件的生命周期。</li>
<li>如果<code>LifecycleOwner</code>的状态为<code>Lifecycle.State.STARTED</code>或<code>Lifecycle.State.RESUMED</code>，才会通知观察者更新</li>
<li>可以通过<code>observeForever（Observer）</code>添加的观察者，使其始终处于活动状态，不仅仅是处于活跃状态。但是这种方式添加的观察者，需要手动调用<code>removeObserver（Observer）</code>解除</li>
</ul>
</blockquote>
<p>上面的描述介绍了LiveData的优点：不用手动控制生命周期，不用担心内存泄露，数据变化时会收到通知。</p>
<p>不仅如此，官方推荐，LiveData和Viewmodel搭配使用，ViewModel是Android官方构件的另一成员。</p>
<blockquote>
<p>ViewModel 将视图的数据和逻辑从具有生命周期特性的实体（如 Activity 和 Fragment）中剥离开来。直到关联的 Activity 或 Fragment 完全销毁时，ViewModel 才会随之消失，也就是说，即使在旋转屏幕导致 Fragment 被重新创建等事件中，视图数据依旧会被保留。ViewModels 不仅消除了常见的生命周期问题，而且可以帮助构建更为模块化、更方便测试的用户界面。</p>
</blockquote>
<p>ViewModel的优点:为Activity 、Fragment存储数据，直到完全销毁。尤其是屏幕旋转的场景，常用的方法都是通过onSaveInstanceState()保存数据，再在onCreate()中恢复，真的是很麻烦。<br>其次因为ViewModel存储了数据，所以ViewModel可以在当前Activity的Fragment中实现数据共享。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>LiveData有几种使用方式：</p>
<ul>
<li>使用LiveData对象</li>
<li>继承LiveData</li>
</ul>
<h4 id="1-使用LiveData对象"><a href="#1-使用LiveData对象" class="headerlink" title="1.使用LiveData对象"></a>1.使用LiveData对象</h4><p>  使用LiveData对象主要有以下几个步骤：</p>
<ul>
<li>创建保存特定数据类型的LiveData实例（ViewModel中）；</li>
<li>创建Observer对象，作为参数传入LiveData.observe()方法，添加观察者；</li>
<li>通过 observe()方法连接观察者和LiveData。observe()方法需要携带一个LifecycleOwner类。这样就可以让观察者订阅LiveData中的数据；</li>
</ul>
<h5 id="创建LiveData实例-一般继承自MutableLiveData"><a href="#创建LiveData实例-一般继承自MutableLiveData" class="headerlink" title="创建LiveData实例,一般继承自MutableLiveData"></a>创建LiveData实例,一般继承自MutableLiveData</h5><p>MutableLiveData是LiveData的子类，添加了公共方法setValue和postValue，方便开发者直接使用。setValue必须在主线程调用。postValue可以在后台线程中调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/8/20</div><div class="line"> * function:lifecycle.example.com.lifecycleexample.LifeCycle</div><div class="line"> */</div><div class="line"></div><div class="line">public class MainViewModel  extends ViewModel&#123;</div><div class="line"></div><div class="line"></div><div class="line">	private MutableLiveData&lt;Student&gt; student =  new MutableLiveData&lt;&gt;();</div><div class="line"></div><div class="line">	public MutableLiveData&lt;Student&gt; getStudent() &#123;</div><div class="line">		return student;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void addStudent()&#123;</div><div class="line">		Student student1 = new Student();</div><div class="line">		student1.setGender(55);</div><div class="line">		student1.setName(&quot;zhangsan&quot;);</div><div class="line">		student.setValue(student1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="创建Observer对象，作为参数添加观察者"><a href="#创建Observer对象，作为参数添加观察者" class="headerlink" title="创建Observer对象，作为参数添加观察者"></a>创建Observer对象，作为参数添加观察者</h5><p>通过LiveData.observe()方法添加观察者，当数据变化时会通过回调方法通知观察者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/8/20</div><div class="line"> * function:lifecycle.example.com.lifecycleexample</div><div class="line"> */</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">	private MainPresenter presenter;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		presenter = new MainPresenter();</div><div class="line">		getLifecycle().addObserver(presenter);</div><div class="line">		final TextView textView = findViewById(R.id.text);</div><div class="line">		Button button = findViewById(R.id.button);</div><div class="line">		ViewModelProvider.NewInstanceFactory  factory = new ViewModelProvider.NewInstanceFactory();</div><div class="line">		final MainViewModel model =	factory.create(MainViewModel.class);</div><div class="line">        //订阅数据变化</div><div class="line">		model.getStudent().observe(this, new Observer&lt;Student&gt;() &#123;</div><div class="line">			@Override</div><div class="line">			public void onChanged(@Nullable Student student) &#123;</div><div class="line">				textView.setText(student.getName());</div><div class="line">				Log.e(student.getName(),student.getGender() + &quot;年级&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="更新LiveData中的数据"><a href="#更新LiveData中的数据" class="headerlink" title="更新LiveData中的数据"></a>更新LiveData中的数据</h5><p>点击button，修改LiveData数据，观察者观察到数据变化，打印出信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">       //修改数据</div><div class="line">	button.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">		@Override</div><div class="line">		public void onClick(View view) &#123;</div><div class="line">			model.addStudent();</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-继承LiveData"><a href="#2-继承LiveData" class="headerlink" title="2.继承LiveData"></a>2.继承LiveData</h4><p>在LiveData中，onActive方法回调表明当前Activity处于激活状态，也就是Activity处于生命周期的活动状态中（onStart，onResume），可以简单认为当前的Activity处于前台。LiveData的onInactive处理涉及onActive剩下的生命周期</p>
<h5 id="1）创建继承于MutableLiveData"><a href="#1）创建继承于MutableLiveData" class="headerlink" title="1）创建继承于MutableLiveData"></a>1）创建继承于MutableLiveData</h5><p>自定义一个MyThread继承MutableLiveData，内部实现一个简单的功能，后台运行一个长时的线程任务，该线程实现一个简单功能：<br>（1）如果当前的Activity处于运行（用户可见）状态，则线程任务不断累计计数器并postValue一个值给任何Observer使用。<br>（2）如果当前Activity处于没有激活状态，则暂停线程任务，停止累计计数器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/8/21</div><div class="line"> * function:lifecycle.example.com.lifecycleexample</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyThread extends MutableLiveData&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">	private Integer a = 0;</div><div class="line">	private boolean Active = true;</div><div class="line"></div><div class="line">	private Thread thread = new Thread(new Runnable() &#123;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			while (Active)&#123;</div><div class="line">				a++;</div><div class="line">				postValue(a);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	public MyThread()&#123;</div><div class="line">		thread.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onInactive() &#123;</div><div class="line">		super.onInactive();</div><div class="line">		Log.e(&quot;aa&quot;,&quot;onInactive&quot;);</div><div class="line">		Active = false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onActive() &#123;</div><div class="line">		super.onActive();</div><div class="line">		Log.e(&quot;aa&quot;,&quot;onActive&quot;);</div><div class="line">		Active = true;</div><div class="line">		thread.interrupt();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2）构建Observer"><a href="#2）构建Observer" class="headerlink" title="2）构建Observer"></a>2）构建Observer</h5><p>再构建Observer，在Observer的onChanged中监听变化<br>在LiveData中的数据变化，通过postValue（可后台线程）或者setValue（主线程）设置后，将触发Observer的onChanged，开发者只需onChanged等待最新数据回调即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">	private MainPresenter presenter;</div><div class="line">	private TextView textView;</div><div class="line">	@Override</div><div class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		textView  = findViewById(R.id.text);</div><div class="line">		MyThread thread = new MyThread();</div><div class="line">		thread.observe(this,new MyObserver());</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	private class MyObserver implements Observer&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void onChanged(@Nullable Integer number) &#123;</div><div class="line">			Log.e(&quot;Main&quot;,number.intValue()+&quot;&quot;);</div><div class="line">			textView.setText(number.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LiveData原理"><a href="#LiveData原理" class="headerlink" title="LiveData原理"></a>LiveData原理</h2><p>先来熟悉一下类图，再分源码</p>
<p>这里参考一下<a href="https://blog.csdn.net/zhuzp_blog/article/details/78871527" target="_blank" rel="external">Android架构组件（二）——LiveData</a></p>
<p><strong>类关系图</strong></p>
<p><img src="http://oq6yfhskd.bkt.clouddn.com/blog/livedata/class_livedata1.png" alt=""></p>
<blockquote>
<p>LiveData的类关系图相对比较简单，从上面的类图我们就能看到。和LiveData组件相关的类和接口有：LiveData类、Observer接口、GenericLifecycleObserver接口。<br>LiveData类是个抽象类，但是它没有抽象方法，抽象类有个特点是：不能在抽象类中实例化自己。为什么LiveData会被定义成abstract而又没有抽象方法呢，这个…我也不知道，看了下LiveData的提交记录，是在将hasObservers()替换getObserverCount()方法时将LiveData改成了abstract，在此之前它是被定义为public，可以翻墙的可以看下这里的修改记录</p>
</blockquote>
<ul>
<li><p>MediatorLiveData继承自MutableLiveData，MutableLiveData继承自LiveData。MediatorLiveData可以看成是多个LiveData的代理，当将多个LiveData添加到MediatorLiveData，任何一个LiveData数据发生变化时，MediatorLiveData都会收到通知。</p>
</li>
<li><p>LiveData有个内部类LifecycleBoundObserver，它实现了GenericLifecycleObserver，而GenericLifecycleObserver继承了LifecycleObserver接口。在这里可以回顾下Lifecycle组件相关的内容。当组件（Fragment、Activity）生命周期变化时会通过onStateChanged()方法回调过来。</p>
</li>
<li><p>Observer接口就是观察者，其中定义了LiveData数据变化的回调方法onChanged()。</p>
</li>
</ul>
<p><strong>时序图</strong><br><img src="http://oq6yfhskd.bkt.clouddn.com/blog/livedata/sequence_livedate.png" alt="时序图"></p>
<p>LiveData主要涉及到的时序有三个：</p>
<ul>
<li>在Fragment/Activity中通过LiveData.observer()添加观察者（observer()方法中的第二个参数）。</li>
<li>根据Fragment/Activity生命周期发生变化时，移除观察者或者通知观察者更新数据。</li>
<li>当调用LiveData的setValue()、postValue()方法后，通知观察者更新数据。</li>
</ul>
<p>最让人头疼的源码，这里只抽取出常用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  //添加观察者，普通模式，只在LifecycleOwner处于活跃状态，监听LiveData的变化</div><div class="line">@MainThread</div><div class="line">  public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123;</div><div class="line">        if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</div><div class="line">            // ignore</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //将LifecycleOwner对象和Observer对象封装成LifecycleBoundObserver对象。</div><div class="line">        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</div><div class="line">        // mObservers可以理解成一个类似Map的容器，putIfAbsent()方法是判断容器中的observer（key）</div><div class="line">        // 是否有已经和wrapper(value)关联，如果已经关联则返回关联值，否则关联并返回wrapper。</div><div class="line">        LifecycleBoundObserver existing = mObservers.putIfAbsent(observer, wrapper);</div><div class="line">        if (existing != null &amp;&amp; existing.owner != wrapper.owner) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</div><div class="line">                    + &quot; with different lifecycles&quot;);</div><div class="line">        &#125;</div><div class="line">        if (existing != null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        owner.getLifecycle().addObserver(wrapper); </div><div class="line">        //条件LifecycleOwner的生命周期观察者</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**通过observeForever()添加观察者，观察者会一直受到数</div><div class="line">  据的变化回到，而不是在组件处于STARTED和RESUMED状态下才</div><div class="line">  会收到，因为这是LifecycleOwner对象就不再是组件了，而是</div><div class="line">  ALWAYS_ON；另外通过该方法添加观察者后，要手动调用</div><div class="line">  removeObserver()方法来停止观察者接收回调通知。</div><div class="line">  observeForever()方法体很简单，调用了observe()方法</div><div class="line">  ，传入的一个参数是ALWAYS_ON常量</div><div class="line">  */</div><div class="line">  @MainThread</div><div class="line">  public void observeForever(@NonNull Observer&lt;T&gt; observer) &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">    /**移除观察者，如果不是主线程，则会警告，然后根据</div><div class="line">    observer取出对应的ObserverWrapper(SafeIterableMap中存储Observer和</div><div class="line">    ObserverWrapper)，真正实现移除是在</div><div class="line">    removed.activeStateChanged(false)中</div><div class="line">    */</div><div class="line">  @MainThread</div><div class="line">  public void removeObserver(@NonNull final Observer&lt;T&gt; observer) &#123;</div><div class="line">      assertMainThread(&quot;removeObserver&quot;);</div><div class="line">      //mObservers是一个SafeIterableMap对象</div><div class="line">      ObserverWrapper removed = mObservers.remove(observer);</div><div class="line">      if (removed == null) &#123;</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">      removed.detachObserver();</div><div class="line">      //真正移除Observer的监听</div><div class="line">      removed.activeStateChanged(false);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    移除全部观察者，同样必须主线程，然后遍历所有Observer，调用removeObserver移除Observer</div><div class="line">    */</div><div class="line">  @MainThread</div><div class="line">  public void removeObservers(@NonNull final LifecycleOwner owner) &#123;</div><div class="line">      assertMainThread(&quot;removeObservers&quot;);</div><div class="line">      for (Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt; entry : mObservers) &#123;</div><div class="line">          if (entry.getValue().isAttachedTo(owner)) &#123;</div><div class="line">              removeObserver(entry.getKey());</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    //主/分线程都可以调用，如果主线程多次调用，只调度最后一个值</div><div class="line">  protected void postValue(T value) &#123;</div><div class="line">      boolean postTask;</div><div class="line">      synchronized (mDataLock) &#123;</div><div class="line">          postTask = mPendingData == NOT_SET;</div><div class="line">          mPendingData = value;</div><div class="line">      &#125;</div><div class="line">      if (!postTask) &#123;</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">     // 会在主线程中执行  mPostValueRunnable中的内容。</div><div class="line">     ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    //判断主线程，</div><div class="line">  @MainThread</div><div class="line">  protected void setValue(T value) &#123;</div><div class="line">      assertMainThread(&quot;setValue&quot;);</div><div class="line">      mVersion++;</div><div class="line">      mData = value;</div><div class="line">      dispatchingValue(null);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    //获取数据，很简单</div><div class="line">  public T getValue() &#123;</div><div class="line">        Object data = mData;</div><div class="line">      if (data != NOT_SET) &#123;</div><div class="line">          //noinspection unchecked</div><div class="line">          return (T) data;</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">    //活跃状态，空方法，子类实现</div><div class="line">  protected void onActive() &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">    //非活跃状态，空方法，子类实现</div><div class="line">  protected void onInactive() &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">    //是否有观察者</div><div class="line">  public boolean hasObservers() &#123;</div><div class="line">      return mObservers.size() &gt; 0;</div><div class="line">  &#125;</div><div class="line">    //是否有活跃观察者</div><div class="line">  public boolean hasActiveObservers() &#123;</div><div class="line">      return mActiveCount &gt; 0;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  private abstract class ObserverWrapper &#123;</div><div class="line">      final Observer&lt;T&gt; mObserver;</div><div class="line">      boolean mActive;</div><div class="line">      int mLastVersion = START_VERSION;</div><div class="line"></div><div class="line">      ObserverWrapper(Observer&lt;T&gt; observer) &#123;</div><div class="line">          mObserver = observer;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      abstract boolean shouldBeActive();</div><div class="line"></div><div class="line">      boolean isAttachedTo(LifecycleOwner owner) &#123;</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      void detachObserver() &#123;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      void activeStateChanged(boolean newActive) &#123;</div><div class="line">          if (newActive == mActive) &#123;</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">          // immediately set active state, so we&apos;d never dispatch anything to inactive</div><div class="line">          // owner</div><div class="line">          mActive = newActive;</div><div class="line">          //是否有活跃状态的观察者</div><div class="line">          boolean wasInactive = LiveData.this.mActiveCount == 0;</div><div class="line">          //增加或减少活跃状态观察者数量</div><div class="line">          LiveData.this.mActiveCount += mActive ? 1 : -1;     </div><div class="line">          //存在活跃状态观察者且新增观察者，则是活跃状态</div><div class="line">          if (wasInactive &amp;&amp; mActive) &#123;</div><div class="line">              onActive();</div><div class="line">          &#125;</div><div class="line">          //如果活跃状态观察者为0，且移除观察者，则非活跃状态</div><div class="line">          if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123;</div><div class="line">              onInactive();</div><div class="line">          &#125;</div><div class="line">          if (mActive) &#123;</div><div class="line">              dispatchingValue(this);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单了解LiveData的使用以及原理，发现内部并不太复杂，一直是维护一个观察者和观察者管理对象的 SafeIterableMap，现在就可以在轻松的开始尝试了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android官方架构/">Android官方架构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 daidai
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>