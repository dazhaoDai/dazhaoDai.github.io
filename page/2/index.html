<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="daidai" />


    
    


<meta name="description" content="喜欢探索未知,保持好奇心">
<meta property="og:type" content="website">
<meta property="og:title" content="T9&#39;S Develop Blog">
<meta property="og:url" content="http://outofmemory.top/page/2/index.html">
<meta property="og:site_name" content="T9&#39;S Develop Blog">
<meta property="og:description" content="喜欢探索未知,保持好奇心">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="T9&#39;S Develop Blog">
<meta name="twitter:description" content="喜欢探索未知,保持好奇心">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="T9&#39;S Develop Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="https://s1.ax1x.com/2018/10/12/iNnhCV.gif">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>T9&#39;S Develop Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://s1.ax1x.com/2018/10/12/iNnhCV.gif" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">daidai</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不仅有工作，更有生活</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://daidazhao@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/dazhaoDai" title="GitHub"></a>
                            
                                <a class="fa CSDN" href="https://blog.csdn.net/dazhaoDai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android官方架构/">Android官方架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进阶/">Android进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git分支操作/">Git分支操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java进阶/">Java进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin学习/">Kotlin学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin开发/">Kotlin开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-aidl/">android aidl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-permission/">android permission</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-view/">android view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-开发错误/">android 开发错误</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-权限/">android 权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-自定义view/">android 自定义view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android触摸事件/">android触摸事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/privacy/">privacy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Developer</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">daidai</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://s1.ax1x.com/2018/10/12/iNnhCV.gif" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">daidai</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不仅有工作，更有生活</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://daidazhao@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/dazhaoDai" title="GitHub"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://blog.csdn.net/dazhaoDai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Handler系列之创建子线程Handler" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Handler系列之创建子线程Handler/" class="article-date">
      <time datetime="2018-08-24T07:12:46.105Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Handler系列之创建子线程Handler/">Android 进阶  ------ Handler系列之创建子线程Handler</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>上一篇我介绍了Handler机制的工作原理，默认情况下，ActivityThread类为我们创建的了主线程的Looper和消息队列，所以当你创建Handler之后发送消息的时候，消息的轮训和handle都是在ui线程进行的。这种情况属于子线程给主线程发消息，通知主线程更新ui…等，那么反过来，怎么才能让主线程给子线程发消息，通知子线程做一些耗时逻辑？？</p>
<p>　　之前的学习我们知道，Android的消息机制遵循三个步骤：</p>
<ul>
<li><p>1　创建当前线程的Looper　　</p>
</li>
<li><p>2　创建当前线程的Handler　</p>
</li>
<li><p>3　调用当前线程Looper对象的loop方法</p>
</li>
</ul>
<p>　　看过之前文章的朋友会注意到，本篇我特意强调了“当前线程”。是的之前我们学习的很多都是Android未我们做好了的，譬如：创建主线程的Looper、主线程的消息队列…就连我们使用的handler也是主线程的。那么如果我想创建非主线程的Handler并且发送消息、处理消息，这一系列的操作我们应该怎么办那？？？不怎么办、凉拌～～～什么意思？？？依葫芦画瓢，依然遵循上面的三步走，直接上代码！！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class ChildThreadHandlerActivity extends Activity &#123;</div><div class="line">    private MyThread childThread;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler);</div><div class="line"></div><div class="line">        childThread = new MyThread();</div><div class="line">        childThread.start();</div><div class="line"></div><div class="line">        Handler childHandler = new Handler(childThread.childLooper)&#123;//这样之后，childHandler和childLooper就关联起来了。</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                </div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class MyThread extends Thread&#123;</div><div class="line">        public Looper childLooper;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            Looper.prepare();//创建与当前线程相关的Looper</div><div class="line">            childLooper = Looper.myLooper();//获取当前线程的Looper对象</div><div class="line">            Looper.loop();//调用此方法，消息才会循环处理</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码如上，我们依然循序Android的三步走战略，完成了子线程Handler的创建，难道这样创建完了，就可以发消息了么？发的消息在什么线程处理？一系列的问题，怎么办？看代码！！！运行上述代码，我们发现一个问题，就是此代码一会崩溃、一会不崩溃，通过查看日志我们看到崩溃的原因是空指针。谁为空？？？查到是我们的Looper对象，怎么会那？我不是在子线程的run方法中初始化Looper对象了么？话是没错，但是你要知道，当你statr子线程的时候，虽然子线程的run方法得到执行，但是主线程中代码依然会向下执行，造成空指针的原因是当我们new Handler(childThread.childLooper)的时候，run方法中的Looper对象还没初始化。当然这种情况是随机的，所以造成偶现的崩溃。</p>
<p>　　那怎么办？难道我们不能创建子线程Handler ？？？No!!!No!!!No!!!，你能想到的Android早就为我们实现好了，HandlerThread类就是解决这个问题的关键所在，看代码！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class HandlerThreadActivity extends Activity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler);</div><div class="line">        TextView textView = (TextView) findViewById(R.id.tv);</div><div class="line">        textView.setText(&quot;HandlerThreadActivity.class&quot;);</div><div class="line"></div><div class="line">        HandlerThread handlerThread = new HandlerThread(&quot;HandlerThread&quot;);</div><div class="line">        handlerThread.start();</div><div class="line"></div><div class="line">        Handler mHandler = new Handler(handlerThread.getLooper())&#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                super.handleMessage(msg);</div><div class="line">                Log.d(&quot;HandlerThreadActivity.class&quot;,&quot;uiThread2------&quot;+Thread.currentThread());//子线程</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Log.d(&quot;HandlerThreadActivity.class&quot;,&quot;uiThread1------&quot;+Thread.currentThread());//主线程</div><div class="line">        mHandler.sendEmptyMessage(1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建HandlerThread对象的时候，有个参数，是指定线程名字的。上面的代码不管运行多少次都不会奔溃！！！并且这种方法创建的handler的handleMessage方法运行在子线程中。所以我们可以在这里处理一些耗时的逻辑。到此我们完成了主线程给子线程发通知，在子线程做耗时逻辑的操作。</p>
<p>　　下面我们去看看源码，看看为什么使用HandlerThread就可以避免空指针那？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public Looper getLooper() &#123;</div><div class="line">    if (!isAlive()) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // If the thread has been started, wait until the looper has been created.</div><div class="line">    synchronized (this) &#123;</div><div class="line">        while (isAlive() &amp;&amp; mLooper == null) &#123;</div><div class="line">            try &#123;</div><div class="line">                wait();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return mLooper;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HandlerThread类的getLooper方法如上，我们看到当我们获取当前线程Looper对象的时候，会先判断当前线程是否存活，然后还要判断Looper对象是否为空，都满足之后才会返回给我Looper对象，否则处于等待状态！！既然有等待，那就有唤醒的时候，在那里那？？？我们发现HandlerThread的run方法中，有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明了什么那？？？HandlerThread类start的时候，Looper对象就初始化了，并唤醒之前等待的。所以HandlerThread很好的避免了之前空指针的产生。所以以后要想创建非主线程的Handler时，我们用HandlerThread类提供的Looper对象即可。</p>
<hr>
<p>参考<br><a href="https://www.cnblogs.com/lang-yu/p/6228832.html" target="_blank" rel="external">https://www.cnblogs.com/lang-yu/p/6228832.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶 ——— 使用SparseArray和ArrayMap代替HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android进阶 ——— 使用SparseArray和ArrayMap代替HashMap/" class="article-date">
      <time datetime="2018-08-24T07:06:38.651Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android进阶 ——— 使用SparseArray和ArrayMap代替HashMap/">Android进阶 ——— 使用SparseArray和ArrayMap代替HashMap</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Android开发时，我们使用的大部分都是Java的api，比如HashMap这个api，使用率非常高，但是对于Android这种对内存非常敏感的移动平台，很多时候使用一些java的api并不能达到更好的性能，相反反而更消耗内存，所以针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray、ArrayMap用来代替HashMap在有些情况下能带来更好的性能提升。</p>
<p>介绍它们之前先来介绍一下HashMap的内部存储结构，就明白为什么推荐使用SparseArray和ArrayMap</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap内部是使用一个默认容量为16的数组来存储数据的，而数组中每一个元素却又是一个链表的头结点，所以，更准确的来说，HashMap内部存储结构是使用哈希表的拉链结构（数组+链表），如图：<br>这种存储数据的方法叫做拉链法 </p>
<p><img src="https://img-blog.csdn.net/20150820130200565" alt=""></p>
<p>且每一个结点都是Entry类型，那么Entry是什么呢？我们来看看HashMap中Entry的属性：</p>
<blockquote>
<p>final K key;<br>V value;<br>final int hash;<br>HashMapEntry<k, v=""> next;</k,></p>
</blockquote>
<p>从中我们得知Entry存储的内容有key、value、hash值、和next下一个Entry，那么，这些Entry数据是按什么规则进行存储的呢？就是通过计算元素key的hash值，然后对HashMap中数组长度取余得到该元素存储的位置，计算公式为hash(key)%len，比如：假设hash(14)=14,hash(30)=30,hash(46)=46，我们分别对len取余，得到<br>hash(14)%16=14，hash(30)%16=14，hash(46)%16=14，所以key为14、30、46的这三个元素存储在数组下标为14的位置，如：</p>
<p><img src="https://img-blog.csdn.net/20150820133048242" alt=""></p>
<p>从中可以看出，如果有多个元素key的hash值相同的话，后一个元素并不会覆盖上一个元素，而是采取链表的方式，把之后加进来的元素加入链表末尾，从而解决了hash冲突的问题，由此我们知道HashMap中处理hash冲突的方法是链地址法，在此补充一个知识点，处理hash冲突的方法有以下几种：</p>
<ul>
<li>开放地址法</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区</li>
</ul>
<p>讲到这里，重点来了，我们知道HashMap中默认的存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap对象时，即使里面没有任何元素，也要分别一块内存空间给它，而且，我们再不断的向HashMap里put数据时，当达到一定的容量限制时（这个容量满足这样的一个关系时候将会扩容：HashMap中的数据量&gt;容量*加载因子，而HashMap中默认的加载因子是0.75），HashMap的空间将会扩大，而且扩大后新的空间一定是原来的2倍，我们可以看put()方法中有这样的一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int newCapacity = oldCapacity * 2;</div></pre></td></tr></table></figure></p>
<p>所以，重点就是这个，只要一满足扩容条件，HashMap的空间将会以2倍的规律进行增大。假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费，而且HashMap获取数据是通过遍历Entry[]数组来得到对应的元素，在数据量很大时候会比较慢，所以在Android中，HashMap是比较费内存的，我们在一些情况下可以使用SparseArray和ArrayMap来代替HashMap。</p>
<h3 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h3><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源码中可以看到key和value分别是用数组表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private int[] mKeys;</div><div class="line">private Object[] mValues;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，SparseArray只能存储key为int类型的数据，同时，SparseArray在存储和读取数据时候，使用的是二分查找法，我们可以看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void put(int key, E value) &#123;</div><div class="line">       int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</div><div class="line">       ...</div><div class="line">       &#125;</div><div class="line">public E get(int key, E valueIfKeyNotFound) &#123;</div><div class="line">       int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</div><div class="line">       ...</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从小到大的顺序排列好，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。 </p>
<p>而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。</p>
<h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void put(int key, E value)</div></pre></td></tr></table></figure>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void remove(int key)</div></pre></td></tr></table></figure>
<p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void delete(int key)</div></pre></td></tr></table></figure></p>
<p>其实remove内部还是通过调用delete来删除数据的</p>
<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public E get(int key)</div></pre></td></tr></table></figure>
<p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public E get(int key, E valueIfKeyNotFound)</div></pre></td></tr></table></figure></p>
<p>该方法可设置如果key不存在的情况下默认返回的value</p>
<h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p>在此之外，SparseArray还提供了两个特有方法，更方便数据的查询：<br>获取对应的key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public int keyAt(int index)</div></pre></td></tr></table></figure></p>
<p>获取对应的value：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public E valueAt(int index)</div></pre></td></tr></table></figure></p>
<p>SparseArray应用场景：<br>虽说SparseArray性能比较好，但是由于其添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%。</p>
<p>满足下面两个条件我们可以使用SparseArray代替HashMap：</p>
<p>数据量不大，最好在千级以内<br>key必须为int类型，这中情况下的HashMap可以用SparseArray代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;();</div><div class="line">用SparseArray代替:</div><div class="line">SparseArray&lt;Object&gt; array = new SparseArray&lt;&gt;();</div></pre></td></tr></table></figure></p>
<h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><p>这个api的资料在网上可以说几乎没有，然并卵，只能看文档了<br>ArrayMap是一个<key,value>映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。</key,value></p>
<h4 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value)</div></pre></td></tr></table></figure>
<h4 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public V get(Object key)</div></pre></td></tr></table></figure>
<h4 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public V remove(Object key)</div></pre></td></tr></table></figure>
<h4 id="特有方法-1"><a href="#特有方法-1" class="headerlink" title="特有方法"></a>特有方法</h4><p>它和SparseArray一样同样也有两个更方便的获取数据方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public K keyAt(int index)</div><div class="line">public V valueAt(int index)</div></pre></td></tr></table></figure></p>
<p>ArrayMap应用场景<br>数据量不大，最好在千级以内<br>数据结构类型为Map类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayMap&lt;Key, Value&gt; arrayMap = new ArrayMap&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>【注】：如果我们要兼容aip19以下版本的话，那么导入的包需要为v4包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import android.support.v4.util.ArrayMap;</div></pre></td></tr></table></figure></p>
<p>总结<br>SparseArray和ArrayMap都差不多，使用哪个呢？<br>假设数据量都在千级以内的情况下：</p>
<blockquote>
<p>1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用<br>2、如果key类型为其它的类型，则使用ArrayMap</p>
</blockquote>
<p>参考</p>
<hr>
<p><a href="https://blog.csdn.net/u010687392/article/details/47809295" target="_blank" rel="external">https://blog.csdn.net/u010687392/article/details/47809295</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java设计模式 ——— 工厂模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java设计模式 ——— 工厂模式/" class="article-date">
      <time datetime="2018-08-24T07:05:45.715Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java设计模式 ——— 工厂模式/">Java设计模式 ——— 工厂模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式的模型非常简单，定义一个抽象类及抽象方法，具体产品类继承抽象类，在简单工厂类中提供具体产品，供给客户端使用<br><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160818224552500-264215677.png" alt=""></p>
<p>例如，一家餐馆，可以提供多种食品，供用户选择：</p>
<ul>
<li><p>定义抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">抽象类</div><div class="line">*/</div><div class="line">public abstract class SimpleFood &#123;</div><div class="line">	/**</div><div class="line">	 * 提供食物</div><div class="line">	 */</div><div class="line">	public abstract void food();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>提供面条–具体产品类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 具体产品类</div><div class="line"> */</div><div class="line">public class Noodles extends SimpleFood &#123;</div><div class="line">	@Override</div><div class="line">	public void food() &#123;</div><div class="line">		System.out.println(&quot;面条&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>提供米饭–具体产品类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 具体产品类</div><div class="line"> */</div><div class="line">public class Rice extends SimpleFood &#123;</div><div class="line">	@Override</div><div class="line">	public void food() &#123;</div><div class="line">		System.out.println(&quot;米饭&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>准备工作结束，创建餐馆–简单工厂类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SimpleFoodFactory &#123;</div><div class="line"></div><div class="line">	public static final int TYPE_NOODLES = 1;//面条</div><div class="line">	public static final int TYPE_RICE = 2;//米饭</div><div class="line"></div><div class="line"></div><div class="line">	public static SimpleFood createFood(int type) &#123;</div><div class="line">		switch (type) &#123;</div><div class="line">			case TYPE_NOODLES:</div><div class="line">				return new Noodles();</div><div class="line">			case TYPE_RICE:</div><div class="line">				return new Rice();</div><div class="line">			default:</div><div class="line">				return new Rice();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>客人点餐，指明要吃的食物，只要有原料，就可以提供：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SimpleFood food =  SimpleFoodFactory.createFood(SimpleFoodFactory.TYPE_RICE);</div><div class="line">food.food();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>这个和简单工厂有区别，简单工厂模式只有一个工厂，工厂方法模式对每一个产品都有相应的工厂。<br><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160818230715265-504425871.png" alt=""></p>
<p>同样是一家餐馆，可以提供食物</p>
<ul>
<li><p>创建基类，声明创建食物的方法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract class Food &#123;</div><div class="line">	public abstract void createFood();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>声明工厂类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract class FoodStore &#123;</div><div class="line">	public abstract Food createFood(String type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>构建两个窗口，一个卖面工厂，一个卖盖饭工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class NoodlesStore extends FoodStore &#123;</div><div class="line">	@Override</div><div class="line">	public Food createFood(String type) &#123;</div><div class="line">		if (type.equals(&quot;lznoodles&quot;)) &#123;</div><div class="line">			return new LZNoodles();</div><div class="line">		&#125; else if (type.equals(&quot;cqnoodles&quot;)) &#123;</div><div class="line">			return new CQNoodles();</div><div class="line">		&#125; else return null;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class RiceStore extends FoodStore &#123;</div><div class="line">	@Override</div><div class="line">	public Food createFood(String type) &#123;</div><div class="line">		if (type.equals(&quot;yuxiangrousi&quot;)) &#123;</div><div class="line">			return new YXRSRice();</div><div class="line">		&#125; else if (type.equals(&quot;huiguorou&quot;)) &#123;</div><div class="line">			return new HGRRice();</div><div class="line">		&#125; else return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>客户端，点餐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> RiceStore store = new RiceStore();</div><div class="line"> Food food = store.createFood(&quot;YXRS&quot;);</div><div class="line"></div><div class="line">NoodlesStore noodlesStore = new NoodlesStore();</div><div class="line">Food food1 =  noodlesStore.createFood(&quot;CQNoodles&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h3><p>定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p>
<p><img src="http://hi.csdn.net/attachment/201203/16/0_13318591595Q24.gif" alt=""></p>
<p>现在餐馆不仅有食物，还有饮料，提供饮料抽象类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public abstract class IDrinks &#123;</div><div class="line">	/**</div><div class="line">	 * 饮料价格</div><div class="line">	 */</div><div class="line">	public abstract void prices();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>具体产品类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ColaDrinks extends IDrinks &#123;</div><div class="line">	@Override</div><div class="line">	public void prices() &#123;</div><div class="line">		System.out.println(&quot;可乐三块五&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class WaterDrinks extends IDrinks &#123;</div><div class="line">	@Override</div><div class="line">	public void prices() &#123;</div><div class="line">		System.out.println(&quot;开水免费！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>为食物和饮料创建总工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class RestaurantFactory &#123;</div><div class="line">	public abstract Food getFood(String type);</div><div class="line">	public abstract IDrinks getDrink(String price) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>具体的食物工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FoodFactory extends RestaurantFactory &#123;</div><div class="line">	@Override</div><div class="line">	public Food getFood(String type) &#123;</div><div class="line">		if (type.equals(&quot;yuxiangrousi&quot;)) &#123;</div><div class="line">			return new YXRSRice();</div><div class="line">		&#125; else if (type.equals(&quot;huiguorou&quot;)) &#123;</div><div class="line">			return new HGRRice();</div><div class="line">		&#125; else if (type.equals(&quot;lznoodles&quot;)) &#123;</div><div class="line">			return new LZNoodles();</div><div class="line">		&#125; else if (type.equals(&quot;cqnoodles&quot;)) &#123;</div><div class="line">			return new CQNoodles();</div><div class="line">		&#125; else return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public IDrinks getDrink(String price) &#123;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>饮料工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class DrinkFactory extends RestaurantFactory &#123;</div><div class="line">	@Override</div><div class="line">	public Food getFood(String type) &#123;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public IDrinks getDrink(int price) &#123;</div><div class="line">		if(price &lt; 3 )&#123;</div><div class="line">			return new WaterDrinks();</div><div class="line">		&#125;else  if (price &gt;= 3)&#123;</div><div class="line">			return new ColaDrinks();</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶 ——— Android官方架构组件Lifecycle" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android进阶 ——— Android官方架构组件Lifecycle/" class="article-date">
      <time datetime="2018-08-24T06:15:50.616Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android进阶 ——— Android官方架构组件Lifecycle/">Android进阶 ——— Android官方架构组件Lifecycle</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>Lifecycle是Android官方推出的架构组件，在谷歌开发者官微发布的<a href="https://mp.weixin.qq.com/s/9rC_5GhdAA_EMEbWKJT5vQ" target="_blank" rel="external">正式发布 Android 架构组件 1.0 稳定版 | 附带中文介绍视频</a><br>简明扼要的阐述了推出的架构组件的作用及使用，也可以查看<a href="https://developer.android.com/reference/androidx/lifecycle/package-summary" target="_blank" rel="external">Android开发者官网</a>。</p>
<p>先来看看架构组件的第一部分Lifecycle。<br>在长篇大论之前，先要了解它的作用，为什么谷歌要推出Lifecycle？</p>
<p>就是为了解决常见架构模式中，声明周期管理的痛点，例如MVP模式：<br>为了管理声明周期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public interface IPresenter &#123;</div><div class="line"></div><div class="line">	void onCreate();</div><div class="line"></div><div class="line">	void onStart();</div><div class="line"></div><div class="line">	void onResume();</div><div class="line"></div><div class="line">	void onPause();</div><div class="line"></div><div class="line">	void onStop();</div><div class="line"></div><div class="line">	void onDestroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继承Ipresenter接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class MainPresenter implements IPresenter &#123;</div><div class="line"></div><div class="line">	public void xxx()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onCreate() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onStart() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onResume() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onPause() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onStop() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onDestroy() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Activity或Fragment中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/8/20</div><div class="line"> * function:lifecycle.example.com.lifecycleexample</div><div class="line"> */</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">	private MainPresenter presenter;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">		presenter = new MainPresenter();</div><div class="line">		presenter.onCreate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onStart() &#123;</div><div class="line">		super.onStart();</div><div class="line">		presenter.onStart();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onResume() &#123;</div><div class="line">		super.onResume();</div><div class="line">		presenter.onResume();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onPause() &#123;</div><div class="line">		super.onPause();</div><div class="line">		presenter.onPause();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onStop() &#123;</div><div class="line">		super.onStop();</div><div class="line">		presenter.onStop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onDestroy() &#123;</div><div class="line">		super.onDestroy();</div><div class="line">		presenter.onDestroy();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要在Activity的每个声明周期中，依次调用接口IPresenter定义的方法，无疑影响开发效率，更麻烦的是，如果忘记调用声明周期的方法，例如APP被销毁，presenter中依然调用UI层，这必然产生严重后果。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Lifecycle就是为了解决这种重复工作的。先来看看如何使用：<br>导入Java8依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &quot;android.arch.lifecycle:common-java8:1.1.1&quot;</div></pre></td></tr></table></figure></p>
<p>继承DefaultLifecycleObserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IPresenter extends DefaultLifecycleObserver &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现生命周期方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MainPresenter implements IPresenter &#123;</div><div class="line"></div><div class="line">	private final String TAG = this.getClass().getSimpleName();</div><div class="line">	public void xxx()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onCreate(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;oncreate&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onStart(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;start&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onResume(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;resume &quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onPause(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;pause&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onStop(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;stop&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onDestroy(LifecycleOwner owner) &#123;</div><div class="line">		Log.e(TAG,&quot;destory&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Activity中，只需要注册一下，就能完成生命周期的监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">	private MainPresenter presenter;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		presenter = new MainPresenter();</div><div class="line">        //注册</div><div class="line">		getLifecycle().addObserver(presenter);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IPrestener继承DefaultLifecycleObserver,MainPresenter实现IPresenter接口，并实现DefaultLifecycleObserver中定义的方法，可以全部实现，也可以选择需要的生命周期去实现。</p>
<p>了解了Lifecycle的使用，当然也要简单了解一下实现原理，知其然而不知其所以然，不是我们的目的。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h4 id="1-先了解几个重要的类和接口"><a href="#1-先了解几个重要的类和接口" class="headerlink" title="1.先了解几个重要的类和接口"></a>1.先了解几个重要的类和接口</h4><ul>
<li>Lifecycle<br>Lifecycle是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。</li>
<li>Event ：从框架和Lifecycle类派发的生命周期事件。这些事件映射到活动和片段中的回调事件。</li>
<li>State ：由Lifecycle对象跟踪的组件的当前状态。</li>
<li>LifecycleOwner （重要）Lifecycle持有者 （例如Activity、Fragment）<br>实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</li>
<li>LifecycleObserver（重要）Lifecycle观察者<br>实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。</li>
</ul>
<h4 id="2-LifecycleOwner（Lifecycle持有者）"><a href="#2-LifecycleOwner（Lifecycle持有者）" class="headerlink" title="2.LifecycleOwner（Lifecycle持有者）"></a>2.LifecycleOwner（Lifecycle持有者）</h4><blockquote>
<p>官网介绍：LifecycleOwner是一个单一的方法接口，表示该类有一个 Lifecycle。它有一个方法，getLifecycle()这个方法 必须由这个类来实现。如果您试图管理整个应用程序进程的生命周期，请参阅 ProcessLifecycleOwner。该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口<br>实现LifecycleObserver的组件与实现LifecycleOwner的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册以观看</p>
</blockquote>
<p>简单理解：LifecycleOwner就是一个接口，谁继承了它，就持有了lifecycle对象，可以提供生命周期。<br>然后可以调用getLifecycle()方法获取继承了抽象类Lifecycle的LifecycleRegistry，然后调用addObserver(@NonNull LifecycleObserver observer) 方法来注册监听。<br>总而言之：<br><strong>实现该接口的持有者，其生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件</strong></p>
<p><strong>注意：Support Library 26.1.0 及其以后的版本，Activity 和Fragment 已经实现了LifecycleOwner 接口，所以，我们可以直接在Activity 和Fragment中使用getLifecycle()方法来获取lifecycle对象，来添加观察者监听。</strong></p>
<h4 id="3-LifecycleObserver（Lifecycle观察者）"><a href="#3-LifecycleObserver（Lifecycle观察者）" class="headerlink" title="3.LifecycleObserver（Lifecycle观察者）"></a>3.LifecycleObserver（Lifecycle观察者）</h4><blockquote>
<p>LifecycleObserver 是一个观察者接口，实现了它，可以通过注解或者继承的方式，来管理声明周期的监听。只要在持有lifecycle的类中注册了它，当声明周期发生变化时，它就能收到，进行我们自定义的操作。</p>
</blockquote>
<p>简单理解：任何注解或继承实现了该接口，只要在持有Lifecycle的类中注册了，就可以监听到生命周期的变化</p>
<p>两种实现方式：<br>1）、实现DefultLifecyceObserver接口，然后重写里面生命周期方法；<br>2）、直接实现LifecycleObserver接口，然后通过注解的方式来接收生命周期的变化；<br>Lifecycle.java文档中是建议使用第一种方式，因为文档中说明了，随着Java8成为主流，注解的方式会被弃用。DefaultLifecycleObserver是需要另外声明的java8 ，所以上面我们添加了Java8的依赖，再回顾上面的例子：</p>
<p>IPrestener继承<code>DefaultLifecycleObserver</code>,MainPresenter实现IPresenter接口，并实现<code>DefaultLifecycleObserver</code>中定义的方法，而Activity默认实现了<code>LifecycleOwner</code>接口，持有声明周期，最后调用<code>getLifecycle().addObserver(presenter)</code>注册了LifecycleObserver。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android官方架构/">Android官方架构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶 ——— Android官方架构组件LiveData" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android进阶 ——— Android官方架构组件LiveData/" class="article-date">
      <time datetime="2018-08-24T06:15:06.506Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android进阶 ——— Android官方架构组件LiveData/">Android进阶 ——— Android官方架构组件LiveData</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>上一篇文章，学习了Android官方架构组件的第一部分<a href="https://blog.csdn.net/dazhaoDai/article/details/81902704" target="_blank" rel="external">Android进阶 ——— Android官方架构组件Lifecycle</a></p>
</blockquote>
<h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>LiveData 是一个可以感知 Activity 、Fragment生命周期的数据容器。当 LiveData 所持有的数据改变时，它会通知相应的界面代码进行更新。同时，LiveData 持有界面代码 Lifecycle 的引用，这意味着它会在界面代码（LifecycleOwner）的生命周期处于 started 或 resumed 时作出相应更新，而在 LifecycleOwner 被销毁时停止更新。</p>
<blockquote>
<ul>
<li>意味着LiveData可以被观察者订阅，并且感知LifeCycleOwner组件的生命周期。</li>
<li>如果<code>LifecycleOwner</code>的状态为<code>Lifecycle.State.STARTED</code>或<code>Lifecycle.State.RESUMED</code>，才会通知观察者更新</li>
<li>可以通过<code>observeForever（Observer）</code>添加的观察者，使其始终处于活动状态，不仅仅是处于活跃状态。但是这种方式添加的观察者，需要手动调用<code>removeObserver（Observer）</code>解除</li>
</ul>
</blockquote>
<p>上面的描述介绍了LiveData的优点：不用手动控制生命周期，不用担心内存泄露，数据变化时会收到通知。</p>
<p>不仅如此，官方推荐，LiveData和Viewmodel搭配使用，ViewModel是Android官方构件的另一成员。</p>
<blockquote>
<p>ViewModel 将视图的数据和逻辑从具有生命周期特性的实体（如 Activity 和 Fragment）中剥离开来。直到关联的 Activity 或 Fragment 完全销毁时，ViewModel 才会随之消失，也就是说，即使在旋转屏幕导致 Fragment 被重新创建等事件中，视图数据依旧会被保留。ViewModels 不仅消除了常见的生命周期问题，而且可以帮助构建更为模块化、更方便测试的用户界面。</p>
</blockquote>
<p>ViewModel的优点:为Activity 、Fragment存储数据，直到完全销毁。尤其是屏幕旋转的场景，常用的方法都是通过onSaveInstanceState()保存数据，再在onCreate()中恢复，真的是很麻烦。<br>其次因为ViewModel存储了数据，所以ViewModel可以在当前Activity的Fragment中实现数据共享。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>LiveData有几种使用方式：</p>
<ul>
<li>使用LiveData对象</li>
<li>继承LiveData</li>
</ul>
<h4 id="1-使用LiveData对象"><a href="#1-使用LiveData对象" class="headerlink" title="1.使用LiveData对象"></a>1.使用LiveData对象</h4><p>  使用LiveData对象主要有以下几个步骤：</p>
<ul>
<li>创建保存特定数据类型的LiveData实例（ViewModel中）；</li>
<li>创建Observer对象，作为参数传入LiveData.observe()方法，添加观察者；</li>
<li>通过 observe()方法连接观察者和LiveData。observe()方法需要携带一个LifecycleOwner类。这样就可以让观察者订阅LiveData中的数据；</li>
</ul>
<h5 id="创建LiveData实例-一般继承自MutableLiveData"><a href="#创建LiveData实例-一般继承自MutableLiveData" class="headerlink" title="创建LiveData实例,一般继承自MutableLiveData"></a>创建LiveData实例,一般继承自MutableLiveData</h5><p>MutableLiveData是LiveData的子类，添加了公共方法setValue和postValue，方便开发者直接使用。setValue必须在主线程调用。postValue可以在后台线程中调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/8/20</div><div class="line"> * function:lifecycle.example.com.lifecycleexample.LifeCycle</div><div class="line"> */</div><div class="line"></div><div class="line">public class MainViewModel  extends ViewModel&#123;</div><div class="line"></div><div class="line"></div><div class="line">	private MutableLiveData&lt;Student&gt; student =  new MutableLiveData&lt;&gt;();</div><div class="line"></div><div class="line">	public MutableLiveData&lt;Student&gt; getStudent() &#123;</div><div class="line">		return student;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void addStudent()&#123;</div><div class="line">		Student student1 = new Student();</div><div class="line">		student1.setGender(55);</div><div class="line">		student1.setName(&quot;zhangsan&quot;);</div><div class="line">		student.setValue(student1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="创建Observer对象，作为参数添加观察者"><a href="#创建Observer对象，作为参数添加观察者" class="headerlink" title="创建Observer对象，作为参数添加观察者"></a>创建Observer对象，作为参数添加观察者</h5><p>通过LiveData.observe()方法添加观察者，当数据变化时会通过回调方法通知观察者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/8/20</div><div class="line"> * function:lifecycle.example.com.lifecycleexample</div><div class="line"> */</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">	private MainPresenter presenter;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		presenter = new MainPresenter();</div><div class="line">		getLifecycle().addObserver(presenter);</div><div class="line">		final TextView textView = findViewById(R.id.text);</div><div class="line">		Button button = findViewById(R.id.button);</div><div class="line">		ViewModelProvider.NewInstanceFactory  factory = new ViewModelProvider.NewInstanceFactory();</div><div class="line">		final MainViewModel model =	factory.create(MainViewModel.class);</div><div class="line">        //订阅数据变化</div><div class="line">		model.getStudent().observe(this, new Observer&lt;Student&gt;() &#123;</div><div class="line">			@Override</div><div class="line">			public void onChanged(@Nullable Student student) &#123;</div><div class="line">				textView.setText(student.getName());</div><div class="line">				Log.e(student.getName(),student.getGender() + &quot;年级&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="更新LiveData中的数据"><a href="#更新LiveData中的数据" class="headerlink" title="更新LiveData中的数据"></a>更新LiveData中的数据</h5><p>点击button，修改LiveData数据，观察者观察到数据变化，打印出信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">       //修改数据</div><div class="line">	button.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">		@Override</div><div class="line">		public void onClick(View view) &#123;</div><div class="line">			model.addStudent();</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-继承LiveData"><a href="#2-继承LiveData" class="headerlink" title="2.继承LiveData"></a>2.继承LiveData</h4><p>在LiveData中，onActive方法回调表明当前Activity处于激活状态，也就是Activity处于生命周期的活动状态中（onStart，onResume），可以简单认为当前的Activity处于前台。LiveData的onInactive处理涉及onActive剩下的生命周期</p>
<h5 id="1）创建继承于MutableLiveData"><a href="#1）创建继承于MutableLiveData" class="headerlink" title="1）创建继承于MutableLiveData"></a>1）创建继承于MutableLiveData</h5><p>自定义一个MyThread继承MutableLiveData，内部实现一个简单的功能，后台运行一个长时的线程任务，该线程实现一个简单功能：<br>（1）如果当前的Activity处于运行（用户可见）状态，则线程任务不断累计计数器并postValue一个值给任何Observer使用。<br>（2）如果当前Activity处于没有激活状态，则暂停线程任务，停止累计计数器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/8/21</div><div class="line"> * function:lifecycle.example.com.lifecycleexample</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyThread extends MutableLiveData&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">	private Integer a = 0;</div><div class="line">	private boolean Active = true;</div><div class="line"></div><div class="line">	private Thread thread = new Thread(new Runnable() &#123;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			while (Active)&#123;</div><div class="line">				a++;</div><div class="line">				postValue(a);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	public MyThread()&#123;</div><div class="line">		thread.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onInactive() &#123;</div><div class="line">		super.onInactive();</div><div class="line">		Log.e(&quot;aa&quot;,&quot;onInactive&quot;);</div><div class="line">		Active = false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onActive() &#123;</div><div class="line">		super.onActive();</div><div class="line">		Log.e(&quot;aa&quot;,&quot;onActive&quot;);</div><div class="line">		Active = true;</div><div class="line">		thread.interrupt();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2）构建Observer"><a href="#2）构建Observer" class="headerlink" title="2）构建Observer"></a>2）构建Observer</h5><p>再构建Observer，在Observer的onChanged中监听变化<br>在LiveData中的数据变化，通过postValue（可后台线程）或者setValue（主线程）设置后，将触发Observer的onChanged，开发者只需onChanged等待最新数据回调即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">	private MainPresenter presenter;</div><div class="line">	private TextView textView;</div><div class="line">	@Override</div><div class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		textView  = findViewById(R.id.text);</div><div class="line">		MyThread thread = new MyThread();</div><div class="line">		thread.observe(this,new MyObserver());</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	private class MyObserver implements Observer&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void onChanged(@Nullable Integer number) &#123;</div><div class="line">			Log.e(&quot;Main&quot;,number.intValue()+&quot;&quot;);</div><div class="line">			textView.setText(number.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LiveData原理"><a href="#LiveData原理" class="headerlink" title="LiveData原理"></a>LiveData原理</h2><p>先来熟悉一下类图，再分源码</p>
<p>这里参考一下<a href="https://blog.csdn.net/zhuzp_blog/article/details/78871527" target="_blank" rel="external">Android架构组件（二）——LiveData</a></p>
<p><strong>类关系图</strong></p>
<p><img src="http://oq6yfhskd.bkt.clouddn.com/blog/livedata/class_livedata1.png" alt=""></p>
<blockquote>
<p>LiveData的类关系图相对比较简单，从上面的类图我们就能看到。和LiveData组件相关的类和接口有：LiveData类、Observer接口、GenericLifecycleObserver接口。<br>LiveData类是个抽象类，但是它没有抽象方法，抽象类有个特点是：不能在抽象类中实例化自己。为什么LiveData会被定义成abstract而又没有抽象方法呢，这个…我也不知道，看了下LiveData的提交记录，是在将hasObservers()替换getObserverCount()方法时将LiveData改成了abstract，在此之前它是被定义为public，可以翻墙的可以看下这里的修改记录</p>
</blockquote>
<ul>
<li><p>MediatorLiveData继承自MutableLiveData，MutableLiveData继承自LiveData。MediatorLiveData可以看成是多个LiveData的代理，当将多个LiveData添加到MediatorLiveData，任何一个LiveData数据发生变化时，MediatorLiveData都会收到通知。</p>
</li>
<li><p>LiveData有个内部类LifecycleBoundObserver，它实现了GenericLifecycleObserver，而GenericLifecycleObserver继承了LifecycleObserver接口。在这里可以回顾下Lifecycle组件相关的内容。当组件（Fragment、Activity）生命周期变化时会通过onStateChanged()方法回调过来。</p>
</li>
<li><p>Observer接口就是观察者，其中定义了LiveData数据变化的回调方法onChanged()。</p>
</li>
</ul>
<p><strong>时序图</strong><br><img src="http://oq6yfhskd.bkt.clouddn.com/blog/livedata/sequence_livedate.png" alt="时序图"></p>
<p>LiveData主要涉及到的时序有三个：</p>
<ul>
<li>在Fragment/Activity中通过LiveData.observer()添加观察者（observer()方法中的第二个参数）。</li>
<li>根据Fragment/Activity生命周期发生变化时，移除观察者或者通知观察者更新数据。</li>
<li>当调用LiveData的setValue()、postValue()方法后，通知观察者更新数据。</li>
</ul>
<p>最让人头疼的源码，这里只抽取出常用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  //添加观察者，普通模式，只在LifecycleOwner处于活跃状态，监听LiveData的变化</div><div class="line">@MainThread</div><div class="line">  public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123;</div><div class="line">        if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</div><div class="line">            // ignore</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //将LifecycleOwner对象和Observer对象封装成LifecycleBoundObserver对象。</div><div class="line">        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</div><div class="line">        // mObservers可以理解成一个类似Map的容器，putIfAbsent()方法是判断容器中的observer（key）</div><div class="line">        // 是否有已经和wrapper(value)关联，如果已经关联则返回关联值，否则关联并返回wrapper。</div><div class="line">        LifecycleBoundObserver existing = mObservers.putIfAbsent(observer, wrapper);</div><div class="line">        if (existing != null &amp;&amp; existing.owner != wrapper.owner) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</div><div class="line">                    + &quot; with different lifecycles&quot;);</div><div class="line">        &#125;</div><div class="line">        if (existing != null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        owner.getLifecycle().addObserver(wrapper); </div><div class="line">        //条件LifecycleOwner的生命周期观察者</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**通过observeForever()添加观察者，观察者会一直受到数</div><div class="line">  据的变化回到，而不是在组件处于STARTED和RESUMED状态下才</div><div class="line">  会收到，因为这是LifecycleOwner对象就不再是组件了，而是</div><div class="line">  ALWAYS_ON；另外通过该方法添加观察者后，要手动调用</div><div class="line">  removeObserver()方法来停止观察者接收回调通知。</div><div class="line">  observeForever()方法体很简单，调用了observe()方法</div><div class="line">  ，传入的一个参数是ALWAYS_ON常量</div><div class="line">  */</div><div class="line">  @MainThread</div><div class="line">  public void observeForever(@NonNull Observer&lt;T&gt; observer) &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">    /**移除观察者，如果不是主线程，则会警告，然后根据</div><div class="line">    observer取出对应的ObserverWrapper(SafeIterableMap中存储Observer和</div><div class="line">    ObserverWrapper)，真正实现移除是在</div><div class="line">    removed.activeStateChanged(false)中</div><div class="line">    */</div><div class="line">  @MainThread</div><div class="line">  public void removeObserver(@NonNull final Observer&lt;T&gt; observer) &#123;</div><div class="line">      assertMainThread(&quot;removeObserver&quot;);</div><div class="line">      //mObservers是一个SafeIterableMap对象</div><div class="line">      ObserverWrapper removed = mObservers.remove(observer);</div><div class="line">      if (removed == null) &#123;</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">      removed.detachObserver();</div><div class="line">      //真正移除Observer的监听</div><div class="line">      removed.activeStateChanged(false);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    移除全部观察者，同样必须主线程，然后遍历所有Observer，调用removeObserver移除Observer</div><div class="line">    */</div><div class="line">  @MainThread</div><div class="line">  public void removeObservers(@NonNull final LifecycleOwner owner) &#123;</div><div class="line">      assertMainThread(&quot;removeObservers&quot;);</div><div class="line">      for (Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt; entry : mObservers) &#123;</div><div class="line">          if (entry.getValue().isAttachedTo(owner)) &#123;</div><div class="line">              removeObserver(entry.getKey());</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    //主/分线程都可以调用，如果主线程多次调用，只调度最后一个值</div><div class="line">  protected void postValue(T value) &#123;</div><div class="line">      boolean postTask;</div><div class="line">      synchronized (mDataLock) &#123;</div><div class="line">          postTask = mPendingData == NOT_SET;</div><div class="line">          mPendingData = value;</div><div class="line">      &#125;</div><div class="line">      if (!postTask) &#123;</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">     // 会在主线程中执行  mPostValueRunnable中的内容。</div><div class="line">     ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    //判断主线程，</div><div class="line">  @MainThread</div><div class="line">  protected void setValue(T value) &#123;</div><div class="line">      assertMainThread(&quot;setValue&quot;);</div><div class="line">      mVersion++;</div><div class="line">      mData = value;</div><div class="line">      dispatchingValue(null);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    //获取数据，很简单</div><div class="line">  public T getValue() &#123;</div><div class="line">        Object data = mData;</div><div class="line">      if (data != NOT_SET) &#123;</div><div class="line">          //noinspection unchecked</div><div class="line">          return (T) data;</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">    //活跃状态，空方法，子类实现</div><div class="line">  protected void onActive() &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">    //非活跃状态，空方法，子类实现</div><div class="line">  protected void onInactive() &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">    //是否有观察者</div><div class="line">  public boolean hasObservers() &#123;</div><div class="line">      return mObservers.size() &gt; 0;</div><div class="line">  &#125;</div><div class="line">    //是否有活跃观察者</div><div class="line">  public boolean hasActiveObservers() &#123;</div><div class="line">      return mActiveCount &gt; 0;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  private abstract class ObserverWrapper &#123;</div><div class="line">      final Observer&lt;T&gt; mObserver;</div><div class="line">      boolean mActive;</div><div class="line">      int mLastVersion = START_VERSION;</div><div class="line"></div><div class="line">      ObserverWrapper(Observer&lt;T&gt; observer) &#123;</div><div class="line">          mObserver = observer;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      abstract boolean shouldBeActive();</div><div class="line"></div><div class="line">      boolean isAttachedTo(LifecycleOwner owner) &#123;</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      void detachObserver() &#123;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      void activeStateChanged(boolean newActive) &#123;</div><div class="line">          if (newActive == mActive) &#123;</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">          // immediately set active state, so we&apos;d never dispatch anything to inactive</div><div class="line">          // owner</div><div class="line">          mActive = newActive;</div><div class="line">          //是否有活跃状态的观察者</div><div class="line">          boolean wasInactive = LiveData.this.mActiveCount == 0;</div><div class="line">          //增加或减少活跃状态观察者数量</div><div class="line">          LiveData.this.mActiveCount += mActive ? 1 : -1;     </div><div class="line">          //存在活跃状态观察者且新增观察者，则是活跃状态</div><div class="line">          if (wasInactive &amp;&amp; mActive) &#123;</div><div class="line">              onActive();</div><div class="line">          &#125;</div><div class="line">          //如果活跃状态观察者为0，且移除观察者，则非活跃状态</div><div class="line">          if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123;</div><div class="line">              onInactive();</div><div class="line">          &#125;</div><div class="line">          if (mActive) &#123;</div><div class="line">              dispatchingValue(this);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单了解LiveData的使用以及原理，发现内部并不太复杂，一直是维护一个观察者和观察者管理对象的 SafeIterableMap，现在就可以在轻松的开始尝试了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android官方架构/">Android官方架构</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS 自定义View 中跳转UIViewController" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/iOS 自定义View 中跳转UIViewController/" class="article-date">
      <time datetime="2018-08-24T04:33:38.958Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/iOS 自定义View 中跳转UIViewController/">iOS 自定义View 中跳转UIViewController</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>自定义View中实现控制器的跳转，可以有多种实现方式：</p>
<ul>
<li><h5 id="1-使用Notification"><a href="#1-使用Notification" class="headerlink" title="1 使用Notification"></a>1 使用Notification</h5><p>使用Notification，在父控制器打开需要跳转的控制器</p>
</li>
<li><h5 id="2-使用代理"><a href="#2-使用代理" class="headerlink" title="2 使用代理"></a>2 使用代理</h5><p>使用代理通知父控制器跳转</p>
</li>
<li><h5 id="3-使用闭包"><a href="#3-使用闭包" class="headerlink" title="3 使用闭包"></a>3 使用闭包</h5><p>原理同第2条</p>
</li>
<li><h5 id="4-使用主窗口的根控制器"><a href="#4-使用主窗口的根控制器" class="headerlink" title="4 使用主窗口的根控制器"></a>4 使用主窗口的根控制器</h5><p>拿到主窗口的根控制器，用根控制器打开需要跳转的控制器</p>
</li>
</ul>
<p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let nav = UIApplication.shared.keyWindow?.rootViewController as! UIViewController</div><div class="line">let feedVC  = FeedBackViewController.init()</div><div class="line">nav.present(feedVC!, animated: true, completion: nil)</div></pre></td></tr></table></figure></p>
<p> OC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIViewController *root = [UIApplication sharedApplication].keyWindow.rootViewController;</div><div class="line">[root presentViewController:&lt;#(nonnull UIViewController *)#&gt; animated:YES completion:nil];</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Kotlin 学习笔记（八）—— Kotlin类与对象之接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/28/Kotlin 学习笔记（八）—— Kotlin类与对象之接口/" class="article-date">
      <time datetime="2018-02-28T08:28:07.000Z" itemprop="datePublished">2018-02-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/Kotlin 学习笔记（八）—— Kotlin类与对象之接口/">Kotlin 学习笔记（八）—— Kotlin类与对象之接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79301071" target="_blank" rel="external">Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79315585" target="_blank" rel="external">Kotlin 学习笔记（五）—— Kotlin基础之控制流、返回与跳转、 包与导入</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79392850" target="_blank" rel="external">Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79401080" target="_blank" rel="external">Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段</a>  </p>
</blockquote>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Kotlin 的接口和 Java8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存柱状。它可以有属性但必须声明为抽象或提供访问器实现。</p>
<p>使用关键字 interface 来定义接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface A &#123;</div><div class="line">    fun setName()</div><div class="line"></div><div class="line">    fun setAge()&#123;</div><div class="line">        //可选方法体</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类或者对象可以实现一个或多个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class B : A &#123;</div><div class="line">    override fun setName() &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h3><p>你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现，在接口中声明的属性不能有幕后字段，因此接口中声明的访问器不能引用它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">interface A &#123;</div><div class="line">    val time:Int</div><div class="line">    </div><div class="line">    var name:String</div><div class="line">    get() = &quot;aaa&quot;</div><div class="line">    set(value) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    fun setName()</div><div class="line"></div><div class="line">    fun setAge()&#123;</div><div class="line">        //可选方法体</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B : A &#123;</div><div class="line">    override val time: Int</div><div class="line">        get() = 5</div><div class="line"></div><div class="line">    override fun setName() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解决覆盖冲突"><a href="#解决覆盖冲突" class="headerlink" title="解决覆盖冲突"></a>解决覆盖冲突</h3><p>实现多个接口或继承父类时，可能会遇到同一方法继承多个实现的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">interface A &#123;</div><div class="line">    fun foo() &#123; print(&quot;A&quot;) &#125;</div><div class="line">    fun bar()</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface B &#123;</div><div class="line">    fun foo() &#123; print(&quot;B&quot;) &#125;</div><div class="line">    fun bar() &#123; print(&quot;bar&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C : A &#123;</div><div class="line">    override fun bar() &#123; print(&quot;bar&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class D : A, B &#123;</div><div class="line">    override fun foo() &#123;</div><div class="line">        super&lt;A&gt;.foo()</div><div class="line">        super&lt;B&gt;.foo()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun bar() &#123;</div><div class="line">        super&lt;B&gt;.bar()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口 A 和 B 都定义了方法 foo() 和 bar()，两者都实现了foo()，但是只要 B 实现了bar()，bar()在 A 中没有标记为抽象，因为没有方法体时默认为抽象。因为 C 实现了 A 的具体类，所以必须重写 bar() 并实现这个抽象方法。</p>
<p>然而，如果我们从 A 和 B 派生 D，我们需要实现我们从多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。</p>
<hr>
<blockquote>
<p>以上就是类与对象第三篇之接口，第四篇将学习可见性修饰符</p>
</blockquote>
<hr>
<p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a>  </p>
<hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin学习/">Kotlin学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin开发/">Kotlin开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/28/Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段/" class="article-date">
      <time datetime="2018-02-28T07:20:18.000Z" itemprop="datePublished">2018-02-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段/">Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79301071" target="_blank" rel="external">Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79315585" target="_blank" rel="external">Kotlin 学习笔记（五）—— Kotlin基础之控制流、返回与跳转、 包与导入</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79392850" target="_blank" rel="external">Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承</a></p>
</blockquote>
<hr>
<h2 id="属性与字段"><a href="#属性与字段" class="headerlink" title="属性与字段"></a>属性与字段</h2><h3 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h3><p>Kotlin的类可以有属性，属性可以用关键词 var 声明为可变， 否则使用只读关键字 val。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Kotlin3 &#123;</div><div class="line">    var name: String = &quot;name&quot;</div><div class="line">    var age: Int = 5</div><div class="line">    var city: String = &quot;Beijing&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用一个属性，只需要用名称引用即可，就像Java中的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun copyKotlin3(kotlin3: Kotlin3):Kotlin3&#123;</div><div class="line">    val kotlin3 = Kotlin3()</div><div class="line">    kotlin3.age = 30</div><div class="line">    kotlin3.name = &quot;kotlin4&quot;</div><div class="line">    return kotlin3</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Getters-与-Setters"><a href="#Getters-与-Setters" class="headerlink" title="Getters 与 Setters"></a>Getters 与 Setters</h3><p>声明一个属性的完整语法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">[&lt;getter&gt;]</div><div class="line">[&lt;setter&gt;]</div></pre></td></tr></table></figure></p>
<p>其初始化器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始化器（或者从其getter 返回值，如下文所示）中推断出来，也可以省略。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var defaultSize: Int?  // 错误：需要显式初始化器，隐含默认 getter 和 setter</div><div class="line">var defaultTime = 1 // 类型 Int、默认 getter 和 setter</div></pre></td></tr></table></figure></p>
<p>一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 val 开始代替 var ，2、只读属性不允许 setter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val defaultSize: Int?  // 错误：默认 getter</div><div class="line">val defaultTime = 1 // 类型 Int、默认 getter</div></pre></td></tr></table></figure></p>
<p>我们可以自定义访问器，非常像普通函数，刚好在属性声明内部。这里有一个自定义getter 的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var defaultName: String </div><div class="line">    get() = this.toString()</div><div class="line">    set(value) &#123;</div><div class="line">        value.toUpperCase()</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>按照惯例，setter 参数的名称是 value，如果你喜欢你可以选择其他名称。<br>自Kotlin 1.1 起，如果可以从getter 推断出属性类型，则可以省略属性类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var defaultAge</div><div class="line">    get() = this.toString()  //省略String类型</div><div class="line">    set(value) &#123;</div><div class="line">        value.toUpperCase()</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现，你可以定义访问器而不定义其实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var changeAge: String = &quot;aaa&quot;</div><div class="line">    private set  //此 setter 是私有的并且有默认实现</div><div class="line"></div><div class="line">var changeName: String? = null</div><div class="line">    @Inject set // 用 Inject 注解此 setter</div></pre></td></tr></table></figure></p>
<h3 id="幕后字段"><a href="#幕后字段" class="headerlink" title="幕后字段"></a>幕后字段</h3><p>在kotlin 类中不能直接声明字段。然而，当一个属性需要一个幕后字段时，Kotlin 会自动提供，这个幕后字段可以使用field 标识符在访问器中引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var count = 1</div><div class="line">    set(value) &#123;</div><div class="line">        if (value &gt; 0) field = value</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>field 标识符只能用在属性的访问器内</p>
<p>如果属性至少一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会为该属性生成一个幕后字段</p>
<p>例如，下面情况，就没有幕后字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val height: Int</div><div class="line">get() = defaultTime</div></pre></td></tr></table></figure></p>
<h3 id="幕后属性"><a href="#幕后属性" class="headerlink" title="幕后属性"></a>幕后属性</h3><p>如果你的需求不符合这套”隐式的幕后字段”方案，那么总可以使用<em>幕后属性（backing property）</em>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private var _table: Map&lt;String, Int&gt;? = null</div><div class="line">public val table: Map&lt;String, Int&gt;</div><div class="line">    get() &#123;</div><div class="line">        if (_table == null) &#123;</div><div class="line">            _table = HashMap() // 类型参数已推断出</div><div class="line">        &#125;</div><div class="line">        return _table ?: throw AssertionError(&quot;Set to null by another thread&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>从各方面来看，这正是与 Java 相同的方式。因为通过默认 getter 和 setter 访问私有属性会被优化，所以不会引入函数调用开销</p>
<h3 id="编译期常量"><a href="#编译期常量" class="headerlink" title="编译期常量"></a>编译期常量</h3><p>已知值的属性可以使用 const 修饰符标记为 <em>编译期常量</em>。这些属性需要满足以下条件：</p>
<ul>
<li>位于顶层或者是 object 的一个成语</li>
<li>用 String 或原生类型 值初始化</li>
<li>没有自定义 getter<br>这些属性可以用在注解中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const val SUBSYSTEM_DEPRECATED: String = &quot;This subsystem is deprecated&quot;</div><div class="line"></div><div class="line">@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() &#123; …… &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="延迟初始化属性与变量"><a href="#延迟初始化属性与变量" class="headerlink" title="延迟初始化属性与变量"></a>延迟初始化属性与变量</h3><p>一般地，属性声明为非空类型必须在构造函数中初始化。然而，这经常不方便。例如：属性可以通过依赖注入来初始化，或者在单元测试的setup方法中初始化，这种情况下，你不能在构造函数内提供一个非空初始器，但你仍想在类体中引用该属性时避免空检查。<br>为处理这种情况，你可以用 lateinit 修饰符标记该属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyTest &#123;</div><div class="line">    lateinit var subject: TestSubject</div><div class="line"></div><div class="line">    @SetUp fun setup() &#123;</div><div class="line">        subject = TestSubject()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test fun test() &#123;</div><div class="line">        subject.method()  // 直接解引用</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该修饰符只能用于类体中的属性（如果在主构造函数中声明的 var 属性，并且仅当该属性没有自定义 getter 或 setter 时），而自 Kotlin 1.2 起，也用于顶层属性与局部变量。该属性或变量必须为非空类型，并且不能是原生类型。</p>
<p>在初始化前访问一个 lateinit 属性会抛出一个特定异常，该异常明确标识该属性被访问及它没有初始化的事实。</p>
<h3 id="检测一个-lateinit-var-是否已初始化（自-1-2-起）"><a href="#检测一个-lateinit-var-是否已初始化（自-1-2-起）" class="headerlink" title="检测一个 lateinit var 是否已初始化（自 1.2 起）"></a>检测一个 lateinit var 是否已初始化（自 1.2 起）</h3><p>要检测一个 lateinit var 是否经过初始化，请在该属性的引用上使用 .isInitialized：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (foo::bar.isInitialized) &#123;</div><div class="line">    println(foo.bar)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此检测仅对可词法级访问的属性可用，即声明位于同一个类型内、位于其中一个外围类型中或者位于相同文件的顶层的属性。</p>
<h3 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h3><p>参见第<a href="http://blog.csdn.net/dazhaodai/article/details/79392850" target="_blank" rel="external"> Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承</a> —- 覆盖属性</p>
<h3 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h3><p>最常见的一类属性就是简单地从幕后字段中读取（以及可能的写入）。另一方面，使用自定义getter 和 setter 可以实现属性的任何行为，介于两者之间，属性如何工作有一些常见的模式，一些例子：惰性值、通过键值从映射读取。访问数据库。访问时通知侦听器等等。</p>
<p>这些常见行为可以通过委托属性实现为库，会在后续文章中介绍</p>
<hr>
<blockquote>
<p>本篇主要介绍了Kotlin类与对象之属性与字段，下篇文章学习kotlin之接口</p>
</blockquote>
<hr>
<p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a></p>
<hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin学习/">Kotlin学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin开发/">Kotlin开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/27/Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承/" class="article-date">
      <time datetime="2018-02-27T12:57:04.000Z" itemprop="datePublished">2018-02-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承/">Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79301071" target="_blank" rel="external"> Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79315585" target="_blank" rel="external"> Kotlin 学习笔记（五）—— Kotlin基础之控制流、返回与跳转、 包与导入</a></p>
</blockquote>
<hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Kotlin中使用关键字class声明类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Invoice &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类声明由类名、类头（指定其类型参数、主构造函数等）以及花括号包围的类体构成。类头和类体都是可选的；如果一个类没有类体，可以省略花括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Empty</div></pre></td></tr></table></figure></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在Kotlin中的一个类可以有一个<strong>主构造函数</strong>和一个或多个<strong>次构造函数</strong>，主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Person constructor(firstName: String) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个constructor关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Person(firstName: String) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主构造函数不能包含任何的代码。初始化代码可以放到以init关键字作为前缀的<strong>初始化块</strong>（<strong>initializer blocks</strong>）中。<br>在实例初始化期间，初始化块按照它们出现在类体重的顺序执行，与属性初始化器交织在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Kotlin1(fileName: String)&#123;</div><div class="line"></div><div class="line">    val time = fileName</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">       var size = time.length</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：主构造的参数可以在初始化块中使用，它们也可以在类体内声明的属性初始化器中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val time = fileName</div></pre></td></tr></table></figure></p>
<p>事实上，声明属性以及从主构造函数初始化属性，Kotlin有简洁的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Kotlin1(fileName: String,val size: Int,var age: Int)&#123;</div><div class="line">      //.... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。<br>如果构造函数有注解或可见性修饰符，这个constructor关键词是必须的，并且这些修饰符在它的前面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Customer public @Inject constructor(name: String) &#123; …… &#125;</div></pre></td></tr></table></figure></p>
<h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Kotlin1&#123;</div><div class="line">    </div><div class="line">    constructor(fileName: String, size: Int, age: Int) &#123;</div><div class="line">        val time = fileName</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数，可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用this关键字即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Kotlin1(fileName: String)&#123;</div><div class="line"></div><div class="line">   constructor(fileName: String, size: Int, age: Int) : this(fileName)&#123;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Kotlin1&#123;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">      print(&quot;first&quot;)  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(fileName: String, size: Int, age: Int)&#123;</div><div class="line">        print(&quot;second&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数，构造函数的可见性是public，如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Kotlin2 private constructor()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">注意：在JVM上，如果主构造函数的所有参数都有默认值，编译器会生成一个额外的无参构造函数，它将使用默认值，这使得Kotlin更易于像Jackson或者JPA这样的通过无参构造函数创建类的实例的库。</div><div class="line"></div><div class="line">  class Kotlin2 (val  fileName: String = &quot;&quot;)&#123;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>###创建类的实例<br>要创建一个类的实例，我们就像普通函数一样调用构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val kotlin2 = Kotlin2(&quot;music&quot;)</div></pre></td></tr></table></figure></p>
<p>注意Kotlin没有new 关键字<br>创建嵌套类、内部类和匿名内部类的类实例在嵌套类中有述。</p>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>类可以包含：</p>
<ul>
<li>构造函数和初始化块</li>
<li>函数</li>
<li>属性</li>
<li>嵌套类和内部类</li>
<li>对象声明</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在Kotlin 中所有类都有一个共同的超类 <code>Any</code>,这对于没有超类型声明的类是默认超类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Example // 从 Any 隐式继承</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注意：Any 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。 更多细节请查阅Java互操作性部分。</div></pre></td></tr></table></figure>
<p>要声明一个显式的超类型，我们把类型放到类头的冒号之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">      print(&quot;first&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(fileName: String, size: Int, age: Int)&#123;</div><div class="line">        print(&quot;second&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">类上的 open 标注与 Java 中 final相反，它允许其他类从这个类继承。默认情况下，在Kotlin中所有的类都是final，对应于 Effective Java书中的第17条：**要么为继承而设计，并提供说明文档，要么就禁止继承**。</div></pre></td></tr></table></figure>
<p>如果派生类有一个主构造函数，其基类型可以（并且必须）用基类的主构造函数参数就地初始化。</p>
<p>如果累没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyView : View &#123;</div><div class="line">    constructor(ctx: Context) : super(ctx)</div><div class="line"></div><div class="line">    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>我们之前提到过，Kotlin力求清晰显示，与Java 不同，Kotlin 需要显示标注可覆盖的成员（我们称之为开放）和覆盖后的成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">      print(&quot;first&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(fileName: String, size: Int, age: Int)&#123;</div><div class="line">        print(&quot;second&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open fun addSize()&#123;&#125;</div><div class="line">    fun  addAge()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20) &#123;</div><div class="line"></div><div class="line">    override  fun addSize() &#123;</div><div class="line">        super.addSize()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Kotlin2.addSize()函数上必须加上<strong>override</strong>标注，如果没写，编译器将会报错。如果函数没有标注<strong>open</strong> 和 Kotlin1.addAge()，则子类中不允许定义相同签名的函数，不论加不加 <strong>override</strong>。在一个final 类中，开放成员是禁止的。</p>
<p>标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用final 关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20) &#123;</div><div class="line"></div><div class="line">    final override  fun addSize() &#123;</div><div class="line">        super.addSize()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h3><p>属性覆盖和方法覆盖类似：在超类中声明然后在派生类中重新声明的属性必须以override 开头，并且它们必须具有兼容的类型。每个声明的属性可以由具有初始化的属性或者具有getter方法的属性覆盖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line">    open val aa: Int get() &#123;</div><div class="line">        return 5</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1 &#123;</div><div class="line">    override val aa: Int</div><div class="line">        get() = super.aa + 5</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你也可以用一个 var 属性覆盖一个 val 属性，但是反之则不行。这是允许的，因为一个 val 属性本质上声明了 一个 getter 方法，而将其覆盖为 var 只是在子类中额外 声明一个 setter方法。</p>
<p>请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface Foo &#123;</div><div class="line">    val count: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bar1(override val count: Int) : Foo</div><div class="line"></div><div class="line">class Bar2 : Foo &#123;</div><div class="line">    override var count: Int = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="派生类初始化顺序"><a href="#派生类初始化顺序" class="headerlink" title="派生类初始化顺序"></a>派生类初始化顺序</h3><p>在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">open class Base(val name: String) &#123;</div><div class="line"></div><div class="line">    init &#123; println(&quot;Initializing Base&quot;) &#125;</div><div class="line"></div><div class="line">    open val size: Int = </div><div class="line">    name.length.also &#123; println(&quot;Initializing size in Base: $it&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Derived(</div><div class="line">    name: String,</div><div class="line">    val lastName: String</div><div class="line">) : Base(name.capitalize().also &#123; println(&quot;Argument for Base: $it&quot;) &#125;) &#123;</div><div class="line"></div><div class="line">    init &#123; println(&quot;Initializing Derived&quot;) &#125;</div><div class="line"></div><div class="line">    override val size: Int =</div><div class="line">    (super.size + lastName.length).also &#123; println(&quot;Initializing size in Derived: $it&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Constructing Derived(&quot;hello&quot;, &quot;world&quot;)</div><div class="line">Argument for Base: Hello</div><div class="line">Initializing Base</div><div class="line">Initializing size in Base: 5</div><div class="line">Initializing Derived</div><div class="line">Initializing size in Derived: 10</div></pre></td></tr></table></figure></p>
<p>这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化，如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或者运行时故障，设计一个基类时，应该避免这种在构造函数、属性初始化器以及init 块中使用 open 成员</p>
<h3 id="调用超类实现"><a href="#调用超类实现" class="headerlink" title="调用超类实现"></a>调用超类实现</h3><p>派生类中的代码可以使用super 关键字调用其超类的函数与属性访问器的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">      print(&quot;first&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(fileName: String, size: Int, age: Int)&#123;</div><div class="line">        print(&quot;second&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open fun addSize()&#123;</div><div class="line">        print(&quot;Kotlin1&quot;)</div><div class="line">    &#125;</div><div class="line">    fun  addAge()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20) &#123;</div><div class="line"></div><div class="line">    override  fun addSize() &#123;</div><div class="line">        super.addSize()</div><div class="line">        print(&quot;Kotlin2&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在一个内部类中访问外部类的超类，可以通过由外部类名限定的super关键字来实现： <code>super@Outer</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Bar : Foo() &#123;</div><div class="line">    override fun f() &#123; /* …… */ &#125;</div><div class="line">    override val x: Int get() = 0</div><div class="line"></div><div class="line">    inner class Baz &#123;</div><div class="line">        fun g() &#123;</div><div class="line">            super@Bar.f() // 调用 Foo 实现的 f()</div><div class="line">            println(super@Bar.x) // 使用 Foo 实现的 x 的 getter</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h3><p>在Kotlin中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现，它必须覆盖这个成员并提供自己的实现（也许用继承来的其中之一）。为了表示采用从哪个超类型继承的实现，我们使用尖括号中超类型名限定的super，例如 <code>super&lt;Base&gt;</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line">    open fun addSize()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface A &#123;</div><div class="line">    fun addSize()&#123;</div><div class="line">        println(&quot;aa&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20),A &#123;</div><div class="line"></div><div class="line">    override  fun addSize() &#123;</div><div class="line">        super&lt;Kotlin1&gt;.addSize()</div><div class="line">        super&lt;A&gt;.addSize()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时继承Kotlin1 和 A 没问题，但是addSize() 由 Kotlin2 继承了两个实现，所以我们必须在 Kotlin2 中覆盖addSize() 并且提供我们自己的实现来消除歧义。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>类和其中的某些成员可以声明为abstract。 抽象成员在本类中可以不用实现，需要注意的是，我们并不需要用 open 标注一个抽象类火灾函数 – 因为这不言而喻</p>
<p>我们可以用一个抽象成员覆盖一个非抽象的开放成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">open class Base &#123;</div><div class="line">    open fun f() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class Derived : Base() &#123;</div><div class="line">    override abstract fun f()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>与Java 或者 C# 不同，在Kotlin 中类没有静态方法，在大多数情况下，它建议简单地使用包级函数。</p>
<p>如果你需要写一个无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。</p>
<p>更具体的讲，如果在你的类内部声明了一个伴生对象，你就可以使用像在Java/C# 中调用静态方法相同的语法来调用其成员，只使用类名作为限定符。</p>
<hr>
<h2 id="gt-以上就是类与对象的第一篇–类和继承"><a href="#gt-以上就是类与对象的第一篇–类和继承" class="headerlink" title="&gt;以上就是类与对象的第一篇–类和继承"></a>&gt;以上就是类与对象的第一篇–类和继承</h2><p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a></p>
<hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin学习/">Kotlin学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin开发/">Kotlin开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Kotlin基础之控制流、返回与跳转、 包与导入" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/12/Kotlin基础之控制流、返回与跳转、 包与导入/" class="article-date">
      <time datetime="2018-02-12T03:22:20.000Z" itemprop="datePublished">2018-02-12</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/12/Kotlin基础之控制流、返回与跳转、 包与导入/">Kotlin 学习笔记（五）—— Kotlin基础之控制流、返回与跳转、 包与导入</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79301071" target="_blank" rel="external"> Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a></p>
</blockquote>
<hr>
<h2 id="控制流：if、when、for、while"><a href="#控制流：if、when、for、while" class="headerlink" title="控制流：if、when、for、while"></a>控制流：if、when、for、while</h2><h4 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h4><p>在Kotlin中，if是一个表达式，即它会返回一个值。因此就不需要三元运算符（条件？ 然后： 否则），因为普通的if就能胜任这个角色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 传统用法</div><div class="line">  var max = a </div><div class="line">  if (a &lt; b) max = b</div><div class="line"></div><div class="line">  // With else </div><div class="line">  var max: Int</div><div class="line">  if (a &gt; b) &#123;</div><div class="line">      max = a</div><div class="line">  &#125; else &#123;</div><div class="line">      max = b</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  // 作为表达式</div><div class="line">  val max = if (a &gt; b) a else b</div></pre></td></tr></table></figure></p>
<p>if的分支可以是代码块，最后的表达式作为该块的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val a1 = 101</div><div class="line">val b1 = 5</div><div class="line">var d1 = if (a1 &gt; b1) &#123;</div><div class="line">    print(a1)</div><div class="line">    a1</div><div class="line">&#125;else&#123;</div><div class="line">    print(b1)</div><div class="line">    b1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h4><p>when 取代了C语言的switch操作符。最简单的形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    1 -&gt; print(&quot;x == 1&quot;)</div><div class="line">    2 -&gt; print(&quot;x == 2&quot;)</div><div class="line">    else -&gt; &#123; // 注意这个块</div><div class="line">       print(&quot;x is neither 1 nor 2&quot;)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>when 将它的参数和所有分支条件顺序比较，直到某个分支满足条件。when既可以被当做表达式使用也可以被当做语句使用。如果它被当作表达式，符合条件的分支的值就是整个表达式的值，如果当作语句使用，则忽略个别分支的值。（像if 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值）</p>
<p>如果其他分支都不满足条件将会求值else分支。如果一个when作为一个表达式使用，则必须有else分支，除非编译器能够检测出所有的可能情况都已经覆盖了。</p>
<p>如果很多分支需要用相同的方式处理，则可以把多个分支放在一起，用逗号隔开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var  max = 100</div><div class="line"></div><div class="line">fun compareTo()&#123;</div><div class="line">    when(max)&#123;</div><div class="line">        0,1 -&gt; print(&quot;max == 0 or max == 1&quot;)</div><div class="line">        else -&gt; print(&quot;otherwise&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以用任意表达式（而不是常量）作为分支条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">when(max)&#123;</div><div class="line">    parseInt(a1.toString()) -&gt; print(&quot;max encodes x&quot;)</div><div class="line">    else -&gt; print(&quot;otherwise&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    in 1..10 -&gt; print(&quot;x is in the range&quot;)</div><div class="line">    in validNumbers -&gt; print(&quot;x is valid&quot;)</div><div class="line">   !in 10..20 -&gt; print(&quot;x is outside the range&quot;)</div><div class="line">   else -&gt; print(&quot;none of the above&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一种可能是检测一个值是（is）或者不是（!is）一个特定类型的值。注意：由于智能转换，你可以访问该类型的方法和属性而不需要任何额外的检测。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun hasPrefix(x: Any) = when(x)&#123;</div><div class="line">    is String -&gt; x.startsWith(&quot;prefix&quot;)</div><div class="line">    else -&gt; false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>when 也可以用来取代 if-else if链，如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">when &#123;</div><div class="line">    x.isOdd() -&gt; print(&quot;x is odd&quot;)</div><div class="line">    x.isEven() -&gt; print(&quot;x is even&quot;)</div><div class="line">    else -&gt; print(&quot;x is funny&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h4><p>for循环可以对任何提供迭代器（iterator）的对象进行遍历，这相当于C#这样的语言中的<code>foreach</code>循环，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (item  in lists)  print(item)</div></pre></td></tr></table></figure></p>
<p>循环体可以是一个代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (item in lists)&#123;</div><div class="line">    print(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>综上所述，for可以循环遍历任何提供了迭代器的对象，即：</p>
<ul>
<li>有一个成员函数或者拓展函数<code>iterator</code>，它的返回类型</li>
<li>有一个成员函数或者拓展函数<code>next()</code>，并且返回 Boolean</li>
<li>有一个成员函数或者扩展函数 hasNext() 返回 Boolean。</li>
</ul>
<p>这三个函数都需要标记为<code>operator</code>。</p>
<p>对数组的for循环会被编译为并不创建迭代器的基于索引的循环。</p>
<p>如果你想通过索引遍历一个数组或者list，可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (i in array.indices) &#123;</div><div class="line">    print(array[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这种”在区间遍历”会编译成优化的实现而不会创建额外对象；</p>
<p>或者你可以用库函数<code>withIndex</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ((index, value) in array.withIndex()) &#123;</div><div class="line">    println(&quot;the element at $index is $value&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h4><p>while和do..while照常使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">while (x &gt; 0) &#123;</div><div class="line">   x--</div><div class="line">&#125;</div><div class="line"></div><div class="line">do &#123;</div><div class="line">  val y = retrieveData()</div><div class="line">&#125; while (y != null) // y 在此处可见</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h2><p>Kotlin有三种结构化跳转表达式：</p>
<ul>
<li>return。默认从最直接包围它的函数或者匿名函数返回。</li>
<li>break。终止最直接包围它的循环。</li>
<li>continue。继续下一次最直接包围它的循环。</li>
</ul>
<p>所有这些表达式都可以用作更大表达式的一部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val s = person.name ?: return</div></pre></td></tr></table></figure></p>
<p>这些表达式的类型是Nothing类型。</p>
<h4 id="Break-与-Continue-标签"><a href="#Break-与-Continue-标签" class="headerlink" title="Break 与 Continue 标签"></a>Break 与 Continue 标签</h4><p>在 Kotlin 中任何表达式都可以用标签（Label）来标记，标签的格式为标识符后跟 @ 符号，例如：adc@ 、fast@ 都是有效的标签（参见语法）。要为一个表达式加标签，我们只要在其前加标签即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">loop@ for (i in 1..100)&#123;</div><div class="line">    for (j in 1..100)&#123;</div><div class="line">        if (j == 50) break@loop</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。continue 继续标签制定的循环的下一次迭代。</p>
<h4 id="标签处返回"><a href="#标签处返回" class="headerlink" title="标签处返回"></a>标签处返回</h4><p>Kotlin有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。标签限制的return允许我们从外层函数返回。最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    fun foo() &#123;</div><div class="line">    listOf(1, 2, 3, 4, 5).forEach &#123;</div><div class="line">        if (it == 3) return // 非局部直接返回到 foo() 的调用者</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">    println(&quot;this point is unreachable&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里 return 表达式从最直接包围它的函数即 foo 中返回。（注意，这种非局部的返回只支持传给内联函数的 lambda 表达式）如果我们需要从 lambda 表达式中返回，我们必须给它加上标签并用以限制 return。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    fun foo() &#123;</div><div class="line">    listOf(1, 2, 3, 4, 5).forEach lit@&#123;</div><div class="line">        if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">    print(&quot; done with explicit label&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，它只会从lambda 表达式中返回。通常情况下使用隐式标签更方便。该标签与接受该lambda 的函数同名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    fun foo() &#123;</div><div class="line">    listOf(1, 2, 3, 4, 5).forEach &#123;</div><div class="line">        if (it == 3) return@forEach // 局部返回到该 lambda 表达式的调用者，即 forEach 循环</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">    print(&quot; done with implicit label&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者我们用一个匿名函数替代 lambda 表达式。匿名函数内部的 return 语句将从该匿名函数自身返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun  testReturn()&#123;</div><div class="line">    lists.forEach(fun(value: String) &#123;</div><div class="line">        if (value.startsWith(&quot;a&quot;)) return  //局部返回到匿名函数的调用者，即foreach 循环</div><div class="line">        print(value)</div><div class="line">    &#125;)</div><div class="line">    print(&quot;finfish&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请注意，前文三个实例中使用的局部返回类似于在常规循环中使用continue。并没有 break 的直接等价形式，不过可以通过增加另一层嵌套 lambda 表达式并不从其中非局部返回来模拟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun  testReturn()&#123;</div><div class="line">  run loop@&#123;</div><div class="line">      lists.forEach &#123; </div><div class="line">          if (it.equals(&quot;a&quot;)) return@loop</div><div class="line">          print(it)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">    print(&quot;out&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当要返一个回值得时候，解析器优先选用标签限制的return，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return@a 1</div></pre></td></tr></table></figure></p>
<p>意为“从标签 @a 返回 1”，而不是“返回一个标签标注的表达式 (@a 1)”。</p>
<hr>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>源文件通常以包声明开头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package foo.bar</div><div class="line"></div><div class="line">fun baz() &#123;&#125;</div><div class="line"></div><div class="line">class Goo &#123;&#125;</div><div class="line"></div><div class="line">// ……</div></pre></td></tr></table></figure></p>
<p>源文件所有内容（无论是类还是函数）都包含在声明的包内。所以上例中<code>baz()</code>的全名是<code>foo.bar.baz</code>、<code>Goo</code> 的全名是 <code>foo.bar.Goo</code>。<br>如果没有指明包，该文件的内容属于无名字的默认包。</p>
<h4 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h4><p>有多个包会默认导入到每个 Kotlin 文件中：</p>
<ul>
<li>kotlin.*</li>
<li>kotlin.annotation.*</li>
<li>kotlin.collections.*</li>
<li>kotlin.comparisons.*</li>
<li>kotlin.io.*</li>
<li>kotlin.ranges.*</li>
<li>kotlin.sequences.*</li>
<li>kotlin.text.*</li>
</ul>
<p>根据目标平台还会导入额外的包：</p>
<ul>
<li>JVM:<ul>
<li>java.lang.*</li>
<li>kotlin.jvm.*</li>
</ul>
</li>
<li>JS:<ul>
<li>kotlin.js.*</li>
</ul>
</li>
</ul>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>除了默认导入之外，每个文件可以包含它自己的导入指令。<br>可以导入一个单独的名字，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import foo.Bar // 现在 Bar 可以不用限定符访问</div></pre></td></tr></table></figure></p>
<p>也可以导入一个作用域下的所有内容（包、类、对象等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import foo.* // “foo”中的一切都可访问</div></pre></td></tr></table></figure></p>
<p>如果出现名字冲突，可以使用 as 关键字在本地重命名冲突项来消歧义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import foo.Bar // Bar 可访问</div><div class="line">import bar.Bar as bBar // bBar 代表“bar.Bar”</div></pre></td></tr></table></figure></p>
<p>关键词 import 并不仅限于导入类；也可用它来导入其他声明：</p>
<ul>
<li>顶层函数及属性；</li>
<li>在对象声明中声明的函数和属性;</li>
<li>枚举常量。</li>
</ul>
<p>与 Java 不同，Kotlin 没有单独的“import static”语法； 所有这些声明都用 import 关键字导入。</p>
<h4 id="顶层声明的可见性"><a href="#顶层声明的可见性" class="headerlink" title="顶层声明的可见性"></a>顶层声明的可见性</h4><p>如果顶层声明是 private 的，它是声明它的文件所私有的（参见 可见性修饰符）。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin学习/">Kotlin学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin开发/">Kotlin开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 daidai
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>