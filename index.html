<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="喜欢探索未知,保持好奇心">
<meta property="og:type" content="website">
<meta property="og:title" content="T9&#39;S Develop Blog">
<meta property="og:url" content="http://outofmemory.top/index.html">
<meta property="og:site_name" content="T9&#39;S Develop Blog">
<meta property="og:description" content="喜欢探索未知,保持好奇心">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="T9&#39;S Develop Blog">
<meta name="twitter:description" content="喜欢探索未知,保持好奇心">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://outofmemory.top/"/>





  <title>T9'S Develop Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">T9'S Develop Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不仅有工作，更有生活</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/28/Kotlin 学习笔记（八）—— Kotlin类与对象之接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/Kotlin 学习笔记（八）—— Kotlin类与对象之接口/" itemprop="url">Kotlin 学习笔记（八）—— Kotlin类与对象之接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T16:28:07+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79301071" target="_blank" rel="external">Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79315585" target="_blank" rel="external">Kotlin 学习笔记（五）—— Kotlin基础之控制流、返回与跳转、 包与导入</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79392850" target="_blank" rel="external">Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79401080" target="_blank" rel="external">Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段</a>  </p>
</blockquote>
<hr>
<p>##接口</p>
<p>Kotlin 的接口和 Java8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存柱状。它可以有属性但必须声明为抽象或提供访问器实现。</p>
<p>使用关键字 interface 来定义接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface A &#123;</div><div class="line">    fun setName()</div><div class="line"></div><div class="line">    fun setAge()&#123;</div><div class="line">        //可选方法体</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类或者对象可以实现一个或多个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class B : A &#123;</div><div class="line">    override fun setName() &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h3><p>你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现，在接口中声明的属性不能有幕后字段，因此接口中声明的访问器不能引用它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">interface A &#123;</div><div class="line">    val time:Int</div><div class="line">    </div><div class="line">    var name:String</div><div class="line">    get() = &quot;aaa&quot;</div><div class="line">    set(value) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    fun setName()</div><div class="line"></div><div class="line">    fun setAge()&#123;</div><div class="line">        //可选方法体</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B : A &#123;</div><div class="line">    override val time: Int</div><div class="line">        get() = 5</div><div class="line"></div><div class="line">    override fun setName() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解决覆盖冲突"><a href="#解决覆盖冲突" class="headerlink" title="解决覆盖冲突"></a>解决覆盖冲突</h3><p>实现多个接口或继承父类时，可能会遇到同一方法继承多个实现的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">interface A &#123;</div><div class="line">    fun foo() &#123; print(&quot;A&quot;) &#125;</div><div class="line">    fun bar()</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface B &#123;</div><div class="line">    fun foo() &#123; print(&quot;B&quot;) &#125;</div><div class="line">    fun bar() &#123; print(&quot;bar&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C : A &#123;</div><div class="line">    override fun bar() &#123; print(&quot;bar&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class D : A, B &#123;</div><div class="line">    override fun foo() &#123;</div><div class="line">        super&lt;A&gt;.foo()</div><div class="line">        super&lt;B&gt;.foo()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun bar() &#123;</div><div class="line">        super&lt;B&gt;.bar()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口 A 和 B 都定义了方法 foo() 和 bar()，两者都实现了foo()，但是只要 B 实现了bar()，bar()在 A 中没有标记为抽象，因为没有方法体时默认为抽象。因为 C 实现了 A 的具体类，所以必须重写 bar() 并实现这个抽象方法。</p>
<p>然而，如果我们从 A 和 B 派生 D，我们需要实现我们从多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。</p>
<hr>
<h2 id="gt-以上就是类与对象第三篇之接口，第四篇将学习可见性修饰符"><a href="#gt-以上就是类与对象第三篇之接口，第四篇将学习可见性修饰符" class="headerlink" title="&gt;以上就是类与对象第三篇之接口，第四篇将学习可见性修饰符"></a>&gt;以上就是类与对象第三篇之接口，第四篇将学习可见性修饰符</h2><p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a>  </p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/28/Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段/" itemprop="url">Kotlin 学习笔记（七）—— Kotlin类与对象之属性与字段</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T15:20:18+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79301071" target="_blank" rel="external">Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79315585" target="_blank" rel="external">Kotlin 学习笔记（五）—— Kotlin基础之控制流、返回与跳转、 包与导入</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79392850" target="_blank" rel="external">Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承</a></p>
</blockquote>
<hr>
<h2 id="属性与字段"><a href="#属性与字段" class="headerlink" title="属性与字段"></a>属性与字段</h2><h3 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h3><p>Kotlin的类可以有属性，属性可以用关键词 var 声明为可变， 否则使用只读关键字 val。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Kotlin3 &#123;</div><div class="line">    var name: String = &quot;name&quot;</div><div class="line">    var age: Int = 5</div><div class="line">    var city: String = &quot;Beijing&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用一个属性，只需要用名称引用即可，就像Java中的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun copyKotlin3(kotlin3: Kotlin3):Kotlin3&#123;</div><div class="line">    val kotlin3 = Kotlin3()</div><div class="line">    kotlin3.age = 30</div><div class="line">    kotlin3.name = &quot;kotlin4&quot;</div><div class="line">    return kotlin3</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Getters-与-Setters"><a href="#Getters-与-Setters" class="headerlink" title="Getters 与 Setters"></a>Getters 与 Setters</h3><p>声明一个属性的完整语法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">[&lt;getter&gt;]</div><div class="line">[&lt;setter&gt;]</div></pre></td></tr></table></figure></p>
<p>其初始化器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始化器（或者从其getter 返回值，如下文所示）中推断出来，也可以省略。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var defaultSize: Int?  // 错误：需要显式初始化器，隐含默认 getter 和 setter</div><div class="line">var defaultTime = 1 // 类型 Int、默认 getter 和 setter</div></pre></td></tr></table></figure></p>
<p>一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 val 开始代替 var ，2、只读属性不允许 setter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val defaultSize: Int?  // 错误：默认 getter</div><div class="line">val defaultTime = 1 // 类型 Int、默认 getter</div></pre></td></tr></table></figure></p>
<p>我们可以自定义访问器，非常像普通函数，刚好在属性声明内部。这里有一个自定义getter 的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var defaultName: String </div><div class="line">    get() = this.toString()</div><div class="line">    set(value) &#123;</div><div class="line">        value.toUpperCase()</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>按照惯例，setter 参数的名称是 value，如果你喜欢你可以选择其他名称。<br>自Kotlin 1.1 起，如果可以从getter 推断出属性类型，则可以省略属性类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var defaultAge</div><div class="line">    get() = this.toString()  //省略String类型</div><div class="line">    set(value) &#123;</div><div class="line">        value.toUpperCase()</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现，你可以定义访问器而不定义其实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var changeAge: String = &quot;aaa&quot;</div><div class="line">    private set  //此 setter 是私有的并且有默认实现</div><div class="line"></div><div class="line">var changeName: String? = null</div><div class="line">    @Inject set // 用 Inject 注解此 setter</div></pre></td></tr></table></figure></p>
<h3 id="幕后字段"><a href="#幕后字段" class="headerlink" title="幕后字段"></a>幕后字段</h3><p>在kotlin 类中不能直接声明字段。然而，当一个属性需要一个幕后字段时，Kotlin 会自动提供，这个幕后字段可以使用field 标识符在访问器中引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var count = 1</div><div class="line">    set(value) &#123;</div><div class="line">        if (value &gt; 0) field = value</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>field 标识符只能用在属性的访问器内</p>
<p>如果属性至少一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会为该属性生成一个幕后字段</p>
<p>例如，下面情况，就没有幕后字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val height: Int</div><div class="line">get() = defaultTime</div></pre></td></tr></table></figure></p>
<h3 id="幕后属性"><a href="#幕后属性" class="headerlink" title="幕后属性"></a>幕后属性</h3><p>如果你的需求不符合这套”隐式的幕后字段”方案，那么总可以使用<em>幕后属性（backing property）</em>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private var _table: Map&lt;String, Int&gt;? = null</div><div class="line">public val table: Map&lt;String, Int&gt;</div><div class="line">    get() &#123;</div><div class="line">        if (_table == null) &#123;</div><div class="line">            _table = HashMap() // 类型参数已推断出</div><div class="line">        &#125;</div><div class="line">        return _table ?: throw AssertionError(&quot;Set to null by another thread&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>从各方面来看，这正是与 Java 相同的方式。因为通过默认 getter 和 setter 访问私有属性会被优化，所以不会引入函数调用开销</p>
<h3 id="编译期常量"><a href="#编译期常量" class="headerlink" title="编译期常量"></a>编译期常量</h3><p>已知值的属性可以使用 const 修饰符标记为 <em>编译期常量</em>。这些属性需要满足以下条件：</p>
<ul>
<li>位于顶层或者是 object 的一个成语</li>
<li>用 String 或原生类型 值初始化</li>
<li>没有自定义 getter<br>这些属性可以用在注解中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const val SUBSYSTEM_DEPRECATED: String = &quot;This subsystem is deprecated&quot;</div><div class="line"></div><div class="line">@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() &#123; …… &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="延迟初始化属性与变量"><a href="#延迟初始化属性与变量" class="headerlink" title="延迟初始化属性与变量"></a>延迟初始化属性与变量</h3><p>一般地，属性声明为非空类型必须在构造函数中初始化。然而，这经常不方便。例如：属性可以通过依赖注入来初始化，或者在单元测试的setup方法中初始化，这种情况下，你不能在构造函数内提供一个非空初始器，但你仍想在类体中引用该属性时避免空检查。<br>为处理这种情况，你可以用 lateinit 修饰符标记该属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyTest &#123;</div><div class="line">    lateinit var subject: TestSubject</div><div class="line"></div><div class="line">    @SetUp fun setup() &#123;</div><div class="line">        subject = TestSubject()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test fun test() &#123;</div><div class="line">        subject.method()  // 直接解引用</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该修饰符只能用于类体中的属性（如果在主构造函数中声明的 var 属性，并且仅当该属性没有自定义 getter 或 setter 时），而自 Kotlin 1.2 起，也用于顶层属性与局部变量。该属性或变量必须为非空类型，并且不能是原生类型。</p>
<p>在初始化前访问一个 lateinit 属性会抛出一个特定异常，该异常明确标识该属性被访问及它没有初始化的事实。</p>
<h3 id="检测一个-lateinit-var-是否已初始化（自-1-2-起）"><a href="#检测一个-lateinit-var-是否已初始化（自-1-2-起）" class="headerlink" title="检测一个 lateinit var 是否已初始化（自 1.2 起）"></a>检测一个 lateinit var 是否已初始化（自 1.2 起）</h3><p>要检测一个 lateinit var 是否经过初始化，请在该属性的引用上使用 .isInitialized：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (foo::bar.isInitialized) &#123;</div><div class="line">    println(foo.bar)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此检测仅对可词法级访问的属性可用，即声明位于同一个类型内、位于其中一个外围类型中或者位于相同文件的顶层的属性。</p>
<h3 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h3><p>参见第<a href="http://blog.csdn.net/dazhaodai/article/details/79392850" target="_blank" rel="external"> Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承</a> —- 覆盖属性</p>
<h3 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h3><p>最常见的一类属性就是简单地从幕后字段中读取（以及可能的写入）。另一方面，使用自定义getter 和 setter 可以实现属性的任何行为，介于两者之间，属性如何工作有一些常见的模式，一些例子：惰性值、通过键值从映射读取。访问数据库。访问时通知侦听器等等。</p>
<p>这些常见行为可以通过委托属性实现为库，会在后续文章中介绍</p>
<hr>
<blockquote>
<p>本篇主要介绍了Kotlin类与对象之属性与字段，下篇文章学习kotlin之接口</p>
</blockquote>
<hr>
<p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/27/Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/27/Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承/" itemprop="url">Kotlin 学习笔记（六）—— Kotlin类与对象之类和继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-27T20:57:04+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79301071" target="_blank" rel="external"> Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79315585" target="_blank" rel="external"> Kotlin 学习笔记（五）—— Kotlin基础之控制流、返回与跳转、 包与导入</a></p>
</blockquote>
<hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Kotlin中使用关键字class声明类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Invoice &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类声明由类名、类头（指定其类型参数、主构造函数等）以及花括号包围的类体构成。类头和类体都是可选的；如果一个类没有类体，可以省略花括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Empty</div></pre></td></tr></table></figure></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在Kotlin中的一个类可以有一个<strong>主构造函数</strong>和一个或多个<strong>次构造函数</strong>，主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Person constructor(firstName: String) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个constructor关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Person(firstName: String) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主构造函数不能包含任何的代码。初始化代码可以放到以init关键字作为前缀的<strong>初始化块</strong>（<strong>initializer blocks</strong>）中。<br>在实例初始化期间，初始化块按照它们出现在类体重的顺序执行，与属性初始化器交织在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Kotlin1(fileName: String)&#123;</div><div class="line"></div><div class="line">    val time = fileName</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">       var size = time.length</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：主构造的参数可以在初始化块中使用，它们也可以在类体内声明的属性初始化器中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val time = fileName</div></pre></td></tr></table></figure></p>
<p>事实上，声明属性以及从主构造函数初始化属性，Kotlin有简洁的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Kotlin1(fileName: String,val size: Int,var age: Int)&#123;</div><div class="line">      //.... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。<br>如果构造函数有注解或可见性修饰符，这个constructor关键词是必须的，并且这些修饰符在它的前面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Customer public @Inject constructor(name: String) &#123; …… &#125;</div></pre></td></tr></table></figure></p>
<h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Kotlin1&#123;</div><div class="line">    </div><div class="line">    constructor(fileName: String, size: Int, age: Int) &#123;</div><div class="line">        val time = fileName</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数，可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用this关键字即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Kotlin1(fileName: String)&#123;</div><div class="line"></div><div class="line">   constructor(fileName: String, size: Int, age: Int) : this(fileName)&#123;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Kotlin1&#123;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">      print(&quot;first&quot;)  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(fileName: String, size: Int, age: Int)&#123;</div><div class="line">        print(&quot;second&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数，构造函数的可见性是public，如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Kotlin2 private constructor()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">注意：在JVM上，如果主构造函数的所有参数都有默认值，编译器会生成一个额外的无参构造函数，它将使用默认值，这使得Kotlin更易于像Jackson或者JPA这样的通过无参构造函数创建类的实例的库。</div><div class="line"></div><div class="line">  class Kotlin2 (val  fileName: String = &quot;&quot;)&#123;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>###创建类的实例<br>要创建一个类的实例，我们就像普通函数一样调用构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val kotlin2 = Kotlin2(&quot;music&quot;)</div></pre></td></tr></table></figure></p>
<p>注意Kotlin没有new 关键字<br>创建嵌套类、内部类和匿名内部类的类实例在嵌套类中有述。</p>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>类可以包含：</p>
<ul>
<li>构造函数和初始化块</li>
<li>函数</li>
<li>属性</li>
<li>嵌套类和内部类</li>
<li>对象声明</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在Kotlin 中所有类都有一个共同的超类 <code>Any</code>,这对于没有超类型声明的类是默认超类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Example // 从 Any 隐式继承</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注意：Any 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。 更多细节请查阅Java互操作性部分。</div></pre></td></tr></table></figure>
<p>要声明一个显式的超类型，我们把类型放到类头的冒号之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">      print(&quot;first&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(fileName: String, size: Int, age: Int)&#123;</div><div class="line">        print(&quot;second&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">类上的 open 标注与 Java 中 final相反，它允许其他类从这个类继承。默认情况下，在Kotlin中所有的类都是final，对应于 Effective Java书中的第17条：**要么为继承而设计，并提供说明文档，要么就禁止继承**。</div></pre></td></tr></table></figure>
<p>如果派生类有一个主构造函数，其基类型可以（并且必须）用基类的主构造函数参数就地初始化。</p>
<p>如果累没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyView : View &#123;</div><div class="line">    constructor(ctx: Context) : super(ctx)</div><div class="line"></div><div class="line">    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>我们之前提到过，Kotlin力求清晰显示，与Java 不同，Kotlin 需要显示标注可覆盖的成员（我们称之为开放）和覆盖后的成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">      print(&quot;first&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(fileName: String, size: Int, age: Int)&#123;</div><div class="line">        print(&quot;second&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open fun addSize()&#123;&#125;</div><div class="line">    fun  addAge()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20) &#123;</div><div class="line"></div><div class="line">    override  fun addSize() &#123;</div><div class="line">        super.addSize()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Kotlin2.addSize()函数上必须加上<strong>override</strong>标注，如果没写，编译器将会报错。如果函数没有标注<strong>open</strong> 和 Kotlin1.addAge()，则子类中不允许定义相同签名的函数，不论加不加 <strong>override</strong>。在一个final 类中，开放成员是禁止的。</p>
<p>标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用final 关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20) &#123;</div><div class="line"></div><div class="line">    final override  fun addSize() &#123;</div><div class="line">        super.addSize()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h3><p>属性覆盖和方法覆盖类似：在超类中声明然后在派生类中重新声明的属性必须以override 开头，并且它们必须具有兼容的类型。每个声明的属性可以由具有初始化的属性或者具有getter方法的属性覆盖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line">    open val aa: Int get() &#123;</div><div class="line">        return 5</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1 &#123;</div><div class="line">    override val aa: Int</div><div class="line">        get() = super.aa + 5</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你也可以用一个 var 属性覆盖一个 val 属性，但是反之则不行。这是允许的，因为一个 val 属性本质上声明了 一个 getter 方法，而将其覆盖为 var 只是在子类中额外 声明一个 setter方法。</p>
<p>请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface Foo &#123;</div><div class="line">    val count: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bar1(override val count: Int) : Foo</div><div class="line"></div><div class="line">class Bar2 : Foo &#123;</div><div class="line">    override var count: Int = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="派生类初始化顺序"><a href="#派生类初始化顺序" class="headerlink" title="派生类初始化顺序"></a>派生类初始化顺序</h3><p>在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">open class Base(val name: String) &#123;</div><div class="line"></div><div class="line">    init &#123; println(&quot;Initializing Base&quot;) &#125;</div><div class="line"></div><div class="line">    open val size: Int = </div><div class="line">    name.length.also &#123; println(&quot;Initializing size in Base: $it&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Derived(</div><div class="line">    name: String,</div><div class="line">    val lastName: String</div><div class="line">) : Base(name.capitalize().also &#123; println(&quot;Argument for Base: $it&quot;) &#125;) &#123;</div><div class="line"></div><div class="line">    init &#123; println(&quot;Initializing Derived&quot;) &#125;</div><div class="line"></div><div class="line">    override val size: Int =</div><div class="line">    (super.size + lastName.length).also &#123; println(&quot;Initializing size in Derived: $it&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Constructing Derived(&quot;hello&quot;, &quot;world&quot;)</div><div class="line">Argument for Base: Hello</div><div class="line">Initializing Base</div><div class="line">Initializing size in Base: 5</div><div class="line">Initializing Derived</div><div class="line">Initializing size in Derived: 10</div></pre></td></tr></table></figure></p>
<p>这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化，如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或者运行时故障，设计一个基类时，应该避免这种在构造函数、属性初始化器以及init 块中使用 open 成员</p>
<h3 id="调用超类实现"><a href="#调用超类实现" class="headerlink" title="调用超类实现"></a>调用超类实现</h3><p>派生类中的代码可以使用super 关键字调用其超类的函数与属性访问器的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">      print(&quot;first&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(fileName: String, size: Int, age: Int)&#123;</div><div class="line">        print(&quot;second&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open fun addSize()&#123;</div><div class="line">        print(&quot;Kotlin1&quot;)</div><div class="line">    &#125;</div><div class="line">    fun  addAge()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20) &#123;</div><div class="line"></div><div class="line">    override  fun addSize() &#123;</div><div class="line">        super.addSize()</div><div class="line">        print(&quot;Kotlin2&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在一个内部类中访问外部类的超类，可以通过由外部类名限定的super关键字来实现： <code>super@Outer</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Bar : Foo() &#123;</div><div class="line">    override fun f() &#123; /* …… */ &#125;</div><div class="line">    override val x: Int get() = 0</div><div class="line"></div><div class="line">    inner class Baz &#123;</div><div class="line">        fun g() &#123;</div><div class="line">            super@Bar.f() // 调用 Foo 实现的 f()</div><div class="line">            println(super@Bar.x) // 使用 Foo 实现的 x 的 getter</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h3><p>在Kotlin中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现，它必须覆盖这个成员并提供自己的实现（也许用继承来的其中之一）。为了表示采用从哪个超类型继承的实现，我们使用尖括号中超类型名限定的super，例如 <code>super&lt;Base&gt;</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">open class Kotlin1&#123;</div><div class="line">    open fun addSize()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface A &#123;</div><div class="line">    fun addSize()&#123;</div><div class="line">        println(&quot;aa&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Kotlin2  : Kotlin1(&quot;music&quot;,20,20),A &#123;</div><div class="line"></div><div class="line">    override  fun addSize() &#123;</div><div class="line">        super&lt;Kotlin1&gt;.addSize()</div><div class="line">        super&lt;A&gt;.addSize()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时继承Kotlin1 和 A 没问题，但是addSize() 由 Kotlin2 继承了两个实现，所以我们必须在 Kotlin2 中覆盖addSize() 并且提供我们自己的实现来消除歧义。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>类和其中的某些成员可以声明为abstract。 抽象成员在本类中可以不用实现，需要注意的是，我们并不需要用 open 标注一个抽象类火灾函数 – 因为这不言而喻</p>
<p>我们可以用一个抽象成员覆盖一个非抽象的开放成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">open class Base &#123;</div><div class="line">    open fun f() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class Derived : Base() &#123;</div><div class="line">    override abstract fun f()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>与Java 或者 C# 不同，在Kotlin 中类没有静态方法，在大多数情况下，它建议简单地使用包级函数。</p>
<p>如果你需要写一个无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。</p>
<p>更具体的讲，如果在你的类内部声明了一个伴生对象，你就可以使用像在Java/C# 中调用静态方法相同的语法来调用其成员，只使用类名作为限定符。</p>
<hr>
<h2 id="gt-以上就是类与对象的第一篇–类和继承"><a href="#gt-以上就是类与对象的第一篇–类和继承" class="headerlink" title="&gt;以上就是类与对象的第一篇–类和继承"></a>&gt;以上就是类与对象的第一篇–类和继承</h2><p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/12/Kotlin基础之控制流、返回与跳转、 包与导入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/12/Kotlin基础之控制流、返回与跳转、 包与导入/" itemprop="url">Kotlin 学习笔记（五）—— Kotlin基础之控制流、返回与跳转、 包与导入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-12T11:22:20+08:00">
                2018-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79301071" target="_blank" rel="external"> Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a></p>
</blockquote>
<hr>
<h2 id="控制流：if、when、for、while"><a href="#控制流：if、when、for、while" class="headerlink" title="控制流：if、when、for、while"></a>控制流：if、when、for、while</h2><h4 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h4><p>在Kotlin中，if是一个表达式，即它会返回一个值。因此就不需要三元运算符（条件？ 然后： 否则），因为普通的if就能胜任这个角色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 传统用法</div><div class="line">  var max = a </div><div class="line">  if (a &lt; b) max = b</div><div class="line"></div><div class="line">  // With else </div><div class="line">  var max: Int</div><div class="line">  if (a &gt; b) &#123;</div><div class="line">      max = a</div><div class="line">  &#125; else &#123;</div><div class="line">      max = b</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  // 作为表达式</div><div class="line">  val max = if (a &gt; b) a else b</div></pre></td></tr></table></figure></p>
<p>if的分支可以是代码块，最后的表达式作为该块的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val a1 = 101</div><div class="line">val b1 = 5</div><div class="line">var d1 = if (a1 &gt; b1) &#123;</div><div class="line">    print(a1)</div><div class="line">    a1</div><div class="line">&#125;else&#123;</div><div class="line">    print(b1)</div><div class="line">    b1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h4><p>when 取代了C语言的switch操作符。最简单的形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    1 -&gt; print(&quot;x == 1&quot;)</div><div class="line">    2 -&gt; print(&quot;x == 2&quot;)</div><div class="line">    else -&gt; &#123; // 注意这个块</div><div class="line">       print(&quot;x is neither 1 nor 2&quot;)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>when 将它的参数和所有分支条件顺序比较，直到某个分支满足条件。when既可以被当做表达式使用也可以被当做语句使用。如果它被当作表达式，符合条件的分支的值就是整个表达式的值，如果当作语句使用，则忽略个别分支的值。（像if 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值）</p>
<p>如果其他分支都不满足条件将会求值else分支。如果一个when作为一个表达式使用，则必须有else分支，除非编译器能够检测出所有的可能情况都已经覆盖了。</p>
<p>如果很多分支需要用相同的方式处理，则可以把多个分支放在一起，用逗号隔开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var  max = 100</div><div class="line"></div><div class="line">fun compareTo()&#123;</div><div class="line">    when(max)&#123;</div><div class="line">        0,1 -&gt; print(&quot;max == 0 or max == 1&quot;)</div><div class="line">        else -&gt; print(&quot;otherwise&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以用任意表达式（而不是常量）作为分支条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">when(max)&#123;</div><div class="line">    parseInt(a1.toString()) -&gt; print(&quot;max encodes x&quot;)</div><div class="line">    else -&gt; print(&quot;otherwise&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    in 1..10 -&gt; print(&quot;x is in the range&quot;)</div><div class="line">    in validNumbers -&gt; print(&quot;x is valid&quot;)</div><div class="line">   !in 10..20 -&gt; print(&quot;x is outside the range&quot;)</div><div class="line">   else -&gt; print(&quot;none of the above&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一种可能是检测一个值是（is）或者不是（!is）一个特定类型的值。注意：由于智能转换，你可以访问该类型的方法和属性而不需要任何额外的检测。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun hasPrefix(x: Any) = when(x)&#123;</div><div class="line">    is String -&gt; x.startsWith(&quot;prefix&quot;)</div><div class="line">    else -&gt; false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>when 也可以用来取代 if-else if链，如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">when &#123;</div><div class="line">    x.isOdd() -&gt; print(&quot;x is odd&quot;)</div><div class="line">    x.isEven() -&gt; print(&quot;x is even&quot;)</div><div class="line">    else -&gt; print(&quot;x is funny&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h4><p>for循环可以对任何提供迭代器（iterator）的对象进行遍历，这相当于C#这样的语言中的<code>foreach</code>循环，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (item  in lists)  print(item)</div></pre></td></tr></table></figure></p>
<p>循环体可以是一个代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (item in lists)&#123;</div><div class="line">    print(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>综上所述，for可以循环遍历任何提供了迭代器的对象，即：</p>
<ul>
<li>有一个成员函数或者拓展函数<code>iterator</code>，它的返回类型</li>
<li>有一个成员函数或者拓展函数<code>next()</code>，并且返回 Boolean</li>
<li>有一个成员函数或者扩展函数 hasNext() 返回 Boolean。</li>
</ul>
<p>这三个函数都需要标记为<code>operator</code>。</p>
<p>对数组的for循环会被编译为并不创建迭代器的基于索引的循环。</p>
<p>如果你想通过索引遍历一个数组或者list，可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (i in array.indices) &#123;</div><div class="line">    print(array[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这种”在区间遍历”会编译成优化的实现而不会创建额外对象；</p>
<p>或者你可以用库函数<code>withIndex</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ((index, value) in array.withIndex()) &#123;</div><div class="line">    println(&quot;the element at $index is $value&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h4><p>while和do..while照常使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">while (x &gt; 0) &#123;</div><div class="line">   x--</div><div class="line">&#125;</div><div class="line"></div><div class="line">do &#123;</div><div class="line">  val y = retrieveData()</div><div class="line">&#125; while (y != null) // y 在此处可见</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h2><p>Kotlin有三种结构化跳转表达式：</p>
<ul>
<li>return。默认从最直接包围它的函数或者匿名函数返回。</li>
<li>break。终止最直接包围它的循环。</li>
<li>continue。继续下一次最直接包围它的循环。</li>
</ul>
<p>所有这些表达式都可以用作更大表达式的一部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val s = person.name ?: return</div></pre></td></tr></table></figure></p>
<p>这些表达式的类型是Nothing类型。</p>
<h4 id="Break-与-Continue-标签"><a href="#Break-与-Continue-标签" class="headerlink" title="Break 与 Continue 标签"></a>Break 与 Continue 标签</h4><p>在 Kotlin 中任何表达式都可以用标签（Label）来标记，标签的格式为标识符后跟 @ 符号，例如：adc@ 、fast@ 都是有效的标签（参见语法）。要为一个表达式加标签，我们只要在其前加标签即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">loop@ for (i in 1..100)&#123;</div><div class="line">    for (j in 1..100)&#123;</div><div class="line">        if (j == 50) break@loop</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。continue 继续标签制定的循环的下一次迭代。</p>
<h4 id="标签处返回"><a href="#标签处返回" class="headerlink" title="标签处返回"></a>标签处返回</h4><p>Kotlin有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。标签限制的return允许我们从外层函数返回。最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    fun foo() &#123;</div><div class="line">    listOf(1, 2, 3, 4, 5).forEach &#123;</div><div class="line">        if (it == 3) return // 非局部直接返回到 foo() 的调用者</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">    println(&quot;this point is unreachable&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里 return 表达式从最直接包围它的函数即 foo 中返回。（注意，这种非局部的返回只支持传给内联函数的 lambda 表达式）如果我们需要从 lambda 表达式中返回，我们必须给它加上标签并用以限制 return。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    fun foo() &#123;</div><div class="line">    listOf(1, 2, 3, 4, 5).forEach lit@&#123;</div><div class="line">        if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">    print(&quot; done with explicit label&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，它只会从lambda 表达式中返回。通常情况下使用隐式标签更方便。该标签与接受该lambda 的函数同名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    fun foo() &#123;</div><div class="line">    listOf(1, 2, 3, 4, 5).forEach &#123;</div><div class="line">        if (it == 3) return@forEach // 局部返回到该 lambda 表达式的调用者，即 forEach 循环</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">    print(&quot; done with implicit label&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者我们用一个匿名函数替代 lambda 表达式。匿名函数内部的 return 语句将从该匿名函数自身返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun  testReturn()&#123;</div><div class="line">    lists.forEach(fun(value: String) &#123;</div><div class="line">        if (value.startsWith(&quot;a&quot;)) return  //局部返回到匿名函数的调用者，即foreach 循环</div><div class="line">        print(value)</div><div class="line">    &#125;)</div><div class="line">    print(&quot;finfish&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请注意，前文三个实例中使用的局部返回类似于在常规循环中使用continue。并没有 break 的直接等价形式，不过可以通过增加另一层嵌套 lambda 表达式并不从其中非局部返回来模拟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun  testReturn()&#123;</div><div class="line">  run loop@&#123;</div><div class="line">      lists.forEach &#123; </div><div class="line">          if (it.equals(&quot;a&quot;)) return@loop</div><div class="line">          print(it)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">    print(&quot;out&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当要返一个回值得时候，解析器优先选用标签限制的return，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return@a 1</div></pre></td></tr></table></figure></p>
<p>意为“从标签 @a 返回 1”，而不是“返回一个标签标注的表达式 (@a 1)”。</p>
<hr>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>源文件通常以包声明开头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package foo.bar</div><div class="line"></div><div class="line">fun baz() &#123;&#125;</div><div class="line"></div><div class="line">class Goo &#123;&#125;</div><div class="line"></div><div class="line">// ……</div></pre></td></tr></table></figure></p>
<p>源文件所有内容（无论是类还是函数）都包含在声明的包内。所以上例中<code>baz()</code>的全名是<code>foo.bar.baz</code>、<code>Goo</code> 的全名是 <code>foo.bar.Goo</code>。<br>如果没有指明包，该文件的内容属于无名字的默认包。</p>
<h4 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h4><p>有多个包会默认导入到每个 Kotlin 文件中：</p>
<ul>
<li>kotlin.*</li>
<li>kotlin.annotation.*</li>
<li>kotlin.collections.*</li>
<li>kotlin.comparisons.*</li>
<li>kotlin.io.*</li>
<li>kotlin.ranges.*</li>
<li>kotlin.sequences.*</li>
<li>kotlin.text.*</li>
</ul>
<p>根据目标平台还会导入额外的包：</p>
<ul>
<li>JVM:<ul>
<li>java.lang.*</li>
<li>kotlin.jvm.*</li>
</ul>
</li>
<li>JS:<ul>
<li>kotlin.js.*</li>
</ul>
</li>
</ul>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>除了默认导入之外，每个文件可以包含它自己的导入指令。<br>可以导入一个单独的名字，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import foo.Bar // 现在 Bar 可以不用限定符访问</div></pre></td></tr></table></figure></p>
<p>也可以导入一个作用域下的所有内容（包、类、对象等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import foo.* // “foo”中的一切都可访问</div></pre></td></tr></table></figure></p>
<p>如果出现名字冲突，可以使用 as 关键字在本地重命名冲突项来消歧义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import foo.Bar // Bar 可访问</div><div class="line">import bar.Bar as bBar // bBar 代表“bar.Bar”</div></pre></td></tr></table></figure></p>
<p>关键词 import 并不仅限于导入类；也可用它来导入其他声明：</p>
<ul>
<li>顶层函数及属性；</li>
<li>在对象声明中声明的函数和属性;</li>
<li>枚举常量。</li>
</ul>
<p>与 Java 不同，Kotlin 没有单独的“import static”语法； 所有这些声明都用 import 关键字导入。</p>
<h4 id="顶层声明的可见性"><a href="#顶层声明的可见性" class="headerlink" title="顶层声明的可见性"></a>顶层声明的可见性</h4><p>如果顶层声明是 private 的，它是声明它的文件所私有的（参见 可见性修饰符）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/09/Kotlin基础之基本类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/Kotlin基础之基本类型/" itemprop="url">Kotlin 学习笔记（四）—— Kotlin基础之基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-09T18:51:42+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79298087" target="_blank" rel="external">Kotlin 学习笔记（三）—— 习惯用法</a></p>
</blockquote>
<hr>
<p>在Kotlin中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数和属性，一些类型可以有特殊的内部表示–例如，数字、字符和布尔值可以在运行时表示为原生类型值，但是对于用户来说，他们看起来就像普通类，在本篇中，将描述Kotlin中使用的基本类型：数字、字符、布尔值、数组与字符串。</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>Kotlin处理数字在某种程度上接近Java，但是不完全相同，例如，对于数字没有隐式拓宽转换（例如Java中int 可以隐式转换为long），另外有些情况的字面值略有不同。</p>
<p>Kotlin 提供了如下的内置类型来表示数字：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Bit Width</th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>64</td>
</tr>
<tr>
<td>Float</td>
<td>32</td>
</tr>
<tr>
<td>Long</td>
<td>64</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
</tr>
<tr>
<td>Short</td>
<td>16</td>
</tr>
<tr>
<td>Byte</td>
<td>8</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Kotlin中字符不是数字</p>
</blockquote>
<h4 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h4><p>数值常量字面值有以下几种：</p>
<ul>
<li>十进制<br> -Long 类型用大写L标记：<code>32L</code></li>
<li>十六进制：<code>0x0F</code></li>
<li>二进制：<code>0b00001011</code><blockquote>
<p>注意：不支持八进制<br>Kotlin同样支持浮点数的常规表示方法：<br>  –默认double：<code>22.2</code>、<code>240.5e10</code><br>  – Float用 <code>f</code> 或者 <code>F</code> 标记：<code>234.5f</code></p>
</blockquote>
</li>
</ul>
<p>数字字面值的下划线（自1.1起）<br>可以使用下划线使数字常量更具有可读性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val sixMillion = 6_000_000</div><div class="line">val phoneNumber = 138_0013_8000</div><div class="line">val creditCardNumber = 1234_5678_9012_3456L</div></pre></td></tr></table></figure></p>
<h4 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h4><p>在Java平台数字是物理存储为JVM的原生类型，除非我们需要一个可空的引用（如<code>Int？</code>） 或泛型，后者情况下会把数字装箱。<br>注意数字装箱不必保留同一性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val a: Int = 10000</div><div class="line">print(a === a) // 输出“true”</div><div class="line">val boxedA: Int? = a</div><div class="line">val anotherBoxedA: Int? = a</div><div class="line">print(boxedA === anotherBoxedA) // ！！！输   出“false”！！！</div></pre></td></tr></table></figure></p>
<p>另一方面，保留了相等性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val a: Int = 10000</div><div class="line">print(a == a) // 输出“true”</div><div class="line">val boxedA: Int? = a</div><div class="line">val anotherBoxedA: Int? = a</div><div class="line">print(boxedA == anotherBoxedA) // 输出“true”</div></pre></td></tr></table></figure></p>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>由于不同的表达方式，较小类型并不是较大类型的子类型。如果它们是的话，就会出现下面问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 假想的代码，实际上并不能编译：</div><div class="line">val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)</div><div class="line">val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)</div><div class="line">print(a == b) // 惊！这将输出“false”鉴于 Long 的 equals() 检测其他部分也是 Long</div></pre></td></tr></table></figure></p>
<p>所以同一性还有相等性都会在所有地方悄无声息地失去</p>
<p>因此较小的类型不能隐式转换为较大的类型。这意味着在不进行显式转换的情况下我们不能把<code>byte</code>类型赋值给一个<code>Int</code>类型变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val a: Byte = 1 </div><div class="line">val b: Int = b //错误，无法赋值</div></pre></td></tr></table></figure></p>
<p>不过，我们可以通过显式转换来拓宽数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val c: Int = a.toInt()  //OK：显式拓宽</div></pre></td></tr></table></figure></p>
<p>每个数字类型都支持如下的转换：</p>
<ul>
<li><code>toByte(): Byte</code></li>
<li><code>toShort(): Short</code></li>
<li><code>toInt(): Int</code></li>
<li><code>toLong(): Long</code></li>
<li><code>toFloat(): Float</code></li>
<li><code>toDouble(): Double</code></li>
<li><code>toChar(): Char</code><br>缺乏隐式类型转换并不显著，因此类型会从上下文来推断出来，而算术运算会有重载做适当转换，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val l = 1L + 3 // Long + Int =&gt; Long</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>Kotlin 支持数字运算的标准集，运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。<br>对于运算符，没有特殊字符表示，而只可用中椎方式调用命令函数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val x = (1 shl 2) and 0x000FF000</div></pre></td></tr></table></figure></p>
<p>这是完整的位运算列表（只用于 <code>Int</code> 和 <code>Long</code>）：</p>
<ul>
<li><code>shl(bits)</code> – 有符号左移 (Java 的 &lt;&lt;)</li>
<li><code>shr(bits)</code> – 有符号右移 (Java 的 &gt;&gt;)</li>
<li><code>ushr(bits)</code> – 无符号右移 (Java 的 &gt;&gt;&gt;)</li>
<li><code>and(bits)</code> – 位与</li>
<li><code>or(bits)</code> – 位或</li>
<li><code>xor(bits)</code> – 位异或</li>
<li><code>inv()</code> – 位非</li>
</ul>
<h4 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h4><p>本节讨论的浮点数操作如下：</p>
<ul>
<li>相等性检测：<code>a == b</code> 与 <code>a != b</code></li>
<li>比较操作符：<code>a &lt; b</code> 、<code>a &gt; b</code>、<code>a &lt;= b</code>、<code>a &gt;= b</code></li>
<li>区间实例以及区间检测：<code>a..b</code>、<code>x in a..b</code>、 <code>x !in a..b</code></li>
</ul>
<p>其中的操作数<code>a</code>、<code>b</code>都是静态已知的<code>FLoat</code> 或 <code>Double</code> 或者它们对呀的可空类型（声明为该类型，或者推断为该类型，或者智能类型转换的结果是该类型），两数字所形成的操作或者区间遵循IEEE 754浮点运算标准。</p>
<p>然而，为了支持泛型场景并提供全序支持，当这些操作符并非静态类型为浮点数（例如是 Any、 Comparable&lt;……&gt;、 类型参数）时，这些操作使用为 Float 与 Double 实现的不符合标准的 equals 与 compareTo，这会出现：</p>
<ul>
<li>认为 NaN 与其自身相等</li>
<li>认为 NaN 比包括正无穷大（POSITIVE_INFINITY）在内的任何其他元素都大</li>
<li>认为 -0.0 小于 0.0</li>
</ul>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>字符使用<code>Char</code>类型表示。它们不能直接当作数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun check(char : Char)&#123;</div><div class="line">    if (char == 1)&#123;  //❎，类型不兼容</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>字符字面值要用单引号括起来 <code>&#39;1&#39;</code>,特殊字符可以用反斜杠转义。支持以下转义序列：<code>\t</code> 、<code>\b</code> 、<code>\n</code> 、<code>\r</code>、 <code>\&#39;</code>、 <code>\&quot;</code>、 <code>\\</code> 、<code>\$</code>。编码其他字符要用Unicode转义序列语法： <code>&#39;\uFF00&#39;</code><br>我们可以显式把字符转为Int数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun chartoInt(char: Char) : Int &#123;</div><div class="line">    if (char in &apos;0&apos;..&apos;9&apos;)&#123;</div><div class="line">        return char.toInt() - &apos;0&apos;.toInt()</div><div class="line">    &#125;</div><div class="line">    throw IllegalArgumentException(&quot;out of range&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性</p>
<h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><p>布尔使用<code>Boolean</code>类型表示，只有两个值：<code>true</code> 和 <code>false</code><br>布尔运算符：</p>
<ul>
<li><code>||</code>  -短路逻辑或</li>
<li><code>&amp;&amp;</code>  -短路逻辑与</li>
<li><code>！</code>  -逻辑非</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组在Kotlin中使用<code>Array</code>类来表示，它定义了<code>get</code>和<code>set</code>函数（按照运算符重载约定这会转变为[]）和<code>size</code>属性，以及一些其他有用的成员函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Array&lt;T&gt; private constructor() &#123;</div><div class="line">    val size: Int</div><div class="line">    operator fun get(index: Int): T</div><div class="line">    operator fun set(index: Int, value: T): Unit</div><div class="line"></div><div class="line">    operator fun iterator(): Iterator&lt;T&gt;</div><div class="line">    // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以使用库函数<code>arrayOf()</code>来创建一个数组并传递元素值给它，这样<code>arrayOf(1, 2, 3)</code>创建了array[1, 2, 3]。或者，库函数<code>arrayOfNulls()</code>可以创建一个制定大小的、所有元素都为空的数组。</p>
<p>另一个选项是用接受数组大小和一个函数参数的<code>Array</code>构造函数，用作参数的函数能够返回给定索引的每个元素初始值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建一个 Array&lt;Int&gt; 初始值为[0，1，4，9]数组</div><div class="line">val intArray = Array(4,&#123;i -&gt; i * i &#125;)</div></pre></td></tr></table></figure></p>
<p>如上所述，<code>[]</code>运算符代表调用成员函数<code>get()</code>和<code>set()</code>。</p>
<p>注意：与Java不同的是，Kotlin中数组是不型变的（invariant），这意味着不能把<code>Array&lt;String&gt;</code> 赋值给 <code>Array&lt;Any&gt;</code>,以防止可能的运行时失败（但是你可以用<code>Array&lt;Out Any&gt;</code>）</p>
<p>Kotlin 也有无装箱开销的专门的类来表示原生类型数组：<code>ByteAray</code> 、<code>ShortArray</code>、<code>IntArray</code> 等等。这些类和<code>Array</code>并没有继承关系，但是它们有相同的方法属性集。它们也有相应的工厂方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val intArray1 = intArrayOf(1,1,1,1)</div><div class="line">intArray1[0] = intArray1[1] + intArray1[2]</div></pre></td></tr></table></figure></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串用 <code>String</code> 类型来表示，字符串是不可变的，字符串的元素 – 字符 可以使用索引运算符访问：<code>s[i]</code>，可以用for循环迭代字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val str = &quot;Kotlin and Java&quot;</div><div class="line"></div><div class="line">fun sortStr()&#123;</div><div class="line">    for (s in str)&#123;</div><div class="line">        print(s)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h4><p>Kotlin 有两种类型的字符串字面值：转义字符串可以有转义字符，以及原生字符串可以包含换行和任意文本。转义字符串很像Java字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val s = &quot;Hello, world!\n&quot;</div></pre></td></tr></table></figure></p>
<p>转义采用传统的反斜杠方式。参见上面的 字符 查看支持的转义序列。<br>原生字符串 使用三个引号(“””)分解符括起来，内部没有转义并且可以包含换行和其他字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val text = &quot;&quot;&quot;</div><div class="line">   for (c in &quot;foo&quot;)</div><div class="line">       print(c)</div><div class="line">&quot;&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>你可以通过 trimMargin() 函数去除前导空格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val text = &quot;&quot;&quot;</div><div class="line">  |Tell me and I forget.</div><div class="line">  |Teach me and I remember.</div><div class="line">  |Involve me and I learn.</div><div class="line">  |(Benjamin Franklin)</div><div class="line">  &quot;&quot;&quot;.trimMargin()</div></pre></td></tr></table></figure></p>
<p>默认使用<code>|</code>用作边界前缀，但你可以选择其他字符作为参数传入，例如trimMargin(“a”)。</p>
<h4 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h4><p>字符串可以包含模板表达式，即一些小段代码，会求值并把结果合并到字符串中。模板表达式以美元符(<code>$</code>)开头，由一个简单的名字构成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val str = &quot;Kotlin and Java&quot;</div><div class="line">val newStr = &quot;i = $str&quot;</div></pre></td></tr></table></figure></p>
<p>或者使用花括号括起来的任意表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val str = &quot;Kotlin and Java&quot;</div><div class="line">val newStr = &quot;$str.length is $&#123;str.length&#125;&quot;  //&quot;Kotlin and Java.length is 15&quot;</div></pre></td></tr></table></figure></p>
<p>原生字符串和转义字符串内部都支持模板，如果你需要在原生字符串中表示字面值<code>$</code>字符（它不支持反斜杠转义），你可以用下列语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val price = &quot;&quot;&quot;</div><div class="line">    $&#123;&apos;$&apos;&#125;0.88</div><div class="line">    &quot;&quot;&quot;</div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>本篇主要学习Kotlin基本类型，包括 数字、字符、布尔、数组字符串</p>
</blockquote>
<hr>
<p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/09/习惯用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/习惯用法/" itemprop="url">Kotlin 学习笔记（三）—— 习惯用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-09T14:16:13+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a><br><a href="http://blog.csdn.net/dazhaodai/article/details/79293555" target="_blank" rel="external"> Kotlin 学习笔记（二）—— 基础语法</a></p>
</blockquote>
<hr>
<p>下面是一些在Kotlin中广泛使用的语法习惯。</p>
<h4 id="创建DTOs（POJOs-POCOs）"><a href="#创建DTOs（POJOs-POCOs）" class="headerlink" title="创建DTOs（POJOs/POCOs）"></a>创建DTOs（POJOs/POCOs）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data class Customer(val name: String,val email: String)&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会为 Customer 类提供以下功能：</p>
<ul>
<li>所有属性的 getters （对于 var 定义的还有 setters）</li>
<li>equals()</li>
<li>hashCode()</li>
<li>toString()</li>
<li>copy()</li>
<li>所有属性的 component1()、 component2()……等等</li>
</ul>
<h4 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun foo(a: Int = 0, b: String = &quot;&quot;) &#123; …… &#125;</div></pre></td></tr></table></figure>
<h4 id="过滤-list"><a href="#过滤-list" class="headerlink" title="过滤 list"></a>过滤 list</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val lists = listOf(&quot;aa&quot;, &quot;ab&quot;, &quot;ac&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)</div><div class="line"></div><div class="line">fun sortList()&#123;    </div><div class="line">    val AList = lists.filter &#123; x -&gt; x.startsWith(&quot;a&quot;) &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者可以更短：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun sortList()&#123;</div><div class="line">    val AList = lists.filter &#123;it.startsWith(&quot;a&quot;) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="String-内插"><a href="#String-内插" class="headerlink" title="String 内插"></a>String 内插</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println(&quot;Name $name&quot;)</div></pre></td></tr></table></figure>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    is Foo //-&gt; ……</div><div class="line">    is Bar //-&gt; ……</div><div class="line">    else   //-&gt; ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="遍历-map-pair型list"><a href="#遍历-map-pair型list" class="headerlink" title="遍历 map/pair型list"></a>遍历 map/pair型list</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val map = mapOf(&quot;a&quot; to 1,&quot;b&quot; to 2,&quot;c&quot; to 3)</div><div class="line"></div><div class="line">fun sortMap()&#123;</div><div class="line">    for ((k, v) in map)&#123;</div><div class="line">        print(&quot;$k -&gt; $v&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用区间"><a href="#使用区间" class="headerlink" title="使用区间"></a>使用区间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (i in 1..100) &#123; …… &#125;  // 闭区间：包含 100</div><div class="line">for (i in 1 until 100) &#123; …… &#125; // 半开区间：不包含 100</div><div class="line">for (x in 2..10 step 2) &#123; …… &#125;</div><div class="line">for (x in 10 downTo 1) &#123; …… &#125;</div><div class="line">if (x in 1..10) &#123; …… &#125;</div></pre></td></tr></table></figure>
<h4 id="只读-list"><a href="#只读-list" class="headerlink" title="只读 list"></a>只读 list</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div></pre></td></tr></table></figure>
<h4 id="只读-map"><a href="#只读-map" class="headerlink" title="只读 map"></a>只读 map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</div></pre></td></tr></table></figure>
<h4 id="访问-map"><a href="#访问-map" class="headerlink" title="访问 map"></a>访问 map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">println(map[&quot;key&quot;])</div><div class="line">map[&quot;key&quot;] = value</div></pre></td></tr></table></figure>
<h4 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val p: String by lazy &#123;</div><div class="line">    // 计算该字符串</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun String.spaceToCamelCase() &#123; …… &#125;</div><div class="line"></div><div class="line">&quot;Convert this to camelcase&quot;.spaceToCamelCase()</div></pre></td></tr></table></figure>
<h4 id="创建单例"><a href="#创建单例" class="headerlink" title="创建单例"></a>创建单例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object Resource &#123;</div><div class="line">    val name = &quot;Name&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="If-not-null-缩写"><a href="#If-not-null-缩写" class="headerlink" title="If not null 缩写"></a>If not null 缩写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val files = File(&quot;Test&quot;).listFiles()</div><div class="line"></div><div class="line">println(files?.size)</div></pre></td></tr></table></figure>
<h4 id="If-not-null-and-else-缩写"><a href="#If-not-null-and-else-缩写" class="headerlink" title="If not null and else 缩写"></a>If not null and else 缩写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val files = File(&quot;Test&quot;).listFiles()</div><div class="line"></div><div class="line">println(files?.size ?: &quot;empty&quot;)</div></pre></td></tr></table></figure>
<h4 id="if-null-执行一个语句"><a href="#if-null-执行一个语句" class="headerlink" title="if null 执行一个语句"></a>if null 执行一个语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val values = ……</div><div class="line">val email = values[&quot;email&quot;] ?: throw IllegalStateException(&quot;Email is missing!&quot;)</div></pre></td></tr></table></figure>
<h4 id="在可能会空的集合中取第一元素"><a href="#在可能会空的集合中取第一元素" class="headerlink" title="在可能会空的集合中取第一元素"></a>在可能会空的集合中取第一元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val emails = ... // 可能会是空集合</div><div class="line">val mainEmail = emails.firstOrNull() ?: &quot;&quot;</div></pre></td></tr></table></figure>
<h4 id="if-not-null-执行代码"><a href="#if-not-null-执行代码" class="headerlink" title="if not null 执行代码"></a>if not null 执行代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val value = ……</div><div class="line"></div><div class="line">value?.let &#123;</div><div class="line">    …… // 代码会执行到此处, 假如data不为null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="映射可空值（如果非空的话）"><a href="#映射可空值（如果非空的话）" class="headerlink" title="映射可空值（如果非空的话）"></a>映射可空值（如果非空的话）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val value = ……</div><div class="line"></div><div class="line">val mapped = value?.let &#123; transformValue(it) &#125; ?: defaultValueIfValueIsNull</div></pre></td></tr></table></figure>
<h4 id="返回-when-表达式"><a href="#返回-when-表达式" class="headerlink" title="返回 when 表达式"></a>返回 when 表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun transform(color: String): Int &#123;</div><div class="line">    return when (color) &#123;</div><div class="line">        &quot;Red&quot; -&gt; 0</div><div class="line">        &quot;Green&quot; -&gt; 1</div><div class="line">        &quot;Blue&quot; -&gt; 2</div><div class="line">        else -&gt; throw IllegalArgumentException(&quot;Invalid color param value&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="“try-catch”表达式"><a href="#“try-catch”表达式" class="headerlink" title="“try/catch”表达式"></a>“try/catch”表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun test() &#123;</div><div class="line">    val result = try &#123;</div><div class="line">        count()</div><div class="line">    &#125; catch (e: ArithmeticException) &#123;</div><div class="line">        throw IllegalStateException(e)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 使用 result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="“if”表达式"><a href="#“if”表达式" class="headerlink" title="“if”表达式"></a>“if”表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun foo(param: Int) &#123;</div><div class="line">    val result = if (param == 1) &#123;</div><div class="line">        &quot;one&quot;</div><div class="line">    &#125; else if (param == 2) &#123;</div><div class="line">        &quot;two&quot;</div><div class="line">    &#125; else &#123;</div><div class="line">        &quot;three&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="返回类型为-Unit-的方法的-Builder-风格用法"><a href="#返回类型为-Unit-的方法的-Builder-风格用法" class="headerlink" title="返回类型为 Unit 的方法的 Builder 风格用法"></a>返回类型为 Unit 的方法的 Builder 风格用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun arrayOfMinusOnes(size: Int): IntArray &#123;</div><div class="line">    return IntArray(size).apply &#123; fill(-1) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单表达式函数"><a href="#单表达式函数" class="headerlink" title="单表达式函数"></a>单表达式函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun theAnswer() = 42</div></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun theAnswer(): Int &#123;</div><div class="line">    return 42</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单表达式函数与其它惯用法一起使用能简化代码，例如和 when 表达式一起使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun transform(color: String): Int = when (color) &#123;</div><div class="line">    &quot;Red&quot; -&gt; 0</div><div class="line">    &quot;Green&quot; -&gt; 1</div><div class="line">    &quot;Blue&quot; -&gt; 2</div><div class="line">    else -&gt; throw IllegalArgumentException(&quot;Invalid color param value&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="对一个对象实例调用多个方法-（with）"><a href="#对一个对象实例调用多个方法-（with）" class="headerlink" title="对一个对象实例调用多个方法 （with）"></a>对一个对象实例调用多个方法 （with）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Turtle &#123;</div><div class="line">    fun penDown()</div><div class="line">    fun penUp()</div><div class="line">    fun turn(degrees: Double)</div><div class="line">    fun forward(pixels: Double)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//获取实例</div><div class="line">val myTurtle = Turtle()</div><div class="line">with(myTurtle) &#123; // 画一个 100 像素的正方形</div><div class="line">    penDown()</div><div class="line">    for(i in 1..4) &#123;</div><div class="line">        forward(100.0)</div><div class="line">        turn(90.0)</div><div class="line">    &#125;</div><div class="line">    penUp()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Java-7-的-try-with-resources"><a href="#Java-7-的-try-with-resources" class="headerlink" title="Java 7 的 try with resources"></a>Java 7 的 try with resources</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val stream = Files.newInputStream(Paths.get(&quot;/some/file.txt&quot;))</div><div class="line">stream.buffered().reader().use &#123; reader -&gt;</div><div class="line">    println(reader.readText())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对于需要泛型信息的泛型函数的适宜形式"><a href="#对于需要泛型信息的泛型函数的适宜形式" class="headerlink" title="对于需要泛型信息的泛型函数的适宜形式"></a>对于需要泛型信息的泛型函数的适宜形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//  public final class Gson &#123;</div><div class="line">//     ……</div><div class="line">//     public &lt;T&gt; T fromJson(JsonElement json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123;</div><div class="line">//     ……</div><div class="line"></div><div class="line">inline fun &lt;reified T: Any&gt; Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java)</div></pre></td></tr></table></figure>
<h4 id="使用可空布尔"><a href="#使用可空布尔" class="headerlink" title="使用可空布尔"></a>使用可空布尔</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val b: Boolean? = ……</div><div class="line">if (b == true) &#123;</div><div class="line">    ……</div><div class="line">&#125; else &#123;</div><div class="line">    // `b` 是 false 或者 null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>第三篇文章主要学习Kotlin开发中的习惯用法</p>
</blockquote>
<hr>
<p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/08/Kotlin 学习笔记（二）—— 基础语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/Kotlin 学习笔记（二）—— 基础语法/" itemprop="url">Kotlin 学习笔记（二）—— 基础语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T20:59:43+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a></p>
</blockquote>
<hr>
<h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h2><h4 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h4><p>包的声明应该处于源文件顶部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">package hard.uistudy.dai.uifinaltest.main.view.fragment</div><div class="line"></div><div class="line">import android.os.Bundle</div><div class="line">import android.support.v4.app.Fragment</div></pre></td></tr></table></figure></p>
<h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>带有两个Int 参数、返回Int 的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun addNumber(a : Int, b: Int) : Int &#123;</div><div class="line">    return a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将表达式作为函数体、返回值类型自动推断的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun addNumber(a: Int, b: Int) = a + b</div></pre></td></tr></table></figure></p>
<p>函数返回无意义的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun printSum(a: Int, b: Int): Unit &#123;</div><div class="line">    println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Unit 返回类型可以省略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun printSum(a: Int, b: Int) &#123;</div><div class="line">    println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>一次赋值（只读不可写）的局部变量,使用<code>val</code>修饰:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val a : Int =5  //立即赋值</div><div class="line">val text  = &quot;aaa&quot;  //自动推断类型</div></pre></td></tr></table></figure></p>
<p>可变变量（可读可写）,使用<code>var</code>修饰:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var b = 5 // 自动推断出 `Int` 类型</div><div class="line">b = 6</div><div class="line"></div><div class="line">/**</div><div class="line"> * 定义暂不赋值，lateinit不能用在可空的属性上和java的基本类型上,lateinit只能修饰var</div><div class="line"> */</div><div class="line">lateinit var open : String</div><div class="line">...</div><div class="line">open = &quot;aaa&quot;</div></pre></td></tr></table></figure></p>
<p>  顶层变量：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  val PI = 3.14</div><div class="line">var x = 0</div><div class="line"></div><div class="line">fun incrementX() &#123; </div><div class="line">    x += 1 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>同Java一样，kotlin也支持行注释 及 块注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这是一个行注释</div><div class="line"></div><div class="line">/* 这是一个多行的</div><div class="line">   块注释。 */</div></pre></td></tr></table></figure></p>
<h4 id="使用字符串模板"><a href="#使用字符串模板" class="headerlink" title="使用字符串模板"></a>使用字符串模板</h4><p>使用$符号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1</div><div class="line">// 模板中的简单名称：</div><div class="line">val s1 = &quot;a is $a&quot; </div><div class="line"></div><div class="line">a = 2</div><div class="line">// 模板中的任意表达式：</div><div class="line">val s2 = &quot;$&#123;s1.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot;</div></pre></td></tr></table></figure></p>
<h4 id="使用条件表达式"><a href="#使用条件表达式" class="headerlink" title="使用条件表达式"></a>使用条件表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun maxOf(a: Int, b: Int): Int &#123;</div><div class="line">    if (a &gt; b) &#123;</div><div class="line">        return a</div><div class="line">    &#125; else &#123;</div><div class="line">        return b</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 if 作为表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b</div></pre></td></tr></table></figure></p>
<h4 id="使用可空值及-null-检测"><a href="#使用可空值及-null-检测" class="headerlink" title="使用可空值及 null 检测"></a>使用可空值及 null 检测</h4><p>当某个变量的值可能为null时，必须在声明处的类型后添加<code>?</code>来标识该引用可为空。<br>如果<code>text</code>的内容不是数字返回null：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun parseInt(string: String) : Int?&#123;</div><div class="line">  return  if (string.toInt() != null) string.toInt() else null</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用返回可空值的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fun  getProduct(str1: String, str2: String)&#123;</div><div class="line">    val x = parseInt(str1)</div><div class="line">    val y = parseInt(str2)</div><div class="line"></div><div class="line">    if (x != null &amp;&amp; y != null)&#123;</div><div class="line">        print(x + y)</div><div class="line">    &#125; else&#123;</div><div class="line">        println(&quot;either &apos;$str1&apos; or &apos;$str2&apos; is not a number&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者 分别分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// ……</div><div class="line">if (x == null) &#123;</div><div class="line">    println(&quot;Wrong number format in arg1: &apos;$arg1&apos;&quot;)</div><div class="line">    return</div><div class="line">&#125;</div><div class="line">if (y == null) &#123;</div><div class="line">    println(&quot;Wrong number format in arg2: &apos;$arg2&apos;&quot;)</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在空检测后，x 和 y 会自动转换为非空值</div><div class="line">println(x * y)</div></pre></td></tr></table></figure></p>
<h4 id="使用类型检测及自动类型转换"><a href="#使用类型检测及自动类型转换" class="headerlink" title="使用类型检测及自动类型转换"></a>使用类型检测及自动类型转换</h4><p>is 运算符检测一个表达式是否为某类型的一个实例。如果一个不可变的局部变量或者属性已经判断出为某类型，那么检测后的 分支直接当做该类型使用，无需显示转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun getStrigLength(obj:Any): Int?&#123;</div><div class="line">    if (obj is String)&#123;</div><div class="line">        // `obj` 在该条件分支内自动转换成 `String`</div><div class="line">        return obj.length</div><div class="line">    &#125;</div><div class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</div><div class="line">    return null</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">    if (obj !is String) return null</div><div class="line">​</div><div class="line">    // `obj` 在这一分支自动转换为 `String`</div><div class="line">    return obj.length</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>甚至</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">    // `obj` 在 `&amp;&amp;` 右边自动转换成 `String` 类型</div><div class="line">    if (obj is String &amp;&amp; obj.length &gt; 0) &#123;</div><div class="line">        return obj.length</div><div class="line">    &#125;</div><div class="line">​</div><div class="line">    return null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-for-循环"><a href="#使用-for-循环" class="headerlink" title="使用 for 循环"></a>使用 for 循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val list  = arrayListOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)</div><div class="line"></div><div class="line">fun printList()&#123;</div><div class="line">    for (item in list)&#123;</div><div class="line">        print(item)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val list  = arrayListOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)</div><div class="line"></div><div class="line">fun printList()&#123;</div><div class="line">    for (index in list.indices)&#123;</div><div class="line">        print(&quot;$list at $index value is $&#123;list[index]&#125; &quot; )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="使用While循环"><a href="#使用While循环" class="headerlink" title="使用While循环"></a>使用While循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val list  = arrayListOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)</div><div class="line"></div><div class="line">fun printList()&#123;</div><div class="line">    var index = 0</div><div class="line">   while (index &lt; list.size)&#123;</div><div class="line">       print(&quot;$index,$&#123;list[index]&#125;&quot;)</div><div class="line">       index++</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用When循环"><a href="#使用When循环" class="headerlink" title="使用When循环"></a>使用When循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun printList(index : Int) : String =</div><div class="line">    when (index )&#123;</div><div class="line">        1 -&gt; &quot;$index value is 1&quot;</div><div class="line">        2 -&gt; &quot;$index value is 2&quot;</div><div class="line">        3 -&gt; &quot;$index value is 3&quot;</div><div class="line">        4 -&gt; &quot;$index value is 4&quot;</div><div class="line">        else  -&gt; &quot;null&quot;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="使用区间（range）"><a href="#使用区间（range）" class="headerlink" title="使用区间（range）"></a>使用区间（range）</h4><p>使用 in 运算符来检测某个数字是否在指定区间内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">val startIndex = 10</div><div class="line">val endIndex = 20</div><div class="line"></div><div class="line">fun sortNum()&#123;</div><div class="line">    if (startIndex in 1.. endIndex)&#123;</div><div class="line">        print(&quot;$startIndex is in range&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>区间迭代:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun sortNum()&#123;</div><div class="line">    for (index in startIndex .. endIndex)&#123;</div><div class="line">        print(index)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数列迭代<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//每次跳过3个元素</div><div class="line">for (index in startIndex .. endIndex step 3)&#123;</div><div class="line">    print(index)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//降序遍历，每次跳过3个元素</div><div class="line">for (index in endIndex downTo startIndex step 3)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检测某个数字是否在指定区间外:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line"></div><div class="line">if (-1 !in 0..list.lastIndex) &#123;</div><div class="line">    println(&quot;-1 is out of range&quot;)</div><div class="line">&#125;</div><div class="line">if (list.size !in list.indices) &#123;</div><div class="line">    println(&quot;list size is out of valid list indices range too&quot;)</div><div class="line">&#125;</div><div class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line">​</div><div class="line">if (-1 !in 0..list.lastIndex) &#123;</div><div class="line">    println(&quot;-1 is out of range&quot;)</div><div class="line">&#125;</div><div class="line">if (list.size !in list.indices) &#123;</div><div class="line">    println(&quot;list size is out of valid list indices range too&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h4><p>对集合进行迭代:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val lists = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line"></div><div class="line">fun sortList()&#123;</div><div class="line">    for (item in lists)&#123;</div><div class="line">        print(item)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用in 运算符来判断集合内是否包含某实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">val lists = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line"></div><div class="line">fun sortList()&#123;</div><div class="line">    when&#123;</div><div class="line">        &quot;a&quot; in lists -&gt; print(&quot;a&quot;)</div><div class="line">        &quot;b&quot; in lists -&gt; print(&quot;b&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用lambda 表达式来过滤（filter）和映射(map)集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">val lists = listOf(&quot;aa&quot;, &quot;ab&quot;, &quot;ac&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)</div><div class="line"></div><div class="line">fun sortList()&#123;</div><div class="line">   lists.filter &#123; it.startsWith(&quot;a&quot;)&#125;  //过滤出 a 开头的元素</div><div class="line">           .sortedBy &#123; it &#125;   //排序</div><div class="line">           .map &#123; it.toUpperCase() &#125;  //将字符串转为大写</div><div class="line">           .forEach &#123; print(it) &#125;  //遍历输出字符串</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="创建基本类及其实例"><a href="#创建基本类及其实例" class="headerlink" title="创建基本类及其实例"></a>创建基本类及其实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val rectangele = Rectangle()  //不需要 new 关键字</div><div class="line">val triangle = Triangle()</div></pre></td></tr></table></figure>
<hr>
<h2 id="gt-以上就是第二篇的全部内容，先学习到这里，第三篇继续学习基础教程"><a href="#gt-以上就是第二篇的全部内容，先学习到这里，第三篇继续学习基础教程" class="headerlink" title="&gt;以上就是第二篇的全部内容，先学习到这里，第三篇继续学习基础教程"></a>&gt;以上就是第二篇的全部内容，先学习到这里，第三篇继续学习基础教程</h2><p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/08/Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料/" itemprop="url">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T14:10:39+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="Kotlin学习笔记系列教程"><a href="#Kotlin学习笔记系列教程" class="headerlink" title="Kotlin学习笔记系列教程"></a>Kotlin学习笔记系列教程</h3><blockquote>
<p><a href="http://blog.csdn.net/dazhaoDai/article/details/79293475" target="_blank" rel="external">Kotlin 学习笔记（一）—— 概述、学习曲线、开发工具、参考资料</a></p>
</blockquote>
<hr>
<h2 id="1-Kotlin-概述"><a href="#1-Kotlin-概述" class="headerlink" title="1. Kotlin 概述"></a>1. Kotlin 概述</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Kotlin 是一门支持多范式、多平台的现代静态编程语言。Kotlin 支持面向对象、泛型与函数式等编程范式，它支持 JVM、Android、JavaScript 目标平台，而原生（Native）平台的 Kotlin 几天前也发布了 0.2 版本。而且 Kotlin 具有很多现代（也有称下一代的）静态语言特性：如类型推断、多范式支持、可空性表达、扩展函数、模式匹配等。因此上面描述毫不夸张，它是一门非常有潜力的新兴语言。</p>
<p>另外 100% 的 Java 互操作性，使 Kotlin 能够与既有工具/框架如 Dagger、Spring、Vert.x 等集成，也能让既有的基于 Java 的服务端与 Android 项目逐步迁移到 Kotlin。</p>
<h4 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h4><p>创建一种兼容Java的语言，让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针<br>让它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。<br>让它比最成熟的竞争对手Scala语言更加简单</p>
<blockquote>
<p>总结：Kotlin就是一个基于JVM，可以兼容Java并且比Java更简洁，能够静态检测常见陷阱的的新的编程语言</p>
</blockquote>
<p>2017年Google I/O正式将Kotlin列为官方开发语言</p>
<h2 id="2-学习曲线"><a href="#2-学习曲线" class="headerlink" title="2. 学习曲线"></a>2. 学习曲线</h2><p>和大多数编程语言一样，学习由浅及深<br>从 基础语法 -&gt; 类与对象 -&gt; 函数表达式 -&gt; 类型检查 -&gt; 核心库 -&gt; Java操作</p>
<h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3. 开发工具"></a>3. 开发工具</h2><p><code>Intellij IDEA</code>是由JetBrains开发，而且Kotlin就是JetBrains开发的语言，所以毫无疑问 <code>Intellij IDEA</code><br>是最合适不过的开发工具。<br><code>Android Studio</code>是<code>Intellij IDEA</code>的插件实现的Android开发IDE，同理支持Kotlin开发，特别是AndroidStudio3.0更新后，Google官方默认支持Kotlin，无需插件。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><p><a href="https://www.kotlincn.net/docs/reference/kotlin-doc.html" target="_blank" rel="external">Kotlin中文站</a><br><a href="https://zhuanlan.zhihu.com/bennyhuo?topic=Kotlin" target="_blank" rel="external">Kotlin知乎专栏</a><br><a href="https://www.gitbook.com/book/hltj/kotlin-reference-chinese/details" target="_blank" rel="external">Kotlin 语言官方参考文档 中文版</a></p>
<hr>
<blockquote>
<p>第一篇文章简单介绍kotlin简介、开发工具、学习资料等基础，后面将继续学习Kotlin基础</p>
</blockquote>
<hr>
<p>个人博客地址：<a href="http://outofmemory.top/">http://outofmemory.top/</a><br>CSDN地址：<a href="http://blog.csdn.net/dazhaoDai" target="_blank" rel="external">http://blog.csdn.net/dazhaoDai</a><br>GitHub地址：<a href="https://github.com/dazhaoDai" target="_blank" rel="external">https://github.com/dazhaoDai</a></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/02/07/Android自定义View(八) -- 硬件加速/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Android自定义View(八) -- 硬件加速/" itemprop="url">Android自定义View(八) -- 硬件加速</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T20:33:07+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面学习的内容:<br><a href="https://www.jianshu.com/p/c5e5734279aa" target="_blank" rel="external">Android自定义View(一) – 初识</a><br><a href="https://www.jianshu.com/p/d7c3bbaef731" target="_blank" rel="external">Android自定义View(二) – Paint详解</a><br><a href="https://www.jianshu.com/p/89939ede6add" target="_blank" rel="external">Android自定义View(三) – drawText()</a><br><a href="https://www.jianshu.com/p/bef2482c675d" target="_blank" rel="external">Android自定义View(四) – Canvas</a><br><a href="https://www.jianshu.com/p/c186df6140b5" target="_blank" rel="external">Android自定义View(五) – 绘制顺序</a><br><a href="https://www.jianshu.com/p/6f705507097a" target="_blank" rel="external">Android自定义View(六) – 属性动画(上)</a><br><a href="https://www.jianshu.com/p/b0fc1b601f2c" target="_blank" rel="external">Android自定义View(七) – 属性动画(下)</a></p>
<hr>
<h2 id="本文计划根据HenCoder系列文章进行学习，所以代码风格及博文素材可能会摘自其中"><a href="#本文计划根据HenCoder系列文章进行学习，所以代码风格及博文素材可能会摘自其中" class="headerlink" title="本文计划根据HenCoder系列文章进行学习，所以代码风格及博文素材可能会摘自其中"></a>本文计划根据<a href="https://link.jianshu.com/?t=http%3A%2F%2Fhencoder.com%2F" target="_blank" rel="external">HenCoder</a>系列文章进行学习，所以代码风格及博文素材可能会摘自其中</h2><hr>
<p>硬件加速经常被提及，很多人感兴趣，这个词给人的概念大概有两种：快速、不稳定。</p>
<p>对很多人来说，硬件加速似乎是一个只可远观而不可亵玩的高科技：是，听说很牛逼，但是不敢乱用，甚至不知道什么时候使用</p>
<p>今天就试着把硬件加速的原理和应用，好好了解一下：</p>
<p>  1.硬件加速的本质和原理；</p>
<p>   2.硬件加速在Android中的应用；</p>
<p>   3.硬件加速在Android正宗的限制。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在正式开始之前需要说明一下，作为绘制部分的最后一期，本期内容只是为了内容的完整性做一个补充，因为之前好几期的内容里都有涉及硬件加速的技术点，而一些读者因为不了解硬件加速而产生了一些疑问。所以仅仅从难度上来讲，这期的内容并不难，并且本期的大部分内容你都可以从这两个页面中找到：</p>
<ol>
<li><a href="https://developer.android.google.cn/guide/topics/graphics/hardware-accel.html" target="_blank" rel="external">Hardware Acceleration | Android Developers</a></li>
<li><a href="https://www.youtube.com/watch?v=v9S5EO7CLjo" target="_blank" rel="external">Google I/O 2011: Accelerated Android Rendering</a></li>
</ol>
<p>下面进入正题。</p>
<p>所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。</p>
<p>而对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 <code>Canvas.drawXXX()</code> 变成实际的像素这件事。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在硬件加速关闭的时候，<code>Canvas</code> 绘制的工作方式是：把要绘制的内容写进一个 <code>Bitmap</code>，然后在之后的渲染过程中，这个 <code>Bitmap</code> 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 <code>Canvas.drawCircle()</code> 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。大致就像这样：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fjmybsw31fj30nb0iywfq.jpg" alt=""></p>
<p>而开启硬件加速后，Canvas的工作方式改变了：它把绘制的内容转为GPU的操作保存下来，然后交给GPU来完成显示工作。大致过程：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fjmygtwiutj30nb0o2ta8.jpg" alt=""></p>
<blockquote>
<p>如图，硬件加速开启时，CPU的工作是把绘制工作转换为GPU的操作，这个工作量相对来说还是非常小的。</p>
</blockquote>
<h2 id="怎么「加速」了"><a href="#怎么「加速」了" class="headerlink" title="怎么「加速」了"></a>怎么「加速」了</h2><p>从上图可以看出，开启硬件加速后，绘制的计算工作有CPU交给GPU，不过这怎么就能起到加速作用，让绘制变快了呢？</p>
<p>硬件加速能够让绘制变快，主要有三个原因：</p>
<ol>
<li>本来CPU的工作，分摊一部分给GPU，自然可以提高效率；</li>
<li>相对于CPU来说，GPU自身的设计本来就对于很多常见类型内容的计算(例如简单的圆形、方形)具有优势；</li>
<li>由于绘制流程的不同；硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免一些重复操作，从而大幅提升绘制效率。</li>
</ol>
<p>其中前两点可以总结为一句话：<strong>用了GPU，绘制就是快</strong>，原因很直观，不再多说。</p>
<p>关于第三点，它的原理大致说一下：</p>
<p>前面说到，关闭硬件加速时，绘制内容会被CPU转为实际的像素，然后直接渲染到屏幕，具体来说，这个[实际的像素]，是由bitmap承载的，在界面的某个View由于内容发生改变而调用invalidat()方法时，如果没有开启硬件加速，为了正确计算bitmap的像素，这个View的父View、父View的父View乃至一直向上知道最顶级的View，以及所有和它相交的View，都需要被调用invalidate()来重绘，一个View的改变使得大半个界面甚至整个界面重绘一遍，这个工作量是非常大的。</p>
<p>而在开启硬件加速时，前面说过，绘制的内容会被转换成GPU的操作保存下来(承载的形式成为displaylist,对应的类也叫作DisplayList)，再转交给GPU。由于所有绘制的内容都没有变成最终的像素，所以它们之间是相互独立的，那么在界面内容发生改变时，只需把发生了改变的View调用invalidate()方法以更新它所对应的GPU就好，至于它的父View和兄弟View，只需要保持原样，那么这个工作量就很小了。</p>
<p>正是由于上面的原因，硬件加速不仅是由于GPU的引入提高效率，而且因为<strong>绘制机制的改变，而极大的提高了界面内容改变时的刷新效率</strong></p>
<p>所以把上面三条压缩总结一下，硬件加速更快的原因有两条：</p>
<ol>
<li>用了GPU，绘制更快了</li>
<li>绘制机制的改变，导致界面内容改变时的刷新效率极大提高。</li>
</ol>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>如果仅仅是这样，硬件加速只有好处没有坏处，那大家不必要关心其他问题，直接使用就行了，那这篇文章也没有必要了，既然是好东西，关心那么多原理干嘛？</p>
<p>可事实就是，硬件加速不止有好处，也有限制：收到GPU绘制方式的限制，Canvas的有些方法在硬件加速开启时会失效或者无法正常工作，比如：开启硬件加速，clipPath()在 API 18及以上系统中才有效，具体的 API 限制和 API 版本的关系如下图：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fjn0huxdm5j30lr0q0n25.jpg" alt=""></p>
<p>所以，如果你对自定义控件有自定义绘制的内容，最好参照一下表格，确保你的绘制操作可以正确地在所有用户手机中正常显示，而不是只在你最新Android系统的 Nexus 或 Pixel 里测试一遍没问题就发布。那就小心被祭天了。</p>
<p>不过有一点可以放心的是，所有的原生自带控件，都没有用到 API 版本不兼容的绘制操作，可以放心使用。所以你只要检查你写的自定义绘制就好。</p>
<h2 id="View-Layer"><a href="#View-Layer" class="headerlink" title="View Layer"></a>View Layer</h2><p>在之前几期的内容里我提到过几次，如果你的绘制操作不支持硬件加速，你需要手动关闭硬件加速来绘制界面，关闭的方式是通过这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setLayerType(LAYER_TYPE_SOFTWARE, null);</div></pre></td></tr></table></figure>
<p>很多人有过疑问：什么是layer type？如果这个方法是关闭硬件加速的开关，那么它的参数为什么不是一个LAYER_TYPE_SOFTWARE来关闭硬件加速以及一个LAYER_TYPE_HARDWARE来开启硬件加速，这两个参数，而是三个参数，第三个参数为LAYER_TYPE_NONE，难道还能既不用软件绘制又不用硬件绘制吗？</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fjnhdt0s41j3069069wep.jpg" alt=""></p>
<p>事实上，<code>view.setLayerType(LAYER_TYPE_SOFTWARE, null)</code>这个方法的作用并不是关闭硬件加速，只是当它的参数为LAYER_TYPE_SOFTWARE的时候，可以<strong>顺便</strong>把硬件加速关掉而已；并且除了这个方法外，Android并没有提供专门的View级别的硬件加速开关，所以它就<strong>顺便</strong>成了一个开关硬件加速的方法。</p>
<p><code>setLayerType()</code> 这个方法，它的作用其实就是字面的意思：设置View Layer的类型。所谓ViewLayer，又称为离屏缓冲（off-screen Buffer），它的作用就是单独启用一块地方来绘制这个View，而不是使用绘制软件的Bitmap或者通过硬件加速的GPU，这块地方可能是一块单独的bitmap，也可能是一块OpenGL的纹理（texture，OpenGL的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采取什么来绘制View不是关键，关键在于当设置了View Layer的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把GPU的操作保存下来再交给GPU去计算。通过这样更进一步的缓存方式，View的重绘效率进一步提高了:只要绘制的内容没变，那么不论是CPU绘制还是GPU绘制，都不用重新计算，只要用之前缓存的结果就可以了。</p>
<blockquote>
<p>多说一句，其实这个离屏缓冲（Off-screen Buffer），更准确的说应该叫做离屏缓存（Off-screen Cache）会更合适一点。原因在上面这一段里已经说过了，因为它其实是缓存而不是缓冲。（这段话仅代表个人意见）</p>
</blockquote>
<p>基于这样的原理，在进行移动、旋转等（无需调用 <code>invalidate()</code>）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View。所以在这种动画的过程中开启 Hardware Layer，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。实现方式大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">view.setLayerType(LAYER_TYPE_HARDWARE, null);  </div><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180);</div><div class="line"></div><div class="line">animator.addListener(new AnimatorListenerAdapter() &#123;  </div><div class="line">    @Override</div><div class="line">    public void onAnimationEnd(Animator animation) &#123;</div><div class="line">        view.setLayerType(LAYER_TYPE_NONE, null);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">animator.start();</div></pre></td></tr></table></figure>
<p>或者如果是使用 <code>ViewPropertyAnimator</code>，那么更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">view.animate()  </div><div class="line">        .rotationY(90)</div><div class="line">        .withLayer(); // withLayer() 可以自动完成上面这段代码的复杂操作</div></pre></td></tr></table></figure>
<p>不过一定要注意，只有你在对 <code>translationX</code> <code>translationY</code> <code>rotation</code> <code>alpha</code> 等无需调用 <code>invalidate()</code> 的属性做动画的时候，这种方法才适用，因为这种方法本身利用的就是当界面不发生时，缓存未更新所带来的时间的节省。所以简单地说——</p>
<p><strong>这种方式不适用于基于自定义属性绘制的动画。</strong>一定记得这句话。</p>
<p>另外，除了用于关闭硬件加速和辅助属性动画这两项功能外，Layer 还可以用于给 View 增加一些绘制效果，例如设置一个 <code>ColorMatrixColorFilter</code> 来让 View 变成黑白的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = new ColorMatrix();  </div><div class="line">colorMatrix.setSaturation(0);</div><div class="line"></div><div class="line">Paint paint = new Paint();  </div><div class="line">paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));</div><div class="line"></div><div class="line">view.setLayerType(LAYER_TYPE_HARDWARE, paint);</div></pre></td></tr></table></figure>
<p>另外，由于设置了ViewLayer后，View在初次绘制时以及每次invalidate()后重绘时，需要进行两次的绘制工作(一次绘制到Layer，一次从Layer绘制到显示屏)，所以其实它的每次绘制的效率是被降低了的，所以一定要慎重使用View Layer，在需要用到它的时候再去使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本期内容就是这些，就像文章开始说的，本期知识是作为一个完整的补充，并么有太多重要或者高难度的东西，我也没有准备视频或者太多的截图或者GIF 去说明，总结一下：</p>
<p>硬件加速指使用GPU来完成绘制的计算工作，代替CPU，它从工作分摊和绘制机制优化两个角度提升了绘制速度。</p>
<p>硬件加速可以使用setLayerType()来关闭硬件加速，但这个方法其实是用来设置View Layer的：</p>
<ol>
<li>参数为  <code>LAYER_TYPE_SOFTWARE</code> 时，使用软件来绘制View Layer，绘制到一个Bitmap，并顺便关闭硬件加速；</li>
<li>参数为 <code>LAYER_TYPE_HARDWARE</code> 时，使用GPU来绘制View Layer，绘制到一个OpenGL texture(如果硬件加速关闭，那么行为和LAYER_TYPE_SOFTWARE一致)；</li>
<li>参数为 <code>LAYER_TYPE_NONE</code> 时，关闭View Layer。</li>
</ol>
<p>View Layer 可以加速无 <code>invalidate()</code> 时的刷新效率，但对于需要调用 <code>invalidate()</code> 的刷新无法加速。</p>
<p>View Layer 绘制所消耗的实际时间是比不使用 View Layer 时要高的，所以要慎重使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2017/10/30/Git常用操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/Git常用操作/" itemprop="url">Git常用操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-30T12:53:07+08:00">
                2017-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>  Git作为日常开发的版本管理系统，功能强大，操作简单，简直不要太方便，但是，常用口令，却是我们必须要掌握的，比较AS安装Git插件，使用命令行才是最快捷方便的</p>
<h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>  开发中：常用操作就那么几个，那就一一罗列出来：</p>
<h5 id="1-从远程服务器Clone分支"><a href="#1-从远程服务器Clone分支" class="headerlink" title="1.从远程服务器Clone分支"></a>1.从远程服务器Clone分支</h5><p>见我之前文章  <a href="http://www.jianshu.com/p/1a03c3637091" target="_blank" rel="external">Git从远端服务器Clone分支到本地</a></p>
<h5 id="2-将本地分支推送到远端新分支"><a href="#2-将本地分支推送到远端新分支" class="headerlink" title="2.将本地分支推送到远端新分支"></a>2.将本地分支推送到远端新分支</h5><p>开发中遇到一种情况，本地分支Local1是从远端某分支Remote1 Clone下来的，但是开发之后，想将本地分支保存到远端的新分支Remote2上，而远端仓库是没有这个Remote2分支的，那么执行以下命令：<code>git push origin &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code>，<br>例如我当前操作：<code>git push origin Local1:Remote2</code></p>
<h5 id="3-删除本地仓库某个分支"><a href="#3-删除本地仓库某个分支" class="headerlink" title="3.删除本地仓库某个分支"></a>3.删除本地仓库某个分支</h5><p>想删除本地仓库某个分支，执行：<code>git branch -D &lt;local_branch_name&gt;</code>,例如：想删除本地仓库widget2分支，执行命令：<code>git branch -D widget2</code>；</p>
<h5 id="4-删除远端仓库某分支"><a href="#4-删除远端仓库某分支" class="headerlink" title="4.删除远端仓库某分支"></a>4.删除远端仓库某分支</h5><p>删除远端仓库分支和删除本地类似：<code>git push origin :{remote_branch_name}</code>，例如删除远端develop分支：<code>git push origin :develop</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">daidai</p>
              <p class="site-description motion-element" itemprop="description">喜欢探索未知,保持好奇心</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">daidai</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
