<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="daidai" />


    
    


<meta name="description" content="喜欢探索未知,保持好奇心">
<meta property="og:type" content="website">
<meta property="og:title" content="T9&#39;S Develop Blog">
<meta property="og:url" content="http://outofmemory.top/index.html">
<meta property="og:site_name" content="T9&#39;S Develop Blog">
<meta property="og:description" content="喜欢探索未知,保持好奇心">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="T9&#39;S Develop Blog">
<meta name="twitter:description" content="喜欢探索未知,保持好奇心">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="T9&#39;S Develop Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="https://s1.ax1x.com/2018/10/12/iNnhCV.gif">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>T9&#39;S Develop Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://s1.ax1x.com/2018/10/12/iNnhCV.gif" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">daidai</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不仅有工作，更有生活</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://daidazhao@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/dazhaoDai" title="GitHub"></a>
                            
                                <a class="fa CSDN" href="https://blog.csdn.net/dazhaoDai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android官方架构/">Android官方架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进阶/">Android进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git分支操作/">Git分支操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java进阶/">Java进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin学习/">Kotlin学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin开发/">Kotlin开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-aidl/">android aidl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-permission/">android permission</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-view/">android view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-开发错误/">android 开发错误</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-权限/">android 权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-自定义view/">android 自定义view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android触摸事件/">android触摸事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/privacy/">privacy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Developer</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">daidai</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://s1.ax1x.com/2018/10/12/iNnhCV.gif" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">daidai</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不仅有工作，更有生活</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://daidazhao@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/dazhaoDai" title="GitHub"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://blog.csdn.net/dazhaoDai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Android进阶 ——— Android 深入理解AIDL进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android进阶 ——— Android 深入理解AIDL进程间通信/" class="article-date">
      <time datetime="2018-08-24T07:23:07.051Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android进阶 ——— Android 深入理解AIDL进程间通信/">Android进阶 ——— Android 深入理解AIDL进程间通信</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>关于AIDL的资料，层出不穷，但是能让人简单明了理解的文章不多，那么我们就自己撸一遍，清晰明了的理解一下AIDL的原理。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在理解AIDL原理之前，先写一个简单的使用AIDL进行进程间通信的例子，根据这个例子来由浅及深的理解AIDL。</p>
<p>先来定义实体类：UserBean.java<br>注意：<strong>如果要在AIDL中使用实体类，实体类必须要实现序列化接口，这里实现的是Android自带的Parcelable接口</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.t9.news.Model;</div><div class="line"></div><div class="line">import android.os.Parcel;</div><div class="line">import android.os.Parcelable;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/5/11</div><div class="line"> * function:com.t9.news.Model</div><div class="line"> */</div><div class="line"></div><div class="line">public class UserBean implements Parcelable&#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private String name;</div><div class="line"></div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	protected UserBean(Parcel in) &#123;</div><div class="line">		age = in.readInt();</div><div class="line">		name = in.readString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">		dest.writeInt(age);</div><div class="line">		dest.writeString(name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public int describeContents() &#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static final Creator&lt;UserBean&gt; CREATOR = new Creator&lt;UserBean&gt;() &#123;</div><div class="line">		@Override</div><div class="line">		public UserBean createFromParcel(Parcel in) &#123;</div><div class="line">			return new UserBean(in);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public UserBean[] newArray(int size) &#123;</div><div class="line">			return new UserBean[size];</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明好了实体类，就需要额外在AIDL中声明实体类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// UserBean.aidl</div><div class="line">package com.t9.news.Model;</div><div class="line"></div><div class="line">parcelable UserBean;</div></pre></td></tr></table></figure></p>
<p>在AIDL 中使用实体类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// IMyAidlInterface.aidl</div><div class="line">package com.t9.news;</div><div class="line"></div><div class="line">// Declare any non-default types here with import statements</div><div class="line">import com.t9.news.Model.UserBean;</div><div class="line">interface IUser &#123;</div><div class="line"></div><div class="line">    List&lt;UserBean&gt; getUser();</div><div class="line"></div><div class="line">    void addUser(in UserBean user);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看一下项目的结构<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fw5j8ufq7xj20no0mo77l.jpg" alt=""></p>
<p>然后Build 一下 Project，结束之后就生成了Binder代码，来看看Binder代码生成的位置<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fw5j8ufs5uj20pq0jawh5.jpg" alt=""></p>
<p>这时候可以点开看一下这个类，十有八九会被吓到，先不去管它，稍后再来分析。</p>
<p>来声明一个Service：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">package com.t9.news;</div><div class="line"></div><div class="line">import android.app.Service;</div><div class="line">import android.content.Intent;</div><div class="line">import android.os.IBinder;</div><div class="line">import android.os.RemoteException;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">import com.t9.news.Model.UserBean;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/5/11</div><div class="line"> * function:com.t9.news</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyService extends Service &#123;</div><div class="line"></div><div class="line">	private String TAG = this.getClass().getName();</div><div class="line">	@Override</div><div class="line">	public void onCreate() &#123;</div><div class="line">		super.onCreate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	List&lt;UserBean&gt; list = new ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	private IBinder binder = new IUser.Stub() &#123;</div><div class="line">		@Override</div><div class="line">		public List&lt;UserBean&gt; getUser() throws RemoteException &#123;</div><div class="line">			if (list.size() &lt;= 0)&#123;</div><div class="line">				for(int i = 0; i &lt; 5; i++)&#123;</div><div class="line">					UserBean bean = new UserBean();</div><div class="line">					bean.setAge(5 * i);</div><div class="line">					bean.setName(&quot;android-&quot; + i);</div><div class="line">					list.add(bean);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			return list;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void addUser(UserBean user) throws RemoteException &#123;</div><div class="line">			Log.e(TAG, user.getName());</div><div class="line">			list.add(user);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	@Nullable</div><div class="line">	@Override</div><div class="line">	public IBinder onBind(Intent intent) &#123;</div><div class="line">		return binder;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义的Service比较简单。new 了一个 IUser.Stub()并把它向上转型成了IBinder，最后在onBind方法中返回回去。在 IUser.Stub()的内部我们重写getUser()、addUser(UserBean user)方法，这就是AIDL中声明的IUser接口中的两个方法。<br>既然是跨进程通信，那么将Service设置到另一个进程中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=&quot;com.t9.news.MyService&quot;</div><div class="line">    android:process=&quot;:newProcess&quot;</div><div class="line">    /&gt;</div></pre></td></tr></table></figure></p>
<p>定义为启动在新进程中，只需要在AndroidMainfest.xml中声明是加上一个process属性即可,不过这里有两个地方值得注意：<br>1.组件默认的进程名就是包名；<br>2.定义新的进程名的时候需要以包的形式(eg: com.xu.aidl)。</p>
<p>好，准备工作完成，在Activity中绑定Service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">package com.t9.News.HomePage.View.Activity</div><div class="line">import android.Manifest</div><div class="line">import android.content.ComponentName</div><div class="line">import android.content.Context</div><div class="line">import android.content.Intent</div><div class="line">import android.content.ServiceConnection</div><div class="line">import android.os.IBinder</div><div class="line">import android.os.RemoteException</div><div class="line">import android.util.Log</div><div class="line">import com.t9.news.Application</div><div class="line">import com.t9.news.R</div><div class="line">import com.t9.news.IUser</div><div class="line">import com.t9.news.Model.UserBean</div><div class="line">import com.t9.news.MyService</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 19:06</div><div class="line"> * function:com.t9.news.Main.View.Activity</div><div class="line"> */</div><div class="line">class MainActivity : BaseActivity() &#123;</div><div class="line"></div><div class="line">    private val TAG = this.javaClass.simpleName;</div><div class="line"></div><div class="line">    override fun getLayoutId(): Int &#123;</div><div class="line">        return R.layout.activity_main</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun initView() &#123;</div><div class="line">        initService()</div><div class="line">    &#125;</div><div class="line">    fun initService()&#123;</div><div class="line">        val service = Intent(this@MainActivity, MyService::class.java)</div><div class="line">        bindService(service, serviceConnection, Context.BIND_AUTO_CREATE)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private var iUser : IUser? = null</div><div class="line">    private val serviceConnection = object : ServiceConnection &#123;</div><div class="line">        override fun onServiceConnected(name: ComponentName, service: IBinder) &#123;</div><div class="line">            iUser = IUser.Stub.asInterface(service)</div><div class="line">            Log.e(TAG,&quot;连接Service成功&quot;)</div><div class="line">            try &#123;</div><div class="line">               val list : List&lt;UserBean&gt;  = iUser!!.user</div><div class="line">                for (user in list)&#123;</div><div class="line">                    Log.e(TAG, &quot;name = &quot; + user.name + &quot; age: = &quot; + user.age)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                val user:UserBean = UserBean();</div><div class="line">                user.name = &quot;张三&quot;</div><div class="line">                user.age = 111</div><div class="line">                iUser!!.addUser(user)</div><div class="line">            &#125; catch (e: RemoteException) &#123;</div><div class="line">                e.printStackTrace()</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        override fun onServiceDisconnected(name: ComponentName) &#123;</div><div class="line">            Log.e(TAG,&quot;连接Service断开&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于主要是Service和Activity间的通信，所以为了让代码整洁就没有写UI了。</p>
<p>在onCreate(Bundle savedInstanceState)中，我们调用了自己定义的一个方法initService()，这个方法里面我们生成了一个Intent，然后 bindService了这个Intent传入了三个参数分别是Intent、ServiceConnection、Flag。</p>
<p>Intent我们就不用说了，我们看看后面两个参数：<br>在Activity中，我们new了一个ServiceConnection并实现了他的两个方法onServiceConnected、onServiceDisconnected。在onServiceConnected中我们通过IUser.Stub.asInterface(service)把传来的IBinder转换成了我们定义的iUser。然后我们调用了getUser方法，传递了个字符串和获取从MyService传来的字符串，并且打印了Log。<br>然后又new 一个UserBean对象，传递给MyService。</p>
<p>然后，我们的编码就完成了，运行并观察Log:</p>
<ul>
<li><p>MainActivity 中 Log：<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fw5jaijka0j211806gq8a.jpg" alt=""></p>
</li>
<li><p>MyService中Log：<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fw5jahze2hj210407mdi3.jpg" alt=""></p>
</li>
</ul>
<p>根据运行结果，在这两个不同的进程中都得到了我们想要的结果，所以，一个用aidl实现的跨进程通信就这样完成了。</p>
<h4 id="AIDL的理解"><a href="#AIDL的理解" class="headerlink" title="AIDL的理解"></a>AIDL的理解</h4><p>回过头来，我们再来分析之前的 debug 目录下的 IUser.java 类</p>
<ul>
<li><strong>先来看MyService 中 Binder</strong></li>
</ul>
<p>还记得我们在MyService中利用new IUser.Stub()向上转型成了IBinder然后在onBind方法中返回的。那我们就看看IUser.Stub()吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static abstract class Stub extends android.os.Binder implements com.t9.news.IUser&#123;</div><div class="line">		......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Stub 是 IUser 中静态抽象类，继承了 Binder，并且 实现 IUser接口，这就说明我们定义IUser.Stub的时候为什么需要实现IUser中的方法了，也说明了为什么我们可以把IUser.Stub向上转型成IBinder了。</p>
<ul>
<li><strong>Activity中的IMyInterface </strong><br>在Activity中，通过ServiceConnection连接MyService并成功回调onServiceConnected中我们把传回来的IBinder通过IUser.Stub.asInterface(service)转换成为IUser，那就来看看这里是如何转换的吧:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//这个接口里 有一个静态的抽象类Stub(注意这个名字是固定的 永远都是Stub 不会是其他)</div><div class="line"> //并且这个Stub是Binder的子类，并且实现了IUser 这个接口</div><div class="line">public static abstract class Stub extends android.os.Binder implements com.t9.news.IUser&#123;</div><div class="line">	//这个东西就是唯一的binder标示 可以看到就是IUser的全路径名</div><div class="line">	private static final java.lang.String DESCRIPTOR = &quot;com.t9.news.IUser&quot;;</div><div class="line">	/** Construct the stub at attach it to the interface. */</div><div class="line">	/**</div><div class="line">	   * 这个就是Stub的构造方法，回顾一下 我们如果写好aidl文件以后 写的service里面 是怎么写的？</div><div class="line">       * private final IUser.Stub mBinder = new IUser.Stub() &#123;&#125;</div><div class="line">        * 我们都是这么写的 对吧~~所以想想我们的service里面的代码 就能辅助理解 这里的代码了</div><div class="line">        */</div><div class="line">	public Stub()</div><div class="line">	&#123;</div><div class="line">	this.attachInterface(this, DESCRIPTOR);</div><div class="line">	&#125;</div><div class="line">	 //这个方法 其实就做了一件事，如果是同一个进程，那么就返回Stub对象本身</div><div class="line">    //如果不是同一个进程，就返回Stub.Proxy这个代理对象了</div><div class="line">	public static com.t9.news.IUser asInterface(android.os.IBinder obj)&#123;</div><div class="line">		if ((obj==null)) &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">		//检查Binder是不是在当前进程</div><div class="line">		android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">		//如果是同1个进程，也就是说进程内通信的话 我们就返回括号内里的对象</div><div class="line">		if (((iin!=null)&amp;&amp;(iin instanceof com.t9.news.IUser))) &#123;</div><div class="line">			return ((com.t9.news.IUser)iin);</div><div class="line">		&#125;</div><div class="line">		 //如果不是同一进程，是2个进程之间相互通信，那我们就得返回这个Stub.Proxy 看上去叫Stub 代理的对象了</div><div class="line">		return new com.t9.news.IUser.Stub.Proxy(obj);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>首先，我们因该明白的是，传回来的IBinder就是我们在Service的onBind( )方法所return的IBinder，然后我们调用Stub中的静态方法asInterface并把返回来的IBinder当参数传进去。<br>在asInterface方法中，首先判断了传进来的IBinder是不是null，如果为null就返回一个null;接着就判断传进来的IBinder是不是就在当前进程里面，如果是的话就直接返回IUser，不是的话就返回IUser.Stub.Proxy(obj)。<br>这里我觉得需要明白的是：直接返回的IUser是实现了定义的接口方法getUser、AddUser的。因为在IUser.Stub中所实现的。当然如果是在同一进程中，那么我们调用IUser的方法时就是在本地调用方法，直接调用就可以了。</p>
<p>如果没在同一进程，就会返回IUser.Stub.Proxy(obj):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">//注意这里的Proxy 这个类名也是不变的，从前文我们知道 只有在多进程通信的情况下  才会返回这个代理的对象</div><div class="line">private static class Proxy implements com.t9.news.IUser&#123;</div><div class="line">	private android.os.IBinder mRemote;</div><div class="line">	Proxy(android.os.IBinder remote)&#123;</div><div class="line">		mRemote = remote;</div><div class="line">	&#125;</div><div class="line">	@Override public android.os.IBinder asBinder()&#123;</div><div class="line">		return mRemote;</div><div class="line">	&#125;</div><div class="line">	public java.lang.String getInterfaceDescriptor()&#123;</div><div class="line">		return DESCRIPTOR;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">   //这里我们一共有2个方法 一个getUser 一个addUser 我们就分析一个方法就可以了</div><div class="line">        //并且要知道 这2个方法运行在客户端！！！！！！！！！！！！！！！！</div><div class="line">         //首先就是创建了3个对象_data 输入对象，_reply输出对象，_result返回值对象</div><div class="line">         //然后把参数信息 写入到_data里，接着就调用了transact这个方法 来发送rpc请求，然后接着</div><div class="line">         //当前线程挂起， 服务端的onTransace方法才被调用，调用结束以后 当前线程继续执行，直到</div><div class="line">         //从_reply中取出rpc的返回结果 然后返回_reply的数据</div><div class="line"></div><div class="line">        //所以这里我们就要注意了，客户端发起调用远程请求时，当前客户端的线程就会被挂起了，</div><div class="line">        //所以如果一个远程方法 很耗时，我们客户端就一定不能在ui main线程里在发起这个rpc请求，不然就anr了。</div><div class="line">	@Override public java.util.List&lt;com.t9.news.Model.UserBean&gt; getUser() throws android.os.RemoteException&#123;</div><div class="line">		android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">		android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">		java.util.List&lt;com.t9.news.Model.UserBean&gt; _result;</div><div class="line">		try &#123;</div><div class="line">			_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">			//传送数据到服务端</div><div class="line">			mRemote.transact(Stub.TRANSACTION_getUser, _data, _reply, 0);</div><div class="line">			_reply.readException();</div><div class="line">			//接受从服务端传回的数据</div><div class="line">			_result = _reply.createTypedArrayList(com.t9.news.Model.UserBean.CREATOR);</div><div class="line">		&#125;</div><div class="line">		finally &#123;</div><div class="line">			_reply.recycle();</div><div class="line">			_data.recycle();</div><div class="line">		&#125;</div><div class="line">		return _result;</div><div class="line">	&#125;</div><div class="line">	@Override public void addUser(com.t9.news.Model.UserBean user) throws android.os.RemoteException&#123;</div><div class="line">		android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">		android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">		try &#123;</div><div class="line">			_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">			if ((user!=null)) &#123;</div><div class="line">			_data.writeInt(1);</div><div class="line">			user.writeToParcel(_data, 0);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			_data.writeInt(0);</div><div class="line">		&#125;</div><div class="line">			mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0);</div><div class="line">			_reply.readException();</div><div class="line">		&#125;</div><div class="line">		finally &#123;</div><div class="line">			_reply.recycle();</div><div class="line">			_data.recycle();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Proxy中，我们首先把Service连接成功返回的IBinder它的内部变量mRemote,这里在提一下，这里得IBinder还是是MyService中onBind所返回的。然后，当我们调用IMyInterface的方法的时候，其实就是调用的Proxy的方法了，这也是为什么这个类叫做Porxy的原因了。</p>
<p>当调用IUser.getUser() ，我们就看Proxy中的getInfor,先获取了两个Parcel对象 _data、_data，从变量名就可以看出，一个是传送数据的，另一个则是接受返回数据的。接着，向_data中写入了DESCRIPTOR(也就是这个类的全名)，再写入了方法参数。然后就到了最重要的一步了，</p>
<p>mRemote.transact(Stub.TRANSACTION_getInfor, _data, _reply, 0);<br>这里我们调用了IBinder的transact方法，来把数据传给远端的服务器。然后在我们远程的MyService中，里面的Stub中就会回调onTransact（）（因为你把数据传个远程的服务，远端的服务收到数据也就回调了）</p>
<p>注意：这里是在远程的服务里调用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> //只有在多进程通信的时候 才会调用这个方法 ，同一个进程是不会调用的。</div><div class="line"></div><div class="line">     //首先 我们要明白 这个方法 一般情况下 都是返回true的，也只有返回true的时候才有意义，如果返回false了 就代表这个方法执行失败，</div><div class="line">     //所以我们通常是用这个方法来做权限认证的，其实也很好理解，既然是多进程通信，那么我们服务端的进程当然不希望谁都能过来调用</div><div class="line">     //所以权限认证是必须的，关于权限认证的代码 以后我再讲 先略过。</div><div class="line"> </div><div class="line">     //除此之外 ，onTransact 这个方法 就是运行在Binder线程池中的，一般就是客户端发起请求，然后android底层代码把这个客户端发起的</div><div class="line">     //请求 封装成3个参数 来调用这个onTransact方法，第一个参数code 就代表客户端想要调用服务端 方法的 标志位。</div><div class="line">     //其实也很好理解 服务端可能有n个方法 每个方法 都有一个对应的int值来代表，这个code就是这个int值，用来标示客户端想调用的服务端的方法</div><div class="line">     //data就是方法参数，reply就是方法返回值。都很好理解</div><div class="line"> </div><div class="line">     //其实隐藏了很重要的一点，这个方法既然是运行在binder线程池中的，所以在这个方法里面调用的服务器方法也是运行在Binder线程池中的，</div><div class="line">     //所以我们要记得 如果你的服务端程序 有可能和多个客户端相联的话，你方法里使用的那些参数 必须要是支持异步的，否则的话</div><div class="line">     //值就会错乱了！这点一定要记住！结论就是Binder方法 一定要是同步方法！！！！！！</div><div class="line">@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;</div><div class="line">	switch (code)&#123;</div><div class="line">		case INTERFACE_TRANSACTION:&#123;</div><div class="line">			reply.writeString(DESCRIPTOR);</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">		case TRANSACTION_getUser:&#123;</div><div class="line">			data.enforceInterface(DESCRIPTOR);</div><div class="line">			// 远程服务调用自己本地实现的方法获取返回值</div><div class="line">			java.util.List&lt;com.t9.news.Model.UserBean&gt; _result = this.getUser();</div><div class="line">			reply.writeNoException();</div><div class="line">			//写入返回值</div><div class="line">			reply.writeTypedList(_result);</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">		case TRANSACTION_addUser:&#123;</div><div class="line">			data.enforceInterface(DESCRIPTOR);</div><div class="line">			com.t9.news.Model.UserBean _arg0;</div><div class="line">			if ((0!=data.readInt())) &#123;</div><div class="line">				_arg0 = com.t9.news.Model.UserBean.CREATOR.createFromParcel(data);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				_arg0 = null;</div><div class="line">			&#125;</div><div class="line">			this.addUser(_arg0);</div><div class="line">			reply.writeNoException();</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return super.onTransact(code, data, reply, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>nTransact方法是在Stub的内部实现的。</p>
<p>先看一下它的四个参数： </p>
<ul>
<li>code：每个方法都有一个int类型的数字用来区分（后面中的swicth），在我们例子中也就是我们Proxy中的Stub.TRANSACTION_geIUser。 </li>
<li>data:传过来的数据，其中包含我们的参数，以及类的描述。 </li>
<li>reply:传回的数据，我们要写入是否发生了Exception,以及返回值 </li>
<li>flags:该方法是否有返回值 ，0表示有返回值。</li>
</ul>
<p>调用onTransact就表示有数据传来，首先就会通过swicth判断是哪个方法，然后取出方法参数，调用本地实现的方法获取返回值，写入返回值到reply。最后，返回true，才会把数据发送出去，发挥false就不会把结果返回给Activity了。这里也就是说，只有返回true,我们Proxy中才能接受从远端传回的数据。</p>
<p>注意：Service也是把数据发送出来，让客户端接受的。</p>
<p>Service发出了数据，客户端接收到了，就会一层一层返回去。所以，当我们简单的调用IUser的getUser时候，先是Proxy的transact发送出数据，然后服务端的onTransact接受并处理传来的数据，再把处理得到的数据写入返回值并发送给客户端，客户端读取值后就成为调用方法的返回值返回了。</p>
<p>到这里 相信大家 至少在应用层上面，就对Binder就一个很直观的理解了，对于进程间通信来说，具体的流程就分为如下几步：</p>
<ul>
<li><p>1.Client 发起远程调用请求 也就是RPC 到Binder。同时将自己挂起，挂起的原因是要等待RPC调用结束以后返回的结果</p>
</li>
<li><p>2.Binder 收到RPC请求以后 把参数收集一下，调用transact方法，把RPC请求转发给service端。</p>
</li>
<li><p>3.service端 收到rpc请求以后 就去线程池里 找一个空闲的线程去走service端的 onTransact方法 ，实际上也就是真正在运行service端的 方法了，等方法运行结束 就把结果 写回到binder中。</p>
</li>
<li><p>4.Binder 收到返回数据以后 就唤醒原来的Client 线程，返回结果。至此，一次进程间通信 的过程就结束了</p>
</li>
</ul>
<p>关于AIDL的基本原理就是这样了，看明白了AIDL，才发现原来AIDL不过就是帮我们生成了那些数据写入，传送，读取的方法而已。</p>
<hr>
<p>参考<br><a href="https://www.cnblogs.com/punkisnotdead/p/5163464.html" target="_blank" rel="external">https://www.cnblogs.com/punkisnotdead/p/5163464.html</a><br><a href="https://blog.csdn.net/u011974987/article/details/51243539" target="_blank" rel="external">https://blog.csdn.net/u011974987/article/details/51243539</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android 进阶  ------ Android 单元测试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android 进阶  ------ Android 单元测试/" class="article-date">
      <time datetime="2018-08-24T07:22:56.164Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android 进阶  ------ Android 单元测试/">Android 进阶  ------ Android 单元测试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h5 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h5><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。比如我们可以测试一个类，或者一个类中的一个方法。</p>
<h5 id="为什么要进行单元测试？"><a href="#为什么要进行单元测试？" class="headerlink" title="为什么要进行单元测试？"></a>为什么要进行单元测试？</h5><p>为什么要进行单元测试？说白了就是单元测试有什么好处，其实测试的好处无非就是减少bug、提高代码质量、使代码易于维护等。</p>
<p>这样表达可能不太好理解，举个例子</p>
<p>比如我们APP启动，从初始化到启动页，再进入首页，需要很长的流程，如果主页需要请求数据，每次都要启动APP，经过一系列流程进入主页，才能测试主页请求数据模块，效率低下。<br>当然我们也能在初始化时请求数据，但是这样需要更改代码逻辑，同样需要启动APP，而如果用单元测试，我们可以直接测试请求数据模块，不需要任何逻辑修改。提高效率</p>
<h5 id="开始进行单元测试"><a href="#开始进行单元测试" class="headerlink" title="开始进行单元测试"></a>开始进行单元测试</h5><p>AS创建工程时，src下创建 androidTest 和 test 目录，这两个目录有什么区别呢？</p>
<table>
<thead>
<tr>
<th>src/test</th>
<th>src/androidTest</th>
</tr>
</thead>
<tbody>
<tr>
<td>位于src/tests目录下的测试是运行在本地电脑Java虚拟机上的单元测试。编写测试，实现功能使测试通过，然后再添加更多的测试…这种工作方式使快速迭代成为可能，我们称之为测试驱动开发</td>
<td>跟src/test不同的是运行在设备上，并充分利用Android框架的测试</td>
</tr>
</tbody>
</table>
<blockquote>
<p>简单来说，src/test不需要你连接设备，而src/androidTest需要连接设备测试。</p>
</blockquote>
<h5 id="一、先说一下src-tests"><a href="#一、先说一下src-tests" class="headerlink" title="一、先说一下src/tests"></a>一、先说一下src/tests</h5><p>首先确认app下gradle中存在依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    testCompile &apos;junit:junit:4.12&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有个 快速排序的类，对一个数组进行快速排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class FastSort &#123;</div><div class="line"></div><div class="line">	public  void main()&#123;</div><div class="line">		int[] a = new int[]&#123;5,10,34,2,45,38,23,70,1,32,20,17,4,80,14,100&#125;;</div><div class="line">		quick_sort(a,0,a.length - 1);</div><div class="line">		for (int i : a) &#123;</div><div class="line">			System.out.println(i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	 void quick_sort(int a[],int l,int r)&#123;</div><div class="line">		if (l &lt; r)&#123;</div><div class="line">			int i = adjustArray(a,l,r);</div><div class="line">			quick_sort(a,l,i-1);</div><div class="line">			quick_sort(a,i+1,r);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private  int adjustArray(int a[],int l,int r)&#123;</div><div class="line">		int i = l,j = r,x = a[i];</div><div class="line">		while (i &lt; j)&#123;</div><div class="line"></div><div class="line">			while (i &lt; j &amp;&amp; a[j] &gt;= x)&#123;   //如果 a[j] &gt; x ，不用管，j-1,倒着比较下一个</div><div class="line">				j--;</div><div class="line">			&#125;</div><div class="line">			if (i &lt; j)&#123;  // a[j] &lt; x 跳出while循环</div><div class="line">				a[i] = a[j];    //将a[j]的值赋给a[i]被挖出的位置，默认是数组都一个</div><div class="line">				i++;   //i++,为后面i开始自增，提前增加</div><div class="line">			&#125;</div><div class="line"></div><div class="line"></div><div class="line">			while (i &lt; j &amp;&amp; a[i] &lt; x)&#123; //如果 a[i] &lt;  x ，不用管，x+1,比较下一个</div><div class="line">				i++;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			if (i &lt; j)&#123;  // a[i] &gt; x 跳出while循环</div><div class="line">				a[j] = a[i];   //将a[i]的值赋给上面a[j]被挖出的位置</div><div class="line">				j--;   //j--,为后面j继续自减，提前减少</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		a[i] = x;</div><div class="line">		return i;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然工具类写好了，当然要测试一下排序方法对不对了，这时候直接用单元测试来检验一下。</p>
<ul>
<li>AS为我们提供了创建测试类的快捷方法：</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/10/12/iNpzwD.png" alt="这里写图片描述"></p>
<ul>
<li><p>右键 –&gt;  Go To –&gt; Test<br><img src="https://s1.ax1x.com/2018/10/12/iN9CYd.png" alt="这里写图片描述"></p>
</li>
<li><p>勾选上所有方法，点击 OK，一路点击OK，完成测试类创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class FastSortTest extends TestCase &#123;</div><div class="line">	public void setUp() throws Exception &#123;</div><div class="line">		super.setUp();</div><div class="line">	&#125;</div><div class="line">	public void tearDown() throws Exception &#123;</div><div class="line">	&#125;</div><div class="line">	public void testMain() throws Exception &#123;</div><div class="line">	&#125;</div><div class="line">	public void testQuick_sort() throws Exception &#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>setUp：在测试开始之前回调的方法（ 比如说初始化我们的类）。<br>tearDown()：测试结束的回调方法。 </p>
</blockquote>
<ul>
<li>来添加测试代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class FastSortTest extends TestCase &#123;</div><div class="line"></div><div class="line">	private FastSort sort;</div><div class="line">	public void setUp() throws Exception &#123;</div><div class="line">		super.setUp();</div><div class="line">		sort = new FastSort();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void tearDown() throws Exception &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void testMain() throws Exception &#123;</div><div class="line">		sort.main();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void testQuick_sort() throws Exception &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>sort.main()方法，检测快速排序方法的正确性</p>
<ul>
<li>开始测试<br>右键点击FastSortTest类 —&gt; ‘Run FastSortTest’，也可以通过命令行运行测试，在工程目录内输入：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew test</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/10/12/iN9PfA.md.png" alt="这里写图片描述"></p>
<p>测试结束，可以看到，sortMain()方法通过测试<br><img src="https://s1.ax1x.com/2018/10/12/iN99FH.md.png" alt="这里写图片描述"></p>
<p>成功完成了 src/test  单元测试，</p>
<hr>
<p>这里简单介绍了 src/test 测试，关于其他用法，大家可以去深入研究一下</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Flutter初体验（二）---- 创建第一个Flutter APP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Flutter初体验（二）---- 创建第一个Flutter APP/" class="article-date">
      <time datetime="2018-08-24T07:22:24.197Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Flutter初体验（二）---- 创建第一个Flutter APP/">Flutter初体验（二）---- 创建第一个Flutter APP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在第一篇文章<a href="http://blog.csdn.net/dazhaodai/article/details/79526401" target="_blank" rel="external"> Flutter初体验（一）—Mac 安装配置</a>，学习了配置 Flutter 开发环境，并运行了Demo项目，本篇根据官方教程，学习创建自己的第一个Flutter APP。</p>
<hr>
<pre><code>参考文档 https://flutter.io/get-started/codelab/
</code></pre><hr>
<h4 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h4><p>您将实施一个简单的移动应用程序，为一家创业公司生成建议名称。用户可以选择和取消选择名称，保存最好的名称。该代码一次生成十个名称。当用户滚动时，会生成新批次的名称。用户可以点击应用栏右上方的列表图标以移动到仅列出收藏名称的新路线</p>
<ul>
<li><p>下面的GIF动画显示我们将要完成应用程序    </p>
<p><img src="https://flutter.io/get-started/codelab/images/startup-namer-app.gif" alt=""></p>
</li>
</ul>
<h5 id="学习成果："><a href="#学习成果：" class="headerlink" title="学习成果："></a>学习成果：</h5><ul>
<li>Flutter应用程序的基本结构</li>
<li>学习查找和使用包来扩展功能</li>
<li>使用热重载加快开发周期</li>
<li>如何实现状态化组件</li>
<li>如何创建一个无限的，延迟加载的列表</li>
<li>如何创建并导航到第二个屏幕</li>
<li>如何使用主题更改应用程序的外观</li>
</ul>
<h3 id="第1步-：创建一个运行的Flutter-应用程序"><a href="#第1步-：创建一个运行的Flutter-应用程序" class="headerlink" title="第1步 ：创建一个运行的Flutter 应用程序"></a>第1步 ：创建一个运行的Flutter 应用程序</h3><p>在第一篇文章中已经讲述了如何配置Flutter开发环境，并且创建一个示例Flutter项目,现在将会修改这个示例程序来完成我们的项目。</p>
<p>本次操作，主要编辑Dart代码中的<strong>lib/main.dart</strong>。</p>
<blockquote>
<p><strong>提示</strong>: 将代码粘贴到您的应用中时，缩进可能会变形。您可以使用Flutter工具自动修复此问题</p>
<ul>
<li>Android Studio / IntelliJ IDEA：右键单击Dart代码，然后选择使用dartfmt重新格式化代码。</li>
<li>VS代码：右键单击并选择格式化文档</li>
<li>Terminal: 运行 flutter format <filename></filename></li>
</ul>
</blockquote>
<p>1.替换 lib/main.dart.<br>  删除lib / main.dart中的所有代码。替换为下面的代码，它在屏幕的中心显示“Hello World”<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">  import &apos;package:flutter/material.dart&apos;;</div><div class="line"></div><div class="line">void main() =&gt; runApp(new MyApp());</div><div class="line"></div><div class="line">class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    return new MaterialApp(</div><div class="line">      title: &apos;Welcome to Flutter&apos;,</div><div class="line">      home: new Scaffold(</div><div class="line">        appBar: new AppBar(</div><div class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</div><div class="line">        ),</div><div class="line">        body: new Center(</div><div class="line">          child: new Text(&apos;Hello World&apos;),</div><div class="line">        ),</div><div class="line">      ),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.运行工程，将会看到下面的屏幕截图</p>
<p><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1fpkpgk43ycj31401z4wfx.jpg" alt=""></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>本示例创建一个Material应用程序。 Material是一种在移动设备和web端是统一标准的视觉设计语言。 Flutter提供了一套丰富的Material小部件</li>
<li>主要方法指定箭头（=&gt;）表示法，它是用于单行函数或方法的简写</li>
<li>该应用程序扩展了使应用程序本身成为小部件的StatelessWidget。在Flutter中，几乎所有东西都是一个小部件，包括对齐，填充和布局</li>
<li>小部件的主要工作是提供一个build（）方法，该方法描述如何根据其他较低级别的小部件显示小部件</li>
<li><p>此示例的小部件树由包含Text小部件的中心小部件组成。中心小部件将其小部件子树对齐到屏幕中心</p>
<hr>
<h3 id="第2步：使用外部包"><a href="#第2步：使用外部包" class="headerlink" title="第2步：使用外部包"></a>第2步：使用外部包</h3><p>在这一步中，您将开始使用名为<strong>english_words</strong>的开源软件包，其中包含数千个最常用的英文单词以及一些实用功能<br> 1.pubspec文件管理Flutter应用程序的资源。在<strong>pubspec.yaml</strong>中，将<strong>english_words</strong>（3.1.0或更高版本）添加到依赖项列表。新行强调如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies:</div><div class="line">flutter:</div><div class="line">  sdk: flutter</div><div class="line"></div><div class="line">cupertino_icons: ^0.1.0</div><div class="line">english_words: ^3.1.0</div></pre></td></tr></table></figure>
<p> 2.在Android Studio的编辑器视图，单击右上角<strong>Packages get</strong>。将该包引入您的项目。将会在控制台中看到以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">flutter packages get</div><div class="line">Running &quot;flutter packages get&quot; in flutter_app...</div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<p> 3.在<strong>lib / main.dart</strong>中，将<strong>english_words</strong>导入,如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &apos;package:flutter/material.dart&apos;;</div><div class="line">import &apos;package:english_words/english_words.dart&apos;;</div></pre></td></tr></table></figure>
<p>在输入过程中，Android Studio会为您提供有关库导入的建议。然后它将呈现灰色的导入字符串，让您知道导入的库未使用（到目前为止）</p>
<p>4.使用English words 包来生成文本取代字符串“Hello World”<br>   进行以下更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import &apos;package:flutter/material.dart&apos;;</div><div class="line">import &apos;package:english_words/english_words.dart&apos;;</div><div class="line"></div><div class="line">void main() =&gt; runApp(new MyApp());</div><div class="line"></div><div class="line">class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line"> Widget build(BuildContext context) &#123;</div><div class="line">   final wordPair = new WordPair.random();</div><div class="line">   return new MaterialApp(</div><div class="line">      title: &apos;Welcome to Flutter&apos;,</div><div class="line">     home: new Scaffold(</div><div class="line">       appBar: new AppBar(</div><div class="line">         title: new Text(&apos;Welcome to Flutter&apos;),</div><div class="line">        ),</div><div class="line">       body: new Center(</div><div class="line">         //child: new Text(&apos;Hello World&apos;), // Replace the   highlighted text...</div><div class="line">         child: new Text(wordPair.asPascalCase),  // With this  highlighted text.</div><div class="line">        ),</div><div class="line">      ),</div><div class="line">    );</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.如果应用程序正在运行，使用热重载按钮（⚡️）更新正在运行的应用程序，每次点击热重载或者保存项目时，都会在正在运行的应用程序中随机显示一个不同的单词，这是单词配对是在构建方法内部生成的，每次MaterialApp需要渲染时都会运行它，或在检查器中切换平台时。<br><img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fpkpf7fzrvj30mz14uq49.jpg" alt=""></p>
<hr>
<h3 id="第3步：添加一个有状态的组件"><a href="#第3步：添加一个有状态的组件" class="headerlink" title="第3步：添加一个有状态的组件"></a>第3步：添加一个有状态的组件</h3></li>
</ul>
<p>无状态组件是不可变的，意味着他们的属性不能被改变–所有的值都是最终值</p>
<p>有状态的小部件保持在小部件的生命周期中可能改变的状态，实现一个有状态的小部件至少需要两个类：1）一个StatefulWidget类，它创建一个取代 2）一个State类的实例。 StatefulWidget类本身是不可变的，但State类在整个构件的生命周期中保持不变</p>
<p>在这一步中，您将添加一个有状态的小部件RandomWords，它创建其状态类RandomWordsState<br>   1.将有状态的RandomWords小部件添加到main.dart，它可以在MyApp之外的文件中的任何位置使用，但解决方案将它放在文件的底部。 RandomWords小部件除了创建其状态类之外无其他作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class RandomWords extends StatefulWidget &#123;</div><div class="line">  @override</div><div class="line">  createState() =&gt; new RandomWordsState();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   2.添加RandomWordsState类。该应用程序的大部分代码都驻留在该类中，该类保持RandomWords小部件的状态,这个类将保存随着用户滚动而无限增长的生成的单词对，以及最喜欢的单词对，因为用户通过切换红心图标来将它们从列表中添加或删除。</p>
<p>   你会一点一点地建立这个类。首先，通过添加突出显示的文本创建一个最小类：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   3.在添加状态类后，IDE会抱怨该类缺少构建方法,接下来，您将添加一个基本构建方法，该方法通过将单词生成代码从MyApp移动到RandomWordsState来生成单词对</p>
<p>  将构建方法添加到RandomWordState中，如突出显示的文本所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    final wordPair = new WordPair.random();</div><div class="line">    return new Text(wordPair.asPascalCase);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  4.通过下面突出显示的更改从MyApp中删除单词生成代码：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">  </div><div class="line">    return new MaterialApp(</div><div class="line">      title: &apos;Welcome to Flutter&apos;,</div><div class="line">      home: new Scaffold(</div><div class="line">        appBar: new AppBar(</div><div class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</div><div class="line">        ),</div><div class="line">        body: new Center(</div><div class="line">          //child: new Text(wordPair.asPascalCase), // Change the highlighted text to...</div><div class="line">          child: new RandomWords(), // ... this highlighted text</div><div class="line">        ),</div><div class="line">      ),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  重新启动应用程序。如果您尝试重新加载热点，则可能会看到警告：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  Reloading...</div><div class="line">Not all changed program elements ran during view reassembly; consider</div><div class="line">restarting.</div></pre></td></tr></table></figure></p>
<p>  这可能是误报，但考虑重新启动以确保您的更改反映在应用的用户界面中。</p>
<p>  应用程序应该像以前一样运行，每次热重新加载或保存应用程序时都会显示一个字对。</p>
<p>  <img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fpkpenbynrj30mz14uabd.jpg" alt=""></p>
<hr>
<h3 id="第4步：创建一个无限的滚动ListView"><a href="#第4步：创建一个无限的滚动ListView" class="headerlink" title="第4步：创建一个无限的滚动ListView"></a>第4步：创建一个无限的滚动ListView</h3><p>在这一步中，您将展开RandomWordsState以生成并显示单词配对列表。当用户滚动时，ListView小部件中显示的列表将无限增长。 ListView的构建器工厂构造函数允许您根据需要懒惰地构建列表视图。</p>
<p>  1.将一个<code>_suggestions</code>列表添加到RandomWordsState类以保存建议的词对。该变量以下划线（_）开头 - 在下划线前加上一个带有下划线的标识符可以强化Dart语言的隐私。</p>
<p>  另外，添加一个largerFont变量来使字体变大。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  final _suggestions = &lt;WordPair&gt;[];</div><div class="line">  </div><div class="line">  final _biggerFont = const TextStyle(fontSize: 18.0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  2.将一个<code>_buildSuggestions（）</code>函数添加到RandomWordsState类。此方法构建显示建议词对的ListView。</p>
<p>ListView类提供了一个构建器属性itemBuilder，一个指定为匿名函数的工厂构建器和回调函数,两个参数传递给函数 - BuildContext和行迭代器.迭代器从0开始，每次调用该函数时递增，每次建议的单词配对一次.该模型允许建议的列表在用户滚动时无限增长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  Widget _buildSuggestions() &#123;</div><div class="line">    return new ListView.builder(</div><div class="line">      padding: const EdgeInsets.all(16.0),</div><div class="line">      // The itemBuilder callback is called once per suggested word pairing,</div><div class="line">      // and places each suggestion into a ListTile row.</div><div class="line">      // For even rows, the function adds a ListTile row for the word pairing.</div><div class="line">      // For odd rows, the function adds a Divider widget to visually</div><div class="line">      // separate the entries. Note that the divider may be difficult</div><div class="line">      // to see on smaller devices.</div><div class="line">      itemBuilder: (context, i) &#123;</div><div class="line">        // Add a one-pixel-high divider widget before each row in theListView.</div><div class="line">        if (i.isOdd) return new Divider();</div><div class="line"></div><div class="line">        // The syntax &quot;i ~/ 2&quot; divides i by 2 and returns an integer result.</div><div class="line">        // For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2.</div><div class="line">        // This calculates the actual number of word pairings in the ListView,</div><div class="line">        // minus the divider widgets.</div><div class="line">        final index = i ~/ 2;</div><div class="line">        // If you&apos;ve reached the end of the available word pairings...</div><div class="line">        if (index &gt;= _suggestions.length) &#123;</div><div class="line">          // ...then generate 10 more and add them to the suggestions list.</div><div class="line">          _suggestions.addAll(generateWordPairs().take(10));</div><div class="line">        &#125;</div><div class="line">        return _buildRow(_suggestions[index]);</div><div class="line">      &#125;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.<code>_buildSuggestions</code>函数每个字对调用<code>_buildRow</code>一次。这个函数在ListTile中显示每个新对，这允许您在下一步中使行更具吸引力</p>
<p>向<code>RandomWordsState</code>添加<code>_buildRow</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  Widget _buildRow(WordPair pair) &#123;</div><div class="line">    return new ListTile(</div><div class="line">      title: new Text(</div><div class="line">        pair.asPascalCase,</div><div class="line">        style: _biggerFont,</div><div class="line">      ),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.更新RandomWordsState的构建方法以使用_buildSuggestions（），而不是直接调用单词生成库。进行突出显示的更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line"></div><div class="line">    //final wordPair = new WordPair.random(); // Delete these two lines.</div><div class="line">    //return new Text(wordPair.asPascalCase);</div><div class="line">    </div><div class="line">    return new Scaffold (</div><div class="line">      appBar: new AppBar(</div><div class="line">        title: new Text(&apos;Startup Name Generator&apos;),</div><div class="line">      ),</div><div class="line">      body: _buildSuggestions(),  </div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.更新MyApp的构建方法。从MyApp中删除Scaffold和AppBar实例。这些将由RandomWordsState管理，当用户在下一步中从一个屏幕导航到另一个屏幕时，可以更轻松地更改应用栏中的路由名称。</p>
<p>用下面突出显示的构建方法替换原始方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    return new MaterialApp(</div><div class="line">      title: &apos;Startup Name Generator&apos;,</div><div class="line">      home: new RandomWords(),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新启动应用程序。你应该看到一个单词配对清单。尽可能向下滚动，您将继续看到新的单词配对。</p>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fpkpe6jufgj30mz14udi6.jpg" alt=""></p>
<hr>
<h3 id="第5步：添加交互性"><a href="#第5步：添加交互性" class="headerlink" title="第5步：添加交互性"></a>第5步：添加交互性</h3><p>在这一步中，您将为每一行添加可点击的心形图标。当用户点击列表中的条目，切换其“收藏”状态时，该单词配对被添加到一组保存的收藏夹中或从中删除</p>
<p>1.将一个<code>_saved</code>集合添加到RandomWordsState。这个集合存储用户最喜欢的单词配对。 Set比List更受欢迎，因为正确实施的Set不允许重复输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  final _suggestions = &lt;WordPair&gt;[];</div><div class="line"></div><div class="line">  final _saved = new Set&lt;WordPair&gt;();  //添加 saved 集合</div><div class="line"></div><div class="line">  final _biggerFont = const TextStyle(fontSize: 18.0);</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.在<code>_buildRow</code>函数中，添加<code>alreadySaved</code>检查以确保单词配对尚未添加到收藏夹.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Widget _buildRow(WordPair pair) &#123;</div><div class="line">  final alreadySaved = _saved.contains(pair);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.同样在_buildRow（）中，将心形图标添加到ListTiles以启用收藏。稍后，您将添加与心形图标进行交互的功能。</p>
<p>添加下面突出显示的行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Widget _buildRow(WordPair pair) &#123;</div><div class="line">  final alreadySaved = _saved.contains(pair);</div><div class="line">  return new ListTile(</div><div class="line">    title: new Text(</div><div class="line">      pair.asPascalCase,</div><div class="line">      style: _biggerFont,</div><div class="line">    ),</div><div class="line">    //添加心形图标以添加收藏功能</div><div class="line">    trailing: new Icon(</div><div class="line">      alreadySaved ? Icons.favorite : Icons.favorite_border,</div><div class="line">      color: alreadySaved ? Colors.red : null,</div><div class="line">    ),</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.重新启动应用程序。你现在应该在每一行看到开放的心，但它们还没有互动。</p>
<p>5.在<code>_buildRow</code>函数中让心形图标可点击。如果单词条目已经添加到收藏夹中，再次点击它将其从收藏夹中删除。当心形图标被轻敲时，函数调用setState（）来通知框架状态已经改变。</p>
<p>添加下列代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Widget _buildRow(WordPair pair) &#123;</div><div class="line">  final alreadySaved = _saved.contains(pair);</div><div class="line">  return new ListTile(</div><div class="line">    title: new Text(</div><div class="line">      pair.asPascalCase,</div><div class="line">      style: _biggerFont,</div><div class="line">    ),</div><div class="line">    trailing: new Icon(</div><div class="line">      alreadySaved ? Icons.favorite : Icons.favorite_border,</div><div class="line">      color: alreadySaved ? Colors.red : null,</div><div class="line">    ),</div><div class="line">    //修改心形图标的状态</div><div class="line">    onTap: () &#123;</div><div class="line">      setState(() &#123;</div><div class="line">        if (alreadySaved) &#123;</div><div class="line">          _saved.remove(pair);</div><div class="line">        &#125; else &#123;</div><div class="line">          _saved.add(pair);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;,</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>热重载应用程序。你应该能够点击任何一行以获得最喜欢的，或不适合的条目。注意，点击一行会生成从心形图标散发的涟漪动画。</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fpkpdim8dhj30mz14uju1.jpg" alt=""></p>
<hr>
<h3 id="第6步：导航到新的屏幕"><a href="#第6步：导航到新的屏幕" class="headerlink" title="第6步：导航到新的屏幕"></a>第6步：导航到新的屏幕</h3><p>在这一步中，您将添加一个显示收藏夹的新屏幕（在Flutter中称为路线）。您将学习如何在主路线和新路线之间导航。</p>
<p>在Flutter中，导航器管理包含应用程序路线的堆栈。将路线推入导航器的堆栈，将显示更新为该推入的路线。从导航器的堆栈中弹出路径，将显示返回到上一个路线。</p>
<p>1.向RandomWordsState的构建方法中的AppBar添加列表图标。当用户点击列表图标时，包含收藏夹项目的新路线被推送到导航器，显示该图标。</p>
<blockquote>
<p>提示：某些小部件属性采用单个小部件（子级），而其他属性（如操作）则采用小部件（子级）数组，如方括号（[]）所示。</p>
<p>将该图标及其相应的操作添加到构建方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    return new Scaffold(</div><div class="line">      appBar: new AppBar(</div><div class="line">        title: new Text(&apos;Startup Name Generator&apos;),</div><div class="line">        //添加actions</div><div class="line">        actions: &lt;Widget&gt;[</div><div class="line">          new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved),</div><div class="line">        ],</div><div class="line">      ),</div><div class="line">      body: _buildSuggestions(),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>2.将一个<code>_pushSaved（）</code>函数添加到RandomWordsState类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  void _pushSaved() &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>热重新加载应用程序。列表图标出现在应用程序栏中。点击它什么也没做，因为<code>_pushSaved</code>函数是空的。</p>
<p>3.当用户点击应用栏中的列表图标时，建立一条路线并将其推送到导航器的堆栈。此操作会更改屏幕以显示新路线。</p>
<p>新页面的内容是使用匿名函数在MaterialPageRoute的构建器属性中构建的。</p>
<p>将呼叫添加到Navigator.push，如突出显示的代码所示，将路线推送到导航器的堆栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void _pushSaved() &#123;</div><div class="line">  Navigator.of(context).push(</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.添加MaterialPageRoute及其构建器。现在，添加生成ListTile行的代码。ListTile<code>的divideTiles（）</code>方法在每个ListTile之间添加水平间距。<code>divided</code>的变量保存最后的行，通过便利函数toList（）转换为列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void _pushSaved() &#123;</div><div class="line">  Navigator.of(context).push(</div><div class="line">    new MaterialPageRoute(</div><div class="line">      builder: (context) &#123;</div><div class="line">        final tiles = _saved.map(</div><div class="line">          (pair) &#123;</div><div class="line">            return new ListTile(</div><div class="line">              title: new Text(</div><div class="line">                pair.asPascalCase,</div><div class="line">                style: _biggerFont,</div><div class="line">              ),</div><div class="line">            );</div><div class="line">          &#125;,</div><div class="line">        );</div><div class="line">        final divided = ListTile</div><div class="line">          .divideTiles(</div><div class="line">            context: context,</div><div class="line">            tiles: tiles,</div><div class="line">          )</div><div class="line">          .toList();</div><div class="line">      &#125;,</div><div class="line">    ),</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.构建器属性返回一个Scaffold，其中包含名为“Saved Suggestions”的新路线的应用程序栏。新路由的主体由包含ListTiles行的ListView组成;每行由一个分隔符分隔。</p>
<p>添加下面突出显示的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">void _pushSaved() &#123;</div><div class="line">  Navigator.of(context).push(</div><div class="line">    new MaterialPageRoute(</div><div class="line">      builder: (context) &#123;</div><div class="line">        final tiles = _saved.map(</div><div class="line">          (pair) &#123;</div><div class="line">            return new ListTile(</div><div class="line">              title: new Text(</div><div class="line">                pair.asPascalCase,</div><div class="line">                style: _biggerFont,</div><div class="line">              ),</div><div class="line">            );</div><div class="line">          &#125;,</div><div class="line">        );</div><div class="line">        final divided = ListTile</div><div class="line">          .divideTiles(</div><div class="line">            context: context,</div><div class="line">            tiles: tiles,</div><div class="line">          )</div><div class="line">          .toList();</div><div class="line"></div><div class="line">        //添加 Scaffold 名为 Saved Suggestions</div><div class="line">      </div><div class="line">        return new Scaffold(</div><div class="line">          appBar: new AppBar(</div><div class="line">            title: new Text(&apos;Saved Suggestions&apos;),</div><div class="line">          ),</div><div class="line">          body: new ListView(children: divided),</div><div class="line">        );</div><div class="line">      &#125;,</div><div class="line">    ),</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.热重载应用程序。最喜欢的一些选择，并点击应用栏中的列表图标。新路线显示包含收藏夹。请注意，导航器会在应用栏中添加一个“返回”按钮。你不必显式实现Navigator.pop。点击后退按钮返回到主页路线。</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fpkpbfidmoj30mz14u766.jpg" alt=""></p>
<hr>
<h3 id="第7步：使用主题更改UI"><a href="#第7步：使用主题更改UI" class="headerlink" title="第7步：使用主题更改UI"></a>第7步：使用主题更改UI</h3><p>在最后一步中，您将使用该应用的主题,主题控制你的应用的外观和感觉。您可以使用默认主题，该主题取决于物理设备或模拟器，也可以自定义主题以反映您的品牌。</p>
<p>1.您可以通过配置ThemeData类轻松更改应用程序的主题。您的应用程序目前使用默认主题，但您将更改主要颜色为白色。</p>
<p>将突出显示的代码添加到MyApp，将应用程序的主题更改为蓝色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    return new MaterialApp(</div><div class="line">      title: &apos;Startup Name Generator&apos;,</div><div class="line">      //修改主题颜色</div><div class="line">      theme: new ThemeData(</div><div class="line">        primaryColor: Colors.blue,</div><div class="line">      ),</div><div class="line">      home: new RandomWords(),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.热重新加载应用程序。请注意，整个背景是白色的，甚至是应用栏。</p>
<p>3.作为读者的练习，使用ThemeData来改变用户界面的其他方面。材质库中的Colors类提供了许多可以使用的颜色常量，而热重载使得用户界面的试验变得快速而简单。</p>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fpkpar0zv2j31401z4jtf.jpg" alt=""></p>
<hr>
<h3 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h3><p>我们编写了一个在iOS和Android上运行的交互式Flutter应用程序。在这个codelab中，你有：</p>
<ul>
<li>从头开始创建一个Flutter应用程序。</li>
<li>书写Dart代码。</li>
<li>利用外部的第三方库。</li>
<li>使用热重载加快开发周期。</li>
<li>实现一个有状态的小部件，为你的应用增加交互性。</li>
<li>用ListView和ListTiles创建一个延迟加载的无限滚动列表。</li>
<li>创建了一条路线并添加了在主路线和新路线之间移动的逻辑。</li>
<li>了解如何使用主题更改应用UI的外观。</li>
</ul>
<hr>
<p>第一篇文章：<a href="http://blog.csdn.net/dazhaodai/article/details/79526401" target="_blank" rel="external"> Flutter初体验（一）—Mac 安装配置</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Flutter初体验（一）---- 配置安装Flutter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Flutter初体验（一）---- 配置安装Flutter/" class="article-date">
      <time datetime="2018-08-24T07:20:51.234Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Flutter初体验（一）---- 配置安装Flutter/">Flutter初体验（一）---- 配置安装Flutter</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>参考文档：<br>    <a href="https://flutter.io/setup-macos/" target="_blank" rel="external">https://flutter.io/setup-macos/</a>          <a href="http://blog.csdn.net/zhangxiangliang2/article/details/75566412" target="_blank" rel="external">http://blog.csdn.net/zhangxiangliang2/article/details/75566412</a></p>
<hr>
<h3 id="1-获取-Flutter-SDK"><a href="#1-获取-Flutter-SDK" class="headerlink" title="1. 获取 Flutter SDK"></a>1. 获取 Flutter SDK</h3><ul>
<li><h4 id="clone-Flutter"><a href="#clone-Flutter" class="headerlink" title="clone Flutter"></a>clone Flutter</h4>1、使用git将Flutter项目克隆到本地，然后将Flutter添加到本地环境变量，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b beta https://github.com/flutter/flutter.git</div></pre></td></tr></table></figure>
</li>
</ul>
<p>2、到Flutter保存的路径下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=`pwd`/flutter/bin:$PATH</div></pre></td></tr></table></figure></p>
<p>2.1、如果下载失败，Google为中国地区提供了镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</div><div class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</div><div class="line">git clone -b dev https://github.com/flutter/flutter.git</div><div class="line">export PATH=&quot;$PWD/flutter/bin:$PATH&quot;</div><div class="line">cd ./flutter</div><div class="line">flutter doctor</div></pre></td></tr></table></figure></p>
<ul>
<li><h4 id="Run-flutter-doctor"><a href="#Run-flutter-doctor" class="headerlink" title="Run flutter doctor"></a>Run flutter doctor</h4>运行<code>Flutter doctor</code>命令检查是否需要安装依赖项，完成安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flutter doctor</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个命令会检查环境并在窗口显示报告，Dart SDK与Flutter捆绑在一起;没有必要单独安装Dart。仔细检查输出是否需要安装其他软件或执行其他任务</p>
<p>如果不出意外，报告如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Doctor summary (to see all details, run flutter doctor -v):</div><div class="line">[✓] Flutter (Channel dev, v0.1.7, on Mac OS X 10.12.6 16G1212, locale zh-Hans-CN)</div><div class="line">[✓] Android toolchain - develop for Android devices (Android SDK 27.0.0)</div><div class="line">[!] iOS toolchain - develop for iOS devices (Xcode 9.2)</div><div class="line">    ✗ libimobiledevice and ideviceinstaller are not installed. To install, run:</div><div class="line">        brew install --HEAD libimobiledevice</div><div class="line">        brew install ideviceinstaller</div><div class="line">    ✗ ios-deploy not installed. To install:</div><div class="line">        brew install ios-deploy</div><div class="line">[✓] Android Studio (version 3.0)</div><div class="line">[✓] Connected devices (1 available)</div></pre></td></tr></table></figure></p>
<p>第一次运行命令时，它会下载自身的依赖关系并自行编译，后续运行会快很多。如果过程失败，多重复几次，并根据命令行提示进行安装。</p>
<p>接下来会介绍如何执行这些任务并完成设置过程，如果你选择使用某个IDE，可用于IntelliJ IDEA, Android Studio, 和 VS Code，你会看到<code>flutter doctor</code>输出过程。</p>
<p>一旦你安装了任何缺失的依赖关系，再次运行<code>flutter doctor</code>命令来验证你已经正确设置了所有东西.</p>
<h3 id="2-获取文件路径"><a href="#2-获取文件路径" class="headerlink" title="2. 获取文件路径"></a>2. 获取文件路径</h3><p>Flutter SDK下载后的路径，获取Flutter SDK 的安装路径：<br>/Users/用户名/flutter，要注意的是flutter文件夹下面有多个同名的flutter文件夹，真正的SDK路径只到顶层flutter文件夹<br>具体步骤参考网友做的GIF</p>
<p>打开文件管理<br><img src="http://img.blog.csdn.net/20170720173247459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd4aWFuZ2xpYW5nMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="打开文件管理"></p>
<p>进入sdk目录<br><img src="http://img.blog.csdn.net/20170720173400026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd4aWFuZ2xpYW5nMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>获取文件完整路径<br><img src="http://img.blog.csdn.net/20170720173426342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd4aWFuZ2xpYW5nMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="3-安装Flutter插件和Dart插件"><a href="#3-安装Flutter插件和Dart插件" class="headerlink" title="3. 安装Flutter插件和Dart插件"></a>3. 安装Flutter插件和Dart插件</h3><p> 这里以AndroidStudio为例，打开Preferences面板，在Plugins中搜索Flutter，install，安装时自动安装Dart，安装完成后重启AndroidStudio</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2789715-e7e2c0d64d58fa0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>重启AndroidStudio后，File-&gt;New 中出现  New Flutter Project，说明安装成功<img src="https://upload-images.jianshu.io/upload_images/2789715-602d3cb881459af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-03-13 20.38.38.png"></p>
<h3 id="4-创建Flutter-Project"><a href="#4-创建Flutter-Project" class="headerlink" title="4. 创建Flutter Project"></a>4. 创建Flutter Project</h3><ul>
<li>File -&gt; New -&gt; New Flutter Project，选择Flutter Application -&gt; Next,这里注意 Flutter SDK的路径是否正确</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2789715-f836442dbdf35232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>Next -&gt; 设置 Company domain，Finish,Project创建完成，等待几分钟，Project完成初始化，新建Project提供了默认界面，直接运行，看看运行界面：<br><img src="https://upload-images.jianshu.io/upload_images/2789715-1fa5004873f00d8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></li>
</ul>
<p>至此，Flutter环境配置完成，示例也能运行，后续继续学习Flutter的开发。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java进阶 ——— 面试常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java进阶 ——— 面试常见问题/" class="article-date">
      <time datetime="2018-08-24T07:18:02.162Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java进阶 ——— 面试常见问题/">Java进阶 ——— 面试常见问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="1-java中-和equals和hashCode的区别"><a href="#1-java中-和equals和hashCode的区别" class="headerlink" title="1. java中==和equals和hashCode的区别"></a>1. java中==和equals和hashCode的区别</h3><ul>
<li>1.关系操作符“==”到底比较的是什么？ </li>
</ul>
<p>“关系操作符生成的是一个boolean结果，它们计算的是操作数的值之间的关系”。</p>
<p>　　这句话看似简单，理解起来还是需要细细体会的。说的简单点，==就是用来比较值是否相等<br>在Java中游8种基本数据类型：</p>
<p>　　浮点型：float(4 byte), double(8 byte)</p>
<p>　　整型：byte(1 byte), short(2 byte), int(4 byte) , long(8 byte)</p>
<p>　　字符型: char(2 byte)</p>
<p>　　布尔型: boolean(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值”true”和”false”)</p>
<p>　　对于这8种基本数据类型的变量，变量直接存储的是“值”，因此在用关系操作符==来进行比较时，比较的就是 “值” 本身。要注意浮点型和整型都是有符号类型的，而char是无符号类型的（char类型取值范围为0~2^16-1).</p>
<p>　　也就是说比如：</p>
<p>　　int n=3;</p>
<p>　　int m=3;　</p>
<p>　　变量n和变量m都是直接存储的”3”这个数值，所以用==比较的时候结果是true。</p>
<ul>
<li>2.equals比较的又是什么？</li>
</ul>
<p>equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。为了更直观地理解equals方法的作用，直接看Object类中equals方法的实现。</p>
<p>下面是String类中equals方法的具体实现：<br><img src="https://images0.cnblogs.com/i/288799/201404/232112289512869.jpg" alt="String中equals"></p>
<p>　可以看出，String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。</p>
<p>　　其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。</p>
<ul>
<li>3.关于hashCode()</li>
</ul>
<p>这个方法返回对象的散列码，返回值是int类型的散列码。<br>对象的散列码是为了更好的支持基于哈希机制的Java集合类，例如 Hashtable, HashMap, HashSet 等。</p>
<p>关于hashCode方法，一致的约定是：<br>重写了euqls方法的对象必须同时重写hashCode()方法。</p>
<p>如果2个对象通过equals调用后返回是true，那么这个2个对象的hashCode方法也必须返回同样的int型散列码</p>
<p>如果2个对象通过equals返回false，他们的hashCode返回的值允许相同。(然而，程序员必须意识到，hashCode返回独一无二的散列码，会让存储这个对象的hashtables更好地工作。)</p>
<p>相比 于 equals公认实现约定，hashCode的公约要求是很容易理解的。有2个重点是hashCode方法必须遵守的。约定的第3点，其实就是第2点的<br>细化，下面我们就来看看对hashCode方法的一致约定要求。</p>
<p>第一：在某个运行时期间，只要对象的（字段的）变化不会影响equals方法的决策结果，那么，在这个期间，无论调用多少次hashCode，都必须返回同一个散列码。</p>
<p>第二：通过equals调用返回true 的2个对象的hashCode一定一样。</p>
<p>第三：通过equasl返回false 的2个对象的散列码不需要不同，也就是他们的hashCode方法的返回值允许出现相同的情况。</p>
<p>总结一句话：等价的(调用equals返回true)对象必须产生相同的散列码。不等价的对象，不要求产生的散列码不相同。</p>
<hr>
<p>总结来说：</p>
<p>　　1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>
<p>　　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p>
<p>　　2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量</p>
<p>　　　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>
<p>　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容</p>
<hr>
<pre><code>作者：海子　
出处：http://www.cnblogs.com/dolphin0520/
</code></pre><hr>
<hr>
<h3 id="2-int、char、long各占多少字节数"><a href="#2-int、char、long各占多少字节数" class="headerlink" title="2.int、char、long各占多少字节数"></a>2.int、char、long各占多少字节数</h3><p>int 4字节  char 2字节  long 8字节</p>
<hr>
<h3 id="3-int和Integer的区别"><a href="#3-int和Integer的区别" class="headerlink" title="3. int和Integer的区别"></a>3. int和Integer的区别</h3><ul>
<li>1、Integer是int的包装类，int则是java的一种基本数据类型 </li>
<li>2、Integer变量必须实例化后才能使用，而int变量不需要 </li>
<li>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </li>
<li>4、Integer的默认值是null，int的默认值是0</li>
</ul>
<p>延伸：<br>关于Integer和int的比较<br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer i = new Integer(100);</div><div class="line">Integer j = new Integer(100);</div><div class="line">System.out.print(i == j); //false</div></pre></td></tr></table></figure></p>
<p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer i = new Integer(100);</div><div class="line">int j = 100；</div><div class="line">System.out.print(i == j); //true</div></pre></td></tr></table></figure></p>
<p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer i = new Integer(100);</div><div class="line">Integer j = 100;</div><div class="line">System.out.print(i == j); //false</div></pre></td></tr></table></figure></p>
<p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Integer i = 100;</div><div class="line">Integer j = 100;</div><div class="line">System.out.print(i == j); //true</div><div class="line">Integer i = 128;</div><div class="line">Integer j = 128;</div><div class="line">System.out.print(i == j); //false</div><div class="line">对于第4条的原因： </div><div class="line">java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</div><div class="line">public static Integer valueOf(int i)&#123;</div><div class="line">    assert IntegerCache.high &gt;= 127;</div><div class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</div><div class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">    &#125;</div><div class="line">    return new Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p>
<hr>
<h3 id="4-Java多态的理解"><a href="#4-Java多态的理解" class="headerlink" title="4. Java多态的理解"></a>4. Java多态的理解</h3><p>一、 多态的概念：同一操作作用于不同对象，可以有不同的解释，有不同的执行结果，这就是多态，简单来说就是：父类的引用指向子类对象</p>
<p>二、 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p>三、 多态的作用：消除类型之间的耦合关系。</p>
<p>四、 现实中，关于多态的例子不胜枚举。比方说按下 F1键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果</p>
<p>五、 多态存在的三个必要条件</p>
<ul>
<li>一、要有继承；</li>
<li>二、要有重写；</li>
<li>三、父类引用指向子类对象。</li>
</ul>
<p>六、多态的好处：</p>
<ol>
<li>可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</li>
<li>可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</li>
<li>接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。</li>
<li>灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</li>
<li>简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</li>
<li><strong>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法</strong>，多态在继承链中对象方法的调用存在一个优先级：<code>this.show(O)</code>、<code>super.show(O)</code>、<code>this.show((super)O)</code>、<code>super.show((super)O)</code>。<br>子类的对象，先在子类中查找是否有覆盖的方法，没有就去父类查找该方法，如果还没有，就在子类调用继承于父类的参数，并强转为父类的参数的方法，如果还没有，调用父类中方法，并将参数转为父类</li>
</ol>
<hr>
<h3 id="5-Java中的String，StringBuilder，StringBuffer三者的区别"><a href="#5-Java中的String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="5. Java中的String，StringBuilder，StringBuffer三者的区别"></a>5. Java中的String，StringBuilder，StringBuffer三者的区别</h3><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p>
<ul>
<li>1、首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String<br>String最慢的原因：<br>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</li>
</ul>
<ul>
<li><p>2、 再来说线程安全<br>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的<br>　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
</li>
<li><p>3、总结一下<br>　　String：适用于少量的字符串操作的情况<br>　　StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>　　StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>
</li>
</ul>
<hr>
<h3 id="6-什么是内部类？内部类的作用"><a href="#6-什么是内部类？内部类的作用" class="headerlink" title="6. 什么是内部类？内部类的作用"></a>6. 什么是内部类？内部类的作用</h3><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p>
<ul>
<li><p>1.成员内部类<br>　　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Circle &#123;</div><div class="line">  double radius = 0;</div><div class="line">   </div><div class="line">  public Circle(double radius) &#123;</div><div class="line">      this.radius = radius;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  class Draw &#123;     //内部类</div><div class="line">      public void drawSahpe() &#123;</div><div class="line">          System.out.println(&quot;drawshape&quot;);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p>
<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">外部类.this.成员变量</div><div class="line">外部类.this.成员方法</div></pre></td></tr></table></figure>
<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Circle &#123;</div><div class="line">  private double radius = 0;</div><div class="line"> </div><div class="line">  public Circle(double radius) &#123;</div><div class="line">      this.radius = radius;</div><div class="line">      getDrawInstance().drawSahpe();   //必须先创建成员内部类的对象，再进行访问</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  private Draw getDrawInstance() &#123;</div><div class="line">      return new Draw();</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  class Draw &#123;     //内部类</div><div class="line">      public void drawSahpe() &#123;</div><div class="line">          System.out.println(radius);  //外部类的private成员</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">  public static void main(String[] args)  &#123;</div><div class="line">      //第一种方式：</div><div class="line">    Outter outter = new Outter();</div><div class="line">    Outter.Inner inner = outter.new Inner();  //必须通过Outter对象来创建</div><div class="line">       </div><div class="line">      //第二种方式：</div><div class="line">    Outter.Inner inner1 = outter.getInnerInstance();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Outter &#123;</div><div class="line">  private Inner inner = null;</div><div class="line">  public Outter() &#123;</div><div class="line">       </div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  public Inner getInnerInstance() &#123;</div><div class="line">      if(inner == null)</div><div class="line">          inner = new Inner();</div><div class="line">      return inner;</div><div class="line">  &#125;</div><div class="line">    </div><div class="line">  class Inner &#123;</div><div class="line">      public Inner() &#123;</div><div class="line">           </div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>
</li>
<li><p>2.局部内部类<br>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class People&#123;</div><div class="line">  public People() &#123;</div><div class="line">       </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class Man&#123;</div><div class="line">  public Man()&#123;</div><div class="line">       </div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  public People getWoman()&#123;</div><div class="line">      class Woman extends People&#123;   //局部内部类</div><div class="line">          int age =0;</div><div class="line">      &#125;</div><div class="line">      return new Woman();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
</li>
<li><p>3.匿名内部类<br>　　匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">scan_bt.setOnClickListener(new OnClickListener() &#123;</div><div class="line">           </div><div class="line">          @Override</div><div class="line">          public void onClick(View v) &#123;</div><div class="line">              // TODO Auto-generated method stub</div><div class="line">               </div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">       </div><div class="line">      history_bt.setOnClickListener(new OnClickListener() &#123;</div><div class="line">           </div><div class="line">          @Override</div><div class="line">          public void onClick(View v) &#123;</div><div class="line">              // TODO Auto-generated method stub</div><div class="line">               </div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<p>  这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new OnClickListener() &#123;</div><div class="line">         </div><div class="line">        @Override</div><div class="line">        public void onClick(View v) &#123;</div><div class="line">            // TODO Auto-generated method stub</div><div class="line">             </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>  匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
</li>
<li><p>4.静态内部类<br>　　静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
</li>
</ul>
<hr>
<pre><code>Java内部类详解 
https://www.cnblogs.com/dolphin0520/p/3811445.html
</code></pre><hr>
<h3 id="7-抽象类和接口区别"><a href="#7-抽象类和接口区别" class="headerlink" title="7. 抽象类和接口区别"></a>7. 抽象类和接口区别</h3><h5 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h5><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">抽象类</th>
<th style="text-align:center">接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td style="text-align:center">它可以有默认的方法实现</td>
<td style="text-align:center">接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>实现</td>
<td style="text-align:center">子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td style="text-align:center">子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td style="text-align:center">抽象类可以有构造器</td>
<td style="text-align:center">接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td style="text-align:center">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td style="text-align:center">接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td style="text-align:center">抽象方法可以有public、protected和default这些修饰符</td>
<td style="text-align:center">接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td style="text-align:center">抽象方法可以有main方法并且我们可以运行它</td>
<td style="text-align:center">接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td style="text-align:center">抽象方法可以继承一个类和实现多个接口</td>
<td style="text-align:center">接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td style="text-align:center">它比接口速度要快</td>
<td style="text-align:center">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td style="text-align:center">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td style="text-align:center">如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody>
</table>
<h5 id="什么时候使用抽象类和接口"><a href="#什么时候使用抽象类和接口" class="headerlink" title="什么时候使用抽象类和接口"></a>什么时候使用抽象类和接口</h5><ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<hr>
<pre><code>Java抽象类与接口的区别
http://www.importnew.com/12399.html
</code></pre><hr>
<h3 id="8-Java中为何要定义抽象类"><a href="#8-Java中为何要定义抽象类" class="headerlink" title="8. Java中为何要定义抽象类"></a>8. Java中为何要定义抽象类</h3><p>抽象方法：由abstract修饰的方法为抽象方法，抽象方法只有方法的定义，没有方法的实现。<br>抽象类：一个类中如果包含抽象方法，个i类应该用abstract关键字声明为抽象类。<br>抽象类不可以实例化，即使一个类中没有抽象方法，也可以将其定义为抽象类，同样，该类不可以实例化。<br>抽象类的意义：</p>
<ul>
<li>1、为子类提供一个公共的类型；</li>
<li>2、封装子类中重复内容（成员变量和方法）；</li>
<li>3、定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的。</li>
</ul>
<h3 id="9-抽象类和接口的使用场景"><a href="#9-抽象类和接口的使用场景" class="headerlink" title="9. 抽象类和接口的使用场景"></a>9. 抽象类和接口的使用场景</h3><p>语义上的区别：<br>首先 类描述的是 这个东西是什么（强调所属）？包含了静态属性，静态行为 ，属性和行为。<br>而接口 描述的它能做什么事儿（强调行为）？     只是 静态常量属性 和 行为</p>
<p>abstract class的应用场合<br>  一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：</p>
<ul>
<li>A. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。</li>
<li>B. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。</li>
<li>C. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能<br>其他情况下都是使用 接口。</li>
</ul>
<p>应该这样说，我们再开始使用的时候就是用的接口，后来实现的子类里有些子类有共同属性，或者相同的方法实现，所以提取出来一个抽象类，作为类和接口的中介。</p>
<hr>
<pre><code>抽象类和接口的使用场景
http://blog.csdn.net/xiaoliuliu2050/article/details/61931498
</code></pre><hr>
<h3 id="10-泛型通配符extends与super的区别"><a href="#10-泛型通配符extends与super的区别" class="headerlink" title="10. 泛型通配符extends与super的区别"></a>10. 泛型通配符extends与super的区别</h3><p><code>&lt;? extends T&gt;</code>限定参数类型的上界：参数类型必须是T或T的子类型<br><code>&lt;? super T&gt;</code> 限定参数类型的下界：参数类型必须是T或T的超类型<br>总结为：</p>
<ul>
<li>1.<code>&lt;? extends T&gt;</code> 只能用于方法返回，告诉编译器此返参的类型的最小继承边界为T，T和T的父类都能接收，但是入参类型无法确定，只能接受null的传入</li>
<li>2.<code>&lt;? super T&gt;</code>只能用于限定方法入参，告诉编译器入参只能是T或其子类型，而返参只能用Object类接收</li>
<li>3.? 既不能用于入参也不能用于返参</li>
</ul>
<h3 id="11-父类的静态方法能否被子类重写"><a href="#11-父类的静态方法能否被子类重写" class="headerlink" title="11. 父类的静态方法能否被子类重写"></a>11. 父类的静态方法能否被子类重写</h3><p>静态方法是针对于类而言的，而重写和继承是针对于对象实例的，不能针对于静态方法，因为静态方法在程序启动已经分配内存，所有引用该方法的对象，都指向内存中同一地址，所以子类并不会重写，即使子类定义了相同名称的静态方法，也只是分配了一块内存给子类的静态方法，没有重写的说法。</p>
<h3 id="12-进程和线程的区别"><a href="#12-进程和线程的区别" class="headerlink" title="12. 进程和线程的区别"></a>12. 进程和线程的区别</h3><ul>
<li>1.定义<br>进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br>线程:进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li>
</ul>
<ul>
<li><p>2.关系<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.<br>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p>
</li>
<li><p>3.区别<br>　　进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。<br>1、简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>2、线程的划分尺度小于进程，使得多线程程序的并发性高。<br>3、另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>4、线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>5、从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
</li>
<li><p>4.优缺点<br>线程和进程在使用上各有优缺点：<br>线程执行开销小，但不利于资源的管理和保护；<br>而进程正相反。<br>同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>
</li>
</ul>
<hr>
<pre><code>https://www.cnblogs.com/lgk8023/p/6430592.html
</code></pre><hr>
<h3 id="13-final、finally、finalize区别"><a href="#13-final、finally、finalize区别" class="headerlink" title="13. final、finally、finalize区别"></a>13. final、finally、finalize区别</h3><ul>
<li><p>Final<br>Final用于修饰类、成员变量和成员方法。final修饰的类，不能被继承（String、StringBuilder、StringBuffer、Math，不可变类），其中所有的方法都不能被重写，所以不能同时用abstract和final修饰类（abstract修饰的类是抽象类，抽象类是用于被子类继承的，和final起相反的作用）；Final修饰的方法不能被重写，但是子类可以用父类中final修饰的方法；Final修饰的成员变量是不可变的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的</p>
</li>
<li><p>Finally<br>  Finally通常和try catch搭配使用，保证不管有没有发生异常，资源都能够被释放（释放连接、关闭IO流）。</p>
</li>
<li><p>Finalize<br>  Finalize是object类中的一个方法，子类可以重写finalize()方法实现对资源的回收。垃圾回收只负责回收内存，并不负责资源的回收，资源回收要由程序员完成，Java虚拟机在垃圾回收之前会先调用垃圾对象的finalize方法用于使对象释放资源（如关闭连接、关闭文件），之后才进行垃圾回收，这个方法一般不会显示的调用，在垃圾回收时垃圾回收器会主动调用。    </p>
</li>
</ul>
<hr>
<pre><code>http://blog.csdn.net/beixiaozhang/article/details/52955862
</code></pre><hr>
<h3 id="14-序列化的方式"><a href="#14-序列化的方式" class="headerlink" title="14. 序列化的方式"></a>14. 序列化的方式</h3><ul>
<li>Android开发中的序列化有两种方法。<br>　　第一种是实现Serializable接口（是JavaSE本身就支持的），第二种是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能</li>
<li>两种方式的区别<br>  1）在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。<br>  2）Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。<br>  3）Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。</li>
</ul>
<h3 id="15-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#15-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="15.静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>15.静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h3><p>java中静态属性和静态方法可以被继承，但是没有被重写(overwrite)而是被隐藏.<br>原因：</p>
<ul>
<li>1.静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制及可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为”隐藏”。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在”隐藏”的这种情况。  </li>
<li>2.多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是：”重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。  </li>
<li>3.静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。非静态方法可以被继承和重写，因此可以实现多态</li>
</ul>
<h3 id="16-静态内部类使用的目的"><a href="#16-静态内部类使用的目的" class="headerlink" title="16. 静态内部类使用的目的"></a>16. 静态内部类使用的目的</h3><p>静态内部类可以看做和外部类平级的类，静态内部类不可以访问外部类的非静态变量与成员方法，而非静态内部类，可以访问外部类成员变量和方法，但是内部不允许出现静态成员和静态方法。</p>
<p>创建静态内部类实例不需要绑定在外部类的实例</p>
<h3 id="17-String-转换成-Integer的方式及原理"><a href="#17-String-转换成-Integer的方式及原理" class="headerlink" title="17. String 转换成 Integer的方式及原理"></a>17. String 转换成 Integer的方式及原理</h3><ul>
<li><p>String 转 Integer 的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = Integer.valueOf(str);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>String 转 Integer 原理<br>先来看看 在Integer 类中 Valueof方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  public static Integer valueOf(String s) throws NumberFormatException &#123;</div><div class="line">    return Integer.valueOf(parseInt(s, 10));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析一下<code>parseInt(s, 10)</code>方法，这里只摘取其中关键代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"> public static int parseInt(String s, int radix)</div><div class="line">            throws NumberFormatException</div><div class="line">&#123;</div><div class="line">    int result = 0;</div><div class="line">    boolean negative = false;</div><div class="line">    int i = 0, len = s.length();</div><div class="line">    int limit = -Integer.MAX_VALUE;</div><div class="line">    int multmin;</div><div class="line">    int digit;</div><div class="line"></div><div class="line">    if (len &gt; 0) &#123;</div><div class="line">        char firstChar = s.charAt(0);</div><div class="line">        if (firstChar &lt; &apos;0&apos;) &#123; // Possible leading &quot;+&quot; or &quot;-&quot;  //基本不用管</div><div class="line">            if (firstChar == &apos;-&apos;) &#123;</div><div class="line">                negative = true;</div><div class="line">                limit = Integer.MIN_VALUE;</div><div class="line">            &#125; else if (firstChar != &apos;+&apos;)</div><div class="line">                throw NumberFormatException.forInputString(s);</div><div class="line"></div><div class="line">            if (len == 1) // Cannot have lone &quot;+&quot; or &quot;-&quot;</div><div class="line">                throw NumberFormatException.forInputString(s);</div><div class="line">            i++;  // i自增</div><div class="line">        &#125;</div><div class="line">        multmin = limit / radix;   // multmin = limit/10；</div><div class="line">        while (i &lt; len) &#123;</div><div class="line">            // Accumulating negatively avoids surprises near MAX_VALUE</div><div class="line">            digit = Character.digit(s.charAt(i++),radix);</div><div class="line">            if (digit &lt; 0) &#123;</div><div class="line">                throw NumberFormatException.forInputString(s);</div><div class="line">            &#125;</div><div class="line">            if (result &lt; multmin) &#123;</div><div class="line">                throw NumberFormatException.forInputString(s);</div><div class="line">            &#125;</div><div class="line">            result *= radix;</div><div class="line">            if (result &lt; limit + digit) &#123;</div><div class="line">                throw NumberFormatException.forInputString(s);</div><div class="line">            &#125;</div><div class="line">            result -= digit;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        throw NumberFormatException.forInputString(s);</div><div class="line">    &#125;</div><div class="line">    return negative ? result : -result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java进阶 ——— HTTP概述" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java进阶 ——— HTTP概述/" class="article-date">
      <time datetime="2018-08-24T07:17:32.860Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java进阶 ——— HTTP概述/">Java进阶 ——— HTTP概述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>Web浏览器、服务器和相关的Web应用程序都是通过HTTP相互通信。HTTP是现代全球因特网中使用的公共语言。</p>
<h4 id="HTTP-因特网的多媒体信使"><a href="#HTTP-因特网的多媒体信使" class="headerlink" title="HTTP-因特网的多媒体信使"></a>HTTP-因特网的多媒体信使</h4><hr>
<p>每天都有数亿JPEG图片、HTML页面、文本文件、MPEG电影、WAV音频文件、java小程序和其他资源在因特网游弋。HTTP可以从全世界的Web服务器上将这些信息迅速、便捷、可靠的传输到Web浏览器上。<br>HTTP使用的是可靠的数据传输协议，它能够确保数据在传输过程中不会被损坏或者产生混乱。对开发人员来说，无需担心HTTP通信会在传输过程中被破坏、复制或者产生畸变。开发人员可以专注于程序特有细节的编写，而不是考虑因特网中存在的一些缺陷和问题。</p>
<h4 id="Web客户端和服务器"><a href="#Web客户端和服务器" class="headerlink" title="Web客户端和服务器"></a>Web客户端和服务器</h4><hr>
<p>Web内容都是存储在Web服务器上。Web服务器使用HTTP协议，因此还可以称为HTTP服务器。HTTP客户端向服务器发出请求，服务器会在HTTP响应中回送所请求的数据。</p>
<p><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519114733310-2080783655.jpg" alt=""></p>
<p>最常见的HTTP客户端就是浏览器。浏览器向服务器请求HTTP对象，并将对象显示在屏幕上。</p>
<h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><hr>
<p>因特网有很多的数据类型，HTTP给每种要通过Web传输的对象都打上MIME类型（MIME type）的数据格式标签。最初设计MIME(Multipurpose Internet Mail Extension,多用途因特网邮件扩展)是为了解决不同电子邮件系统之家搬移报文时存在的问题。<br>Web服务器会为所有的HTTP对象数据附一个MIME类型。当Web浏览器从服务器取回一个对象时，会去查看相关的MIME类型，看看它是否知道应该如何处理这个对象。大多数浏览器都可以处理上百种常见对象：显示图片、解析并格式化HTML文件、播放音频文件、或者运行外部软件来处理特殊格式数据。<br>MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。<br>例如：HTML格式的文本文档 text/html类型来标记。</p>
<h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><hr>
<p>每个Web服务器都有一个名字，这样客户端就可以说明它们感兴趣的资源是什么。服务器资源名被统一称为统一资源标识符（Uniform Resource Identifier，URI）。URI有两种形式：分别是URL和URN。</p>
<ul>
<li>URL<blockquote>
<p>统一资源定位符（URL,Uniform Resource Locator）是资源标识符最常见的形式。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112010341-493649336.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>大部分URL都遵循一种标准格式，这种格式包含三个部分。<br>1.URL的第一部分称为方案（scheme），说明访问资源所使用的协议类型。这部分通常是HTTP或者HTTPS（<a href="http://)。" target="_blank" rel="external">http://)。</a><br>2.第二部分给出了服务器的因特网地址（www.joes-hardware.com）。<br>3.其余部分指定了Web服务器上的某个资源（比如，/specials/saw-blade.gif）。<br>现在几乎所有的URI都是URL。</p>
</blockquote>
<ul>
<li>URN</li>
</ul>
<blockquote>
<p>URI的第二种形式就是URN（统一资源名）。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与&gt;位置无关的URN，就可以将资源四处搬动。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。<br>URN仍然处于试验阶段，还未大范围使用。除非特殊说明，否则这里的都是用URL来指定URI。</p>
</blockquote>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><hr>
<p>一个HTTP事务由一条请求命令和一个响应结果组成。这种通信通过名为HTTP报文（HTTP message）的格式化数据块进行。</p>
<ul>
<li>方法</li>
</ul>
<blockquote>
<p>HTTP支持几种几种不同的请求命令，这些命令被称为HTTP方法（HTTP method）。每条HTTP请求报文都包含一个方法。这个方法会告诉服务器要执行什么动作（获取一个Web页面、运行一个网关程序、删除一个文件等）。</p>
</blockquote>
<p>常见的HTTP方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">HTTP方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">从服务器向客户端发送命名资源</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:center">将来自客户端的数据存储到一个命名的资源服务器中</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">从服务器中删除命名资源</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">将客户端数据发送到一个服务器网关应用程序</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">仅发送命名资源响应中的HTTP首部</td>
</tr>
</tbody>
</table>
<ul>
<li>状态码<blockquote>
<p>每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作。</p>
</blockquote>
</li>
</ul>
<p>常见的HTTP状态码：<br>|HTTP状态码|    描述|<br>|—-|—-|<br>|200    |OK, 文档正确返回|<br>|302    |Redirect（重定向）。到其他地方去获取资源|<br>|404    |Not Found（没找到），无法找到这个资源|</p>
<ul>
<li>Web页面可以包含多个对象<blockquote>
<p>应用程序完成一项任务时通常会发布多个HTTP事务。比如，Web浏览器会发布一系列的HTTP事务来获取并显示一个包含丰富图片的Web页面。浏览器会执行一个事务来获取描述页面布局的HTML”框架“，然后发布另外的HTTP事务来获取每个嵌入式图片、图像面板、Java小程序等。这些嵌入式资源甚至可能位于不同的服务器。因此，一个Web页面通常并不是单个资源，而是一组资源的集合。</p>
</blockquote>
</li>
</ul>
<h4 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h4><hr>
<p>HTTP报文都是由一行行的简单字符串组成。HTTP报文都是纯文本，不是二进制代码。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519114829357-917648896.jpg" alt=""></p>
<p>从Web客户端发往Web服务器的HTTP报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文（reponse message），此外没有其他类型的HTTP报文。请求报文和响应报文格式类似。<br>HTTP报文包括以下三部分：</p>
<ul>
<li>起始行</li>
</ul>
<blockquote>
<p>报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。</p>
</blockquote>
<ul>
<li>首部字段</li>
</ul>
<blockquote>
<p>起始行后面有0个或者多个首部字段。每个字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（：）分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。</p>
</blockquote>
<ul>
<li>主体</li>
</ul>
<blockquote>
<p>空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发给Web服务器的数据，响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体可以包含任意的二进制数据（图片、视频、音频、软件程序）。当然，主体还可以包含文本。</p>
</blockquote>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><hr>
<ul>
<li>TCP/IP</li>
</ul>
<blockquote>
<p>HTTP是个应用层协议。HTTP无需关心网络通信的具体细节；它把联网的细节都给了通用、可靠的因特网传输协议TCP/IP。<br>TCP提供了：</p>
<ul>
<li>无差错的数据传输。</li>
<li>按序传输（数据总是按照发送的顺序到达）；</li>
<li>分段的数据流（可以在任意时刻以任意大小将数据发送出去）。<br>因特网自身是基于TCP/IP的，它是全世界计算机网络常用的层次化分组交换网络协议集。TCP/IP 隐藏了各种网络和硬件的特点及弱点，使各种类型的计算机和网络都能够进行可靠地通信。<br>只要建立了TCP连接，客户端和服务器之间的报文交换就不会丢失、被破坏、也不会出现接收时乱序。HTTP协议位于TCP的上层。HTTP使用TCP来传输其报文数据。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112140466-1638988931.jpg" alt=""></li>
</ul>
</blockquote>
<ul>
<li>连接、IP地址及端口号</li>
</ul>
<blockquote>
<p>在HTTP客户端向服务器发送报文之前，需要用网际协议（Internet Prococol，IP）地址和端口号在客户端和服务器之间建立一条TCP/IP连接。<br>建立一条TCP连接的过程与给公司办公室的某个人打电话的过程类似。首先，要拨打公司的电话号码。这样就能进入正确的机构了。其次，拨打要联系的那个人的分机号。<br>最初怎么获取服务器的IP地址呢？当然是通过URL。<br>先看几个URL:<br><a href="http://207.200.83.29:80/index.html" target="_blank" rel="external">http://207.200.83.29:80/index.html</a><br><a href="http://www.netscape.com:80/index.html" target="_blank" rel="external">http://www.netscape.com:80/index.html</a><br><a href="http://www.netscape.com/index.html" target="_blank" rel="external">http://www.netscape.com/index.html</a><br>第一个 URL 使用了机器的 IP 地址，207.200.83.29 以及端口.第二个 URL 没有使用数字形式的 IP 地址，它使用的是文本形式的域名，或者称为主机名（www.netscape.com） 。主机名就是 IP 地址比较人性化的别称。可以通过一<br>种称为域名服务（Domain Name Service，DNS）的机制方便地将主机名转换为 IP地址，这样所有问题就都解决了。<br>最后一个 URL 没有端口号。HTTP 的 URL 中没有端口号时，可以假设默认端口号是 80。有了 IP 地址和端口号，客户端就可以很方便地通过 TCP/IP 进行通信了。</p>
</blockquote>
<ul>
<li>连接、IP地址及端口号</li>
</ul>
<blockquote>
<p>在HTTP客户端向服务器发送报文之前，需要用网际协议（Internet Prococol，IP）地址和端口号在客户端和服务器之间建立一条TCP/IP连接。<br>建立一条TCP连接的过程与给公司办公室的某个人打电话的过程类似。首先，要拨打公司的电话号码。这样就能进入正确的机构了。其次，拨打要联系的那个人的分机号。<br>最初怎么获取服务器的IP地址呢？当然是通过URL。<br>先看几个URL:<br><a href="http://207.200.83.29:80/index.html" target="_blank" rel="external">http://207.200.83.29:80/index.html</a><br><a href="http://www.netscape.com:80/index.html" target="_blank" rel="external">http://www.netscape.com:80/index.html</a><br><a href="http://www.netscape.com/index.html" target="_blank" rel="external">http://www.netscape.com/index.html</a><br>第一个 URL 使用了机器的 IP 地址，207.200.83.29 以及端口.第二个 URL 没有使用数字形式的 IP 地址，它使用的是文本形式的域名，或者称为主机名（www.netscape.com） 。主机名就是 IP 地址比较人性化的别称。可以通过一<br>种称为域名服务（Domain Name Service，DNS）的机制方便地将主机名转换为 IP地址，这样所有问题就都解决了。<br>最后一个 URL 没有端口号。HTTP 的 URL 中没有端口号时，可以假设默认端口号是 80。有了 IP 地址和端口号，客户端就可以很方便地通过 TCP/IP 进行通信了。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112159576-752772932.jpg" alt=""></p>
</blockquote>
<p>步骤如下：</p>
<p>(a) 浏览器从 URL 中解析出服务器的主机名；</p>
<p>(b) 浏览器将服务器的主机名转换成服务器的 IP 地址；</p>
<p>(c) 浏览器将端口号（如果有的话）从 URL 中解析出来；</p>
<p>(d) 浏览器建立一条与 Web 服务器的 TCP 连接；</p>
<p>(e) 浏览器向服务器发送一条 HTTP 请求报文；</p>
<p>(f) 服务器向浏览器回送一条 HTTP 响应报文；</p>
<p>(g) 关闭连接，浏览器显示文档。</p>
<ul>
<li>使用Telnet实例<blockquote>
<p>Telnet程序可以将键盘连接到某个目标TCP端口，并将此TCP端口的输出回送到显示屏上。Telnet常用于远程终端会话，但它几乎可以连接所有的TCP服务器，包括HTTP服务器。<br>可以通过Telnet程序直接与Web服务器进行对话。通过Telnet可以打开一条到某台机器上某个端口的TCP连接，然后直接向端口输入一些字符。Web服务器会将Telnet程序作为一个Web客户端来处理，然后回送给TCP连接的数据会显示在屏幕上。<br>实际例子：Telnet获取URL <a href="http://www.joes-hardware.com:80/tools.html" target="_blank" rel="external">http://www.joes-hardware.com:80/tools.html</a> 所指向的文档<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112210466-1338515722.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Telnet 会查找主机名并打开一条连接，连接到在 www.joes-hardware.com 的端口 80上监听的 Web 服务器。这条命令之后的三行内容是 Telnet 的输出，告诉我们它已经建立了连接。<br>然后我们输入最基本的请求命令 GET/tools.html HTTP/1.1 ，发送一个提供了源端主机名的 Host 首部，后面跟上一个空行，请求从服务器 www.joes-hardware.com 上获取资源 tools.html。随后，服务器会以一个响应行、几个响应首部、一个空行和最后面的 HTML 文档主体来应答。<br>要明确的是，Telnet 可以很好地模拟 HTTP 客户端，但不能作为服务器使用。而且对 Telnet 做脚本自动化是很繁琐乏味的。如果想要更灵活的工具，可以去看看 nc（netcat） 。通过 nc 可以很方便地操纵基于 UDP 和 TCP 的流量（包括 HTTP） ，还可以为其编写脚本。更多细节参见 <a href="http://www.bgw.org/tutorials/utilities/nc.php" target="_blank" rel="external">http://www.bgw.org/tutorials/utilities/nc.php</a></p>
</blockquote>
<h4 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h4><hr>
<p>目前HTTP有几个协议版本。</p>
<ul>
<li>HTTP/0.9</li>
</ul>
<blockquote>
<p>HTTP 的 1991 原型版本称为 HTTP/0.9。这个协议有很多严重的设计缺陷，只应该用于与老客户端的交互。HTTP/0.9 只支持 GET 方法，不支持多媒体内容的MIME 类型、各种 HTTP 首部，或者版本号。HTTP/0.9 定义的初衷是为了获取简单的 HTML 对象，它很快就被 HTTP/1.0 取代了。</p>
</blockquote>
<ul>
<li>HTTP/1.0</li>
</ul>
<blockquote>
<p>1.0 是第一个得到广泛使用的 HTTP 版本。HTTP/1.0 添加了版本号、各种 HTTP首部、一些额外的方法，以及对多媒体对象的处理。HTTP/1.0 使得包含生动图片的 Web 页面和交互式表格成为可能，而这些页面和表格促使万维网为人们广泛地接受。这个规范从未得到良好地说明。在这个 HTTP 协议的商业演进和学术研究都在快速进行的时代，它集合了一系列的最佳实践。</p>
</blockquote>
<ul>
<li>HTTP/1.0+</li>
</ul>
<blockquote>
<p>在 20 世纪 90 年代中叶，很多流行的 Web 客户端和服务器都在飞快地向 HTTP中添加各种特性，以满足快速扩张且在商业上十分成功的万维网的需要。其中很多特性，包括持久的 keep-alive 连接、虚拟主机支持，以及代理连接支持都被加入到 HTTP 之中，并成为非官方的事实标准。这种非正式的 HTTP 扩展版本通常称为 HTTP/1.0+。</p>
</blockquote>
<ul>
<li>HTTP/1.1</li>
</ul>
<blockquote>
<p>HTTP/1.1 重点关注的是校正 HTTP 设计中的结构性缺陷，明确语义，引入重要的性能优化措施，并删除一些不好的特性。HTTP/1.1 还包含了对 20 世纪 90 年代末正在发展中的更复杂的 Web 应用程序和部署方式的支持。HTTP/1.1 是当前使用的 HTTP 版本。</p>
</blockquote>
<ul>
<li>HTTP-NG（又名 HTTP/2.0）</li>
</ul>
<blockquote>
<p>HTTP-NG 是 HTTP/1.1 后继结构的原型建议，它重点关注的是性能的大幅优化，以及更强大的服务逻辑远程执行框架。HTTP-NG 的研究工作终止于 1998 年，编写本书时，还没有任何要用此建议取代 HTTP/1.1 的推广计划。</p>
</blockquote>
<h4 id="Web结构组件"><a href="#Web结构组件" class="headerlink" title="Web结构组件"></a>Web结构组件</h4><hr>
<p>前面重点介绍了Web应用程序（Web客户端和Web服务器）是如何相互发送报文来实现基本事务处理的。因特网上还有一些其他的应用程序。下面一一介绍。</p>
<ul>
<li>代理</li>
</ul>
<blockquote>
<p>代理位于客户端和服务器之间的HTTP中间实体。接收所有客户端的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发） 。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112229279-96424183.jpg" alt=""></p>
</blockquote>
<p>出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。</p>
<ul>
<li>缓存<blockquote>
<p>Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了.<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112238310-462215583.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<p>客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。HTTP 定义了很多功能，使得缓存更加高效，并规范了文档的新鲜度和缓存内容的隐私性。</p>
<ul>
<li>网关</li>
</ul>
<blockquote>
<p>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。<br>例如，一个 HTTP/FTP 网关会通过 HTTP 请求接收对 FTP URI 的请求，但通过 FTP协议来获取文档 。得到的文档会被封装成一条 HTTP 报文，发送给客户端。第 8 章将探讨网关。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112338576-179894136.jpg" alt=""></p>
</blockquote>
<ul>
<li>隧道</li>
</ul>
<blockquote>
<p>隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。<br>HTTP 隧道的一种常见用途是通过 HTTP 连接承载加密的安全套接字层（SSL，Secure Sockets Layer）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。如图所示，HTTP/SSL 隧道收到一条 HTTP 请求，要求建立一条到目的地址和端口的输出连接，然后在 HTTP 信道上通过隧道传输加密的 SSL 流量，这样就可以将其盲转发到目的服务器上去了。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112347044-225510358.jpg" alt=""></p>
</blockquote>
<ul>
<li>Agent代理</li>
</ul>
<blockquote>
<p>用户 Agent 代理（或者简称为 Agent 代理）是代表用户发起 HTTP 请求的客户端程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。到目前为止，我们只提到过一种 HTTP Agent 代理：Web 浏览器，但用户 Agent 代理还有很多其他类型。用fiddler抓包找头部信息会发现类似User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36<br>比如，有些自己会在 Web 上闲逛的自动用户 Agent 代理，可以在无人监视的情况下发布 HTTP 事务并获取内容。这些自动代理的名字通常都很生动，比如“网络蜘蛛”（spiders）或者“Web 机器人” （Web robots） 。网络蜘蛛会在 Web 上闲逛，搜集信息以构建有效的 Web 内容档案，比如一个搜索引擎的数据库或者为比较购物机器人生成的产品目录。<br><img src="https://images2015.cnblogs.com/blog/436758/201605/436758-20160519112356466-407427538.jpg" alt=""></p>
</blockquote>
<h2 id="URL和资源"><a href="#URL和资源" class="headerlink" title="URL和资源"></a>URL和资源</h2><h4 id="因特网资源"><a href="#因特网资源" class="headerlink" title="因特网资源"></a>因特网资源</h4><p>URL是浏览器寻找信息所需的资源位置。URI是一类更通用的资源标识符，URL是URI的一个子集。URI包括URL和URN。</p>
<h4 id="URL语法"><a href="#URL语法" class="headerlink" title="URL语法"></a>URL语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</div></pre></td></tr></table></figure>
<ul>
<li>scheme<br>访问服务器以获取资源时要使用的协议 默认值 无</li>
<li>user<br>一些方案访问资源时需要的用户名 默认值 匿名</li>
<li>password<br>用户名后面可能要包含密码,中间由冒号分隔 默认值 </li>
<li>host<br>资源宿主服务器的主机名或点分IP地址 默认值 无</li>
<li>port<br>资源宿主服务器正在监听的端口号,很多方案都有默认端口号(HTTP默认端口号为80) 默认值 每个方案特有</li>
<li>path<br>服务器上资源的本地名,由一个”/“将其与前面的URL组件分隔开来.路径组件的语法与服务器和方案有关 默认值 无</li>
<li>params<br>一些方案会用这个组件指定输入参数. 参数为名/值对. URL中可以包含多个参数字段,它们相互以及与路径的其余部分之间用分号(;)分隔 默认值 无</li>
<li>query<br>一些方案会用这个组件传递参数以激活应用程序.查询组件的内容没有通用格式.用符号”?”将其与URL的其余部分分隔开来 默认值 无</li>
<li>frag<br>一小片或一部分资源的名字.引用对象时,不会将frag字段传送给服务器。这个字段是在客户端内部使用的.通过字符”#”将其与URL其余部分分隔开来 默认值 无</li>
</ul>
<p><a href="http://www.joes-hardware.com/hammers;sale=false/index.html;graphic=ture" target="_blank" rel="external">http://www.joes-hardware.com/hammers;sale=false/index.html;graphic=ture</a><br>这个例子就有两个路径段，hammers和index.html。hammers路径段的参数是sale，值为false。index.html段有参数graphics，值为true。<br><a href="http://www.joes-hardware.com/inventory-check.cgi?item=12731" target="_blank" rel="external">http://www.joes-hardware.com/inventory-check.cgi?item=12731</a><br>问号右边的内容称为查询组件。URL的查询组件和标志网关资源的URL路径组件一起被发送给网关资源。基本上可以将网关当作访问其他应用程序的访问点。<br>HTTP服务器只处理整个对象，而不是对象的片段，客户端不能将片段传送给服务器，浏览器获得整个资源后，会根据片段来显示你感兴趣的内容。</p>
<h2 id="TCP-IP的三次握手，四次分手"><a href="#TCP-IP的三次握手，四次分手" class="headerlink" title="TCP/IP的三次握手，四次分手"></a>TCP/IP的三次握手，四次分手</h2><p>首先我们先来了解TCP报文段</p>
<p><img src="https://img-blog.csdn.net/20150830163219709" alt=""></p>
<p>重要的标志我在图中也有标记，重点了解标志位<br>ACK：确认序号有效<br>RST：重置连接<br>SYN：发起了一个新连接<br>FIN：释放一个连接</p>
<h4 id="三次握手的过程（客户端我们用A表示，服务器端用B表示）"><a href="#三次握手的过程（客户端我们用A表示，服务器端用B表示）" class="headerlink" title="三次握手的过程（客户端我们用A表示，服务器端用B表示）"></a>三次握手的过程（客户端我们用A表示，服务器端用B表示）</h4><p>前提：A主动打开，B被动打开<br><img src="https://img-blog.csdn.net/20150830163536721" alt=""></p>
<ol>
<li>在建立连接之前，B先创建TCB（传输控制块），准备接受客户进程的连接请求，处于LISTEN（监听）状态</li>
<li>A首先创建TCB，然后向B发出连接请求，SYN置1，同时选择初始序号seq=x，进入SYN-SEND（同步已发送）状态</li>
<li>B收到连接请求后向A发送确认，SYN置1，ACK置1，同时产生一个确认序号ack=x+1。同时随机选择初始序号seq=y，进入SYN-RCVD（同步收到）状态</li>
<li>A收到确认连接请求后，ACK置1，确认号ack=y+1，seq=x+1，进入到ESTABLISHED（已建立连接）状态。向B发出确认连接，最后B也进入到ESTABLISHED（已建立连接）状态。</li>
</ol>
<p>简单来说，就是</p>
<ol>
<li>建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认</li>
<li>服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态</li>
<li>客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
</ol>
<p>在此穿插一个知识点就是SYN攻击，那么什么是SYN攻击？发生的条件是什么？怎么避免？<br>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是 Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址 是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网 络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：</p>
<p>  #netstat -nap | grep SYN_RECV</p>
<h4 id="四次分手的过程（客户端我们用A表示，服务器端用B表示）"><a href="#四次分手的过程（客户端我们用A表示，服务器端用B表示）" class="headerlink" title="四次分手的过程（客户端我们用A表示，服务器端用B表示）"></a>四次分手的过程（客户端我们用A表示，服务器端用B表示）</h4><p>由于TCP连接时是全双工的，因此每个方向都必须单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的链接。收到一个FIN只是意味着这一方向上没有数据流动，既不会在收到数据，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p>前提：A主动关闭，B被动关闭<br><img src="https://img-blog.csdn.net/20150830170207281" alt=""></p>
<p>有人可能会问，为什么连接的时候是三次握手，而断开连接的时候需要四次挥手？<br>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再 发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<ol>
<li>A发送一个FIN，用来关闭A到B的数据传送，A进入FIN_WAIT_1状态。</li>
<li>B收到FIN后，发送一个ACK给A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），B进入CLOSE_WAIT状态。</li>
<li>B发送一个FIN，用来关闭B到A的数据传送，B进入LAST_ACK状态。</li>
<li>A收到FIN后，A进入TIME_WAIT状态，接着发送一个ACK给B，确认序号为收到序号+1，B进入CLOSED状态，完成四次挥手。</li>
</ol>
<p>简单来说就是</p>
<ol>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。</li>
</ol>
<p>A在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），A才进入到CLOSED状态。为什么？<br>为了保证A发送的最后一个ACK报文段能够到达B<br>防止“已失效的连接请求报文段”出现在本连接中</p>
<p>OK~是不是很难懂的感觉？那我们来说的“人性化点的”吧</p>
<p>三次握手流程</p>
<ol>
<li>客户端发个请求“开门呐，我要进来”给服务器</li>
<li>服务器发个“进来吧，我去给你开门”给客户端</li>
<li>客户端有很客气的发个“谢谢，我要进来了”给服务器</li>
</ol>
<p>四次挥手流程</p>
<ol>
<li>客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他</li>
<li>服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走</li>
<li>服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）</li>
<li>客户端发个“我知道了，我走了”，之后自己就走了</li>
</ol>
<hr>
<p>参考<br><a href="http://www.cnblogs.com/qcssmd/p/5508150.html" target="_blank" rel="external">http://www.cnblogs.com/qcssmd/p/5508150.html</a><br><a href="https://blog.csdn.net/u011318165/article/details/48102939" target="_blank" rel="external">https://blog.csdn.net/u011318165/article/details/48102939</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java设计模式  ------ 代理模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java设计模式  ------ 代理模式/" class="article-date">
      <time datetime="2018-08-24T07:16:54.381Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java设计模式  ------ 代理模式/">Java设计模式  ------ 代理模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>代理模式是常用的Java设计模式，它的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。按照代理类的创建时期，代理类可分为两种。</p>
<p>静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。实现类和代理类实现同一个接口，将实现类对象传递给代理类，代理类的实现方法实际是由实现类完成操作的。</p>
<p>动态代理类：在程序运行时，运用反射机制动态创建而成。</p>
<p>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。<br> 静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。</p>
<p>动态代理是实现JDK里的InvocationHandler接口的invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。</p>
<p>还有一种动态代理CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行时，动态修改字节码达到修改类的目的。<br>静态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>动态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java 进阶  ------ 垃圾回收机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java 进阶  ------ 垃圾回收机制/" class="article-date">
      <time datetime="2018-08-24T07:15:25.786Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java 进阶  ------ 垃圾回收机制/">Java 进阶  ------ 垃圾回收机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h3><ul>
<li><p>垃圾回收的意义<br>当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾，JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。</p>
</li>
<li><p>垃圾收集的算法分析<br>1.为什么会有年轻代</p>
<p>我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p>  2.年轻代中的GC</p>
<p>  HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p>
<p>  因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>  在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p>  <img src="http://ifeve.com/wp-content/uploads/2014/07/young_gc.png" alt=""></p>
<p>  3.一个对象的这一辈子<br>我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p>
</li>
</ul>
<hr>
<pre><code>JVM 新生代老年代
https://www.cnblogs.com/E-star/p/5556188.html
</code></pre><hr>
<h3 id="2-常见编码方式"><a href="#2-常见编码方式" class="headerlink" title="2. 常见编码方式"></a>2. 常见编码方式</h3><ul>
<li>1.ASCII<br>共有128个，用一个字节的低7位表示<br>0~31 控制字符 如换行、回车、删除<br>32~126 打印字符</li>
<li>2.GB2312</li>
<li>3.GBK</li>
<li>4.UTF-16</li>
<li>5.UTF-8</li>
</ul>
<h3 id="3-静态代理和动态代理的区别，以及使用场景"><a href="#3-静态代理和动态代理的区别，以及使用场景" class="headerlink" title="3. 静态代理和动态代理的区别，以及使用场景"></a>3. 静态代理和动态代理的区别，以及使用场景</h3><p>原因是采用代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部</p>
<ul>
<li>1.静态代理<br>静态代理是在编译时就将接口、实现类、代理类一股脑儿全部手动完成，但如果我们需要很多的代理，每一个都这么手动的去创建实属浪费时间，而且会有大量的重复代码，此时我们就可以采用动态代理，动态代理可以在程序运行期间根据需要动态的创建代理类及其实例，来完成具体的功能</li>
<li>2.动态代理<br>动态代理类：在程序运行时，运用反射机制动态创建而成。</li>
</ul>
<p>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。<br>静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。</p>
<p>静态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>动态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-如何将一个Java对象序列化到文件"><a href="#4-如何将一个Java对象序列化到文件" class="headerlink" title="4. 如何将一个Java对象序列化到文件"></a>4. 如何将一个Java对象序列化到文件</h3><p>让对象实现Serializable接口或者Parcelable接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public void saveObjToFile(Person p)&#123;  </div><div class="line">     try &#123;  </div><div class="line">         //写对象流的对象  </div><div class="line">         ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(fileName));  </div><div class="line">           </div><div class="line">         oos.writeObject(p);                 //将Person对象p写入到oos中  </div><div class="line">           </div><div class="line">         oos.close();                        //关闭文件流  </div><div class="line">     &#125; catch (FileNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (IOException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125;   </div><div class="line"> &#125;  </div><div class="line">   </div><div class="line"> /* </div><div class="line">  * 从文件中读出对象，并且返回Person对象 </div><div class="line">  */  </div><div class="line"> public Person getObjFromFile()&#123;  </div><div class="line">     try &#123;  </div><div class="line">         ObjectInputStream ois=new ObjectInputStream(new FileInputStream(fileName));  </div><div class="line">           </div><div class="line">         Person person=(Person)ois.readObject();              //读出对象  </div><div class="line">           </div><div class="line">         return person;                                       //返回对象  </div><div class="line">     &#125; catch (FileNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (IOException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (ClassNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125;  </div><div class="line">       </div><div class="line">     return null;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-Java反射的理解"><a href="#5-Java反射的理解" class="headerlink" title="5. Java反射的理解"></a>5. Java反射的理解</h3><h4 id="反射的含义"><a href="#反射的含义" class="headerlink" title="反射的含义"></a>反射的含义</h4><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性</p>
<p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br> 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类；</li>
<li>2.在运行时构造任意一个类的对象；</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>4.在运行时调用任意一个对象的方法<blockquote>
<p>重点：是运行时而不是编译时</p>
</blockquote>
</li>
</ul>
<h4 id="反射的运用"><a href="#反射的运用" class="headerlink" title="反射的运用"></a>反射的运用</h4><p>1、获得Class对象</p>
<hr>
<p>方法有三种</p>
<ul>
<li><p>(1)使用Class类的forName静态方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static Class&lt;?&gt; forName(String className)</div></pre></td></tr></table></figure>
<ul>
<li>(2)直接获取某一个对象的class，比如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> Class&lt;?&gt; klass = int.class;</div><div class="line">Class&lt;?&gt; classInt = Integer.TYPE;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(3)调用某个对象的getClass()方法,比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuilder str = new StringBuilder(&quot;123&quot;);</div><div class="line">Class&lt;?&gt; klass = str.getClass();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>2、判断是否为某个类的实例</p>
<hr>
<p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public native boolean isInstance(Object obj);</div></pre></td></tr></table></figure></p>
<p>3、创建实例</p>
<hr>
<p>通过反射来生成对象主要有两种方式。</p>
<ul>
<li><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">Object str = c.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//获取String所对应的Class对象</div><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">//获取String类带一个String参数的构造器</div><div class="line">Constructor constructor = c.getConstructor(String.class);</div><div class="line">//根据构造器创建实例</div><div class="line">Object obj = constructor.newInstance(&quot;23333&quot;);</div><div class="line">System.out.println(obj);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>4、获取方法</p>
<hr>
<p>获取某个Class对象的方法集合，主要有以下几个方法：<br>getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public Method[] getDeclaredMethods() throws SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Method[] getMethods() throws SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>getMethod 中方法 需要是public，才能获取到</p>
</blockquote>
<p>用例子说明一下，加深理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void testReflect()&#123;</div><div class="line">    try &#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(&quot;hard.uistudy.dai.uifinaltest.main.view.activity.MainActivity6&quot;);</div><div class="line">        try &#123;</div><div class="line">            Object object =  cls.newInstance();</div><div class="line">          Method[] methods =  cls.getMethods();</div><div class="line">          Method[] declaredMethods = cls.getDeclaredMethods();</div><div class="line">            for (Method m: methods) &#123;</div><div class="line">                Log.e(&quot;method&quot;,m.toString());</div><div class="line">            &#125;</div><div class="line">            for (Method m: declaredMethods) &#123;</div><div class="line">                Log.e(&quot;declaredMethods&quot;,m.toString());</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、获取构造器信息</p>
<hr>
<p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public T newInstance(Object ... initargs)</div></pre></td></tr></table></figure></p>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</p>
<p>6、获取类的成员变量（字段）信息</p>
<hr>
<p>主要是这几个方法，在此不再赘述：<br>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void testReflect()&#123;</div><div class="line">       try &#123;</div><div class="line">           Class&lt;?&gt; cls = Class.forName(&quot;hard.uistudy.dai.uifinaltest.main.view.activity.MainActivity6&quot;);</div><div class="line">           try &#123;</div><div class="line">             Object object =  cls.newInstance();</div><div class="line">             Method[] methods =  cls.getMethods();</div><div class="line">             Field[] fields = cls.getDeclaredFields();</div><div class="line">             for (Field field: fields ) &#123;</div><div class="line">                   Log.e(&quot;Field&quot;,field.toString());</div><div class="line">             &#125;</div><div class="line">           &#125; catch (InstantiationException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125; catch (IllegalAccessException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125;</div><div class="line">       &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>7、调用方法</p>
<hr>
<p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Object invoke(Object obj, Object... args)</div><div class="line">        throws IllegalAccessException, IllegalArgumentException,</div><div class="line">           InvocationTargetException</div></pre></td></tr></table></figure></p>
<p>参考下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class test1 &#123;</div><div class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</div><div class="line">        Class&lt;?&gt; klass = methodClass.class;</div><div class="line">        //创建methodClass的实例</div><div class="line">        Object obj = klass.newInstance();</div><div class="line">        //获取methodClass类的add方法</div><div class="line">        Method method = klass.getMethod(&quot;add&quot;,int.class,int.class);</div><div class="line">        //调用method对应的方法 =&gt; add(1,4)</div><div class="line">        Object result = method.invoke(obj,1,4);</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class methodClass &#123;</div><div class="line">    public final int fuck = 3;</div><div class="line">    public int add(int a,int b) &#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">    public int sub(int a,int b) &#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>8、利用反射创建数组</p>
<hr>
<p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void testArray() throws ClassNotFoundException &#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;);</div><div class="line">        Object array = Array.newInstance(cls,25);</div><div class="line">        //往数组里添加内容</div><div class="line">        Array.set(array,0,&quot;hello&quot;);</div><div class="line">        Array.set(array,1,&quot;Java&quot;);</div><div class="line">        Array.set(array,2,&quot;fuck&quot;);</div><div class="line">        Array.set(array,3,&quot;Scala&quot;);</div><div class="line">        Array.set(array,4,&quot;Clojure&quot;);</div><div class="line">        //获取某一项的内容</div><div class="line">        System.out.println(Array.get(array,3));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。<br>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>
<hr>
<pre><code>原文: http://www.sczyh30.com/posts/Java/java-reflection-1/　　作者: sczyh30
</code></pre><hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java 进阶  ------ 时间复杂度对比" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Java 进阶  ------ 时间复杂度对比/" class="article-date">
      <time datetime="2018-08-24T07:14:50.300Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Java 进阶  ------ 时间复杂度对比/">Java 进阶  ------ 时间复杂度对比</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>  通常，对于一个给定的算法，我们要做 两项分析。第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。而在证明算法是正确的基础上，第二部就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。因此，作为程序员，掌握基本的算法时间复杂度分析方法是很有必要的。<br>       算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。</p>
<h3 id="1-算法的效率"><a href="#1-算法的效率" class="headerlink" title="1.算法的效率"></a>1.算法的效率</h3><p>虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率。<br>算法的效率主要由以下两个复杂度来评估：<br>时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。<br>空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。</p>
<p>设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。</p>
<h3 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h3><p>时间频度<br>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p>时间复杂度<br>前面提到的时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。</p>
<h3 id="3-大O表示法"><a href="#3-大O表示法" class="headerlink" title="3.大O表示法"></a>3.大O表示法</h3><p>像前面用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。<br>算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度。<br>大O表示法O(f(n)中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。</p>
<h4 id="推导大O阶"><a href="#推导大O阶" class="headerlink" title="推导大O阶"></a>推导大O阶</h4><p>推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法：<br>1.用常数1来取代运行时间中所有加法常数。<br>2.修改后的运行次数函数中，只保留最高阶项<br>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p>
<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>先举了例子，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int sum = 0,n = 100; //执行一次  </div><div class="line">sum = (1+n)*n/2; //执行一次  </div><div class="line">System.out.println (sum); //执行一次</div></pre></td></tr></table></figure></p>
<p>上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。如果sum = （1+n）*n/2这条语句再执行10遍，因为这与问题大小n的值并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶。</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>线性阶主要要分析循环结构的运行情况，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;n;i++)&#123;</div><div class="line">//时间复杂度为O(1)的算法</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面算法循环体中的代码执行了n次，因此时间复杂度为O(n)。</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><p>接着看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int number=1;</div><div class="line">while(number&lt;n)&#123;</div><div class="line">number=number*2;</div><div class="line">//时间复杂度为O(1)的算法</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>下面的代码是循环嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;n;i++)&#123;   </div><div class="line">    for(int j=0;j&lt;n;i++)&#123;</div><div class="line">       //复杂度为O(1)的算法</div><div class="line">       ... </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内层循环的时间复杂度在讲到线性阶时就已经得知是O(n)，现在经过外层循环n次，那么这段算法的时间复杂度则为O(n²)。<br>接下来我们来算一下下面算法的时间复杂度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;n;i++)&#123;   </div><div class="line">    for(int j=i;j&lt;n;i++)&#123;</div><div class="line">       //复杂度为O(1)的算法</div><div class="line">       ... </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是内循环中int j=i，而不是int j=0。当i=0时，内循环执行了n次；i=1时内循环执行了n-1次，当i=n-1时执行了1次，我们可以推算出总的执行次数为：</p>
<p>n+(n-1)+(n-2)+(n-3)+……+1<br>=(n+1)+[(n-1)+2]+[(n-2)+3]+[(n-3)+4]+……<br>=(n+1)+(n+1)+(n+1)+(n+1)+……<br>=(n+1)n/2<br>=n(n+1)/2<br>=n²/2+n/2</p>
<p>根据此前讲过的推导大O阶的规则的第二条：只保留最高阶，因此保留n²/2。根据第三条去掉和这个项的常数，则去掉1/2,最终这段代码的时间复杂度为O(n²)。</p>
<h4 id="其他常见复杂度"><a href="#其他常见复杂度" class="headerlink" title="其他常见复杂度"></a>其他常见复杂度</h4><p>除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度： </p>
<ul>
<li>f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。 </li>
<li>f(n)=n³时，时间复杂度为O(n³)，可以称为立方阶。 </li>
<li>f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。 </li>
<li>f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。 </li>
<li>f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶。</li>
</ul>
<h3 id="4-复杂度的比较"><a href="#4-复杂度的比较" class="headerlink" title="4.复杂度的比较"></a>4.复杂度的比较</h3><p>下面将算法中常见的f(n)值根据几种典型的数量级来列成一张表，根据这种表，我们来看看各种算法复杂度的差异。</p>
<table>
<thead>
<tr>
<th>n</th>
<th>logn</th>
<th>√n</th>
<th>nlogn</th>
<th>n²</th>
<th>2ⁿ</th>
<th>n!</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>2</td>
<td>2</td>
<td>10</td>
<td>25</td>
<td>32</td>
<td>120</td>
</tr>
<tr>
<td>10</td>
<td>3</td>
<td>3</td>
<td></td>
<td>30</td>
<td>100</td>
<td>1024</td>
<td>3628800</td>
</tr>
<tr>
<td>50</td>
<td>5</td>
<td>7</td>
<td>250</td>
<td>2500</td>
<td>约10^15</td>
<td>约3.0*10^64</td>
</tr>
<tr>
<td>100</td>
<td>6</td>
<td>10</td>
<td>600</td>
<td>10000</td>
<td>约10^30</td>
<td>约9.3*10^157</td>
</tr>
<tr>
<td>1000</td>
<td>9</td>
<td>31</td>
<td>9000</td>
<td>1000 000</td>
<td>约10^300</td>
<td>约4.0*10^2567</td>
</tr>
</tbody>
</table>
<p>从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。</p>
<p>下面给出一个更加直观的图：<br>这里写图片描述</p>
<p>其中x轴代表n值，y轴代表T(n)值（时间复杂度）。T(n)值随着n的值的变化而变化，其中可以看出O(n!)和O(2ⁿ)随着n值的增大，它们的T(n)值上升幅度非常大，而O(logn)、O(n)、O(nlogn)随着n值的增大，T(n)值上升幅度则很小。<br>常用的时间复杂度按照耗费的时间从小到大依次是：</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/itachi85/article/details/54882603" target="_blank" rel="external">https://blog.csdn.net/itachi85/article/details/54882603</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JVM DVM ART对比" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/JVM DVM ART对比/" class="article-date">
      <time datetime="2018-08-24T07:14:07.614Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/JVM DVM ART对比/">Android 进阶  ------ JVM DVM ART对比</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Android系统使用Dalvik Virtual Machine (DVM)作为其虚拟机，所有安卓程序都运行在安卓系统进程里，每个进程对应着一个Dalvik虚拟机实例。他们都提供了对象生命周期管理、堆栈管理、线程管理、安全和异常管理以及垃圾回收等重要功能，各自拥有一套完整的指令系统。</p>
<p>Android之所以不直接使用JVM作为其虚拟机的原因有很多，版权问题我们暂且搁置一边，本文将首先在技术上对DVM和JVM进行比较，然后重点对Dalvik虚拟机的垃圾回收机制进行介绍，文章末尾再对Android5.0之后使用的新型虚拟机——ART虚拟机进行简单介绍</p>
<h3 id="DVM-vs-JVM"><a href="#DVM-vs-JVM" class="headerlink" title="DVM vs JVM"></a>DVM vs JVM</h3><h5 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h5><ul>
<li>都是解释执行</li>
<li>都是每个 OS 进程运行一个 VM，并运行一个单独的程序</li>
<li>在较新版本中（Froyo / Sun JDK 1.5）都实现了相当程度的 JIT compiler（即时编译） 用于提速。<ul>
<li>JIT（Just In Time，即时编译技术）对于热代码（使用频率高的字节码）直接转换成汇编代码；</li>
</ul>
</li>
</ul>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><ul>
<li><p>dvm执行的是.dex格式文件，jvm执行的是.class文件。class文件和dex之间可以相互转换具体流程如下图，多个class文件转变成一个dex文件会引发一些问题，具体如下：</p>
<ul>
<li>方法数受限：多个class文件变成一个dex文件所带来的问题就是方法数超过65535时报错，由此引出MultiDex技术，具体资料同学可以google下。</li>
<li>class文件去冗余：class文件存在很多的冗余信息，dex工具会去除冗余信息(多个class中的字符串常量合并为一个，比如对于Ljava/lang/Oject字符常量，每个class文件基本都有该字符常量，存在很大的冗余)，并把所有的.class文件整合到.dex文件中。减少了I/O操作，提高了类的查找速度。</li>
</ul>
</li>
<li><p>许多GC实现都是在对象开头的地方留一小块空间给GC标记用。Dalvik VM则不同，在进行GC的时候会单独申请一块空间，以位图的形式来保存整个堆上的对象的标记，在GC结束后就释放该空间。 （关于这一点后面的Dalvik垃圾回收机制还会更加深入的介绍）</p>
</li>
<li>dvm是基于寄存器的虚拟机 而jvm执行是基于虚拟栈的虚拟机。这类的不同是最要命的，因为它将导致一系列的问题，具体如下：<ul>
<li>dvm速度快！寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。JAVA虚拟机基于栈结构，程序在运行时虚拟机需要频繁的从栈上读取写入数据，这个过程需要更多的指令分派与内存访问次数，会耗费很多CPU时间。<ul>
<li>指令数小！dvm基于寄存器，所以它的指令是二地址和三地址混合，指令中指明了操作数的地址；jvm基于栈，它的指令是零地址，指令的操作数对象默认是操作数栈中的几个位置。这样带来的结果就是dvm的指令数相对于jvm的指令数会小很多，jvm需要多条指令而dvm可能只需要一条指令。 </li>
<li>jvm基于栈带来的好处是可以做的足够简单，真正的跨平台，保证在低硬件条件下能够正常运行。而dvm操作平台一般指明是ARM系统，所以采取的策略有所不同。需要注意的是dvm基于寄存器，但是这也是个映射关系，如果硬件没有足够的寄存器，dvm将多出来的寄存器映射到内存中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h3><p>谈到垃圾回收自然而然的想到了堆，Dalvik的堆结构相对于JVM的堆结构有所区别，这主要体现在Dalvik将堆分成了Active堆和Zygote堆，这里大家只要知道Zygote堆是Zygote进程在启动的时候预加载的类、资源和对象(具体gygote进程预加载了哪些类，详见文末的附录)，除此之外的所有对象都是存储在Active堆中的。对于为何要将堆分成gygote和Active堆，这主要是因为Android通过fork方法创建到一个新的gygote进程，为了尽可能的避免父进程和子进程之间的数据拷贝，fork方法使用写时拷贝技术，写时拷贝技术简单讲就是fork的时候不立即拷贝父进程的数据到子进程中，而是在子进程或者父进程对内存进行写操作时是才对内存内容进行复制，Dalvik的gygote堆存放的预加载的类都是Android核心类和java运行时库，这部分内容很少被修改，大多数情况父进程和子进程共享这块内存区域。通常垃圾回收重点对Active堆进行回收操作，Dalvik为了对堆进行更好的管理创建了一个Card Table、两个Heap Bitmap和一个Mark Stack数据结构。</p>
<ul>
<li><p>关于 Zygote,有一些参考资料<br><a href="https://www.cnblogs.com/bRAyKpoyNt/p/3649417.html" target="_blank" rel="external">ZYGOTE浅谈</a></p>
<h5 id="Dalvik创建对象流程"><a href="#Dalvik创建对象流程" class="headerlink" title="Dalvik创建对象流程"></a>Dalvik创建对象流程</h5><p>当Dalvik虚拟机的解释器遇到一个new指令时，它就会调用函数Object<em> dvmAllocObject(ClassObject</em> clazz, int flags)。期间完成的动作有( 注意：Java堆分配内存前后，要对Java堆进行加锁和解锁，避免多个线程同时对Java堆进行操作。下面所说的堆指的是Active堆)：</p>
<p>1.调用函数dvmHeapSourceAlloc在Java堆上分配指定大小的内存，成功则返回，否则下一步。<br>2.执行一次GC， GC执行完毕后，再次调用函数dvmHeapSourceAlloc在Java堆上分配指定大小的内存，成功则返回，否则下一步。<br>3.首先将堆的当前大小设置为Dalvik虚拟机启动时指定的Java堆最大值，然后进行内存分配，成功返回失败下一步。这里调用的函数是dvmHeapSourceAllocAndGrow<br>4.调用函数gcForMalloc来执行GC，这里的GC和第二步的GC，区别在于这里回收软引用对象引用的对象，如果还是失败抛出OOM异常。这里调用的函数是dvmHeapSourceAllocAndGrow</p>
</li>
</ul>
<h4 id="Dalvik回收对象流程"><a href="#Dalvik回收对象流程" class="headerlink" title="Dalvik回收对象流程"></a>Dalvik回收对象流程</h4><p>Dalvik的垃圾回收策略默认是标记擦除回收算法，即Mark和Sweep两个阶段。标记与清理的回收算法一个明显的区别就是会产生大量的垃圾碎片，因此程序中应该避免有大量不连续小碎片的时候分配大对象，同时为了解决碎片问题，Dalvik虚拟机通过使用dlmalloc技术解决，关于后者读者另行google。下面我们对Mark阶段进行简单介绍。</p>
<p>Mark阶段使用了两个Bitmap来描述堆的对象，一个称为Live Bitmap，另一个称为Mark Bitmap。Live Bitmap用来标记上一次GC时被引用的对象，也就是没有被回收的对象，而Mark Bitmap用来标记当前GC有被引用的对象。当Live Bitmap被标记为1，但是在Mark Bitmap中标记为0的对象表明该对象需要被回收。</p>
<p>此外在Mark阶段往往要求其它线程处于停止状态，因此Mark又分为并行和串行两种方式，并行的Mark分为两个阶段：1)、只标记gc_root对象，即在GC开始的瞬间被全局变量、栈变量、寄存器等所引用的对象，该阶段不允许垃圾回收线程之外的线程处于运行状态。2)、有条件的并行运行其它线程，使用Card<br> Table记录在垃圾收集过程中对象的引用情况。整个Mark 阶段都是通过Mark Stack来实现递归检查被引用的对象，即在当前GC中存活的对象。标记过程类似用一个栈把第一阶段得到的gc_root放入栈底，然后依次遍历它们所引用的对象(通过出栈入栈)，即用栈数据结构实现了对每个gc_root的递归。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 daidai
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>