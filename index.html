<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="daidai" />


    
    


<meta name="description" content="喜欢探索未知,保持好奇心">
<meta property="og:type" content="website">
<meta property="og:title" content="T9&#39;S Develop Blog">
<meta property="og:url" content="http://outofmemory.top/index.html">
<meta property="og:site_name" content="T9&#39;S Develop Blog">
<meta property="og:description" content="喜欢探索未知,保持好奇心">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="T9&#39;S Develop Blog">
<meta name="twitter:description" content="喜欢探索未知,保持好奇心">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="T9&#39;S Develop Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="https://s1.ax1x.com/2018/10/12/iNnhCV.gif">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>T9&#39;S Develop Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://s1.ax1x.com/2018/10/12/iNnhCV.gif" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">daidai</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不仅有工作，更有生活</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://daidazhao@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/dazhaoDai" title="GitHub"></a>
                            
                                <a class="fa CSDN" href="https://blog.csdn.net/dazhaoDai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android官方架构/">Android官方架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进阶/">Android进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git分支操作/">Git分支操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java进阶/">Java进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin学习/">Kotlin学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin开发/">Kotlin开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-aidl/">android aidl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-permission/">android permission</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-view/">android view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-开发错误/">android 开发错误</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-权限/">android 权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-自定义view/">android 自定义view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android触摸事件/">android触摸事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/privacy/">privacy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Developer</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">daidai</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://s1.ax1x.com/2018/10/12/iNnhCV.gif" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">daidai</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不仅有工作，更有生活</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://daidazhao@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/dazhaoDai" title="GitHub"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://blog.csdn.net/dazhaoDai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Java进阶 ——— Java多线程（4）之多线程局部变量" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/05/Java进阶 ——— Java多线程（4）之多线程局部变量/" class="article-date">
      <time datetime="2019-01-05T06:44:38.862Z" itemprop="datePublished">2019-01-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/05/Java进阶 ——— Java多线程（4）之多线程局部变量/">Java进阶 ——— Java多线程（4）之多线程局部变量TreadLocal</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在了解ThreadLocal之前，一定要确定一个概念：<strong>ThreadLocal不是用来解决共享对象的多线程访问问题的</strong><br>那么ThreadLocal在多线程的作用是什么呢？从下面几个方面来了解</p>
<h3 id="ThreadLocal的作用"><a href="#ThreadLocal的作用" class="headerlink" title="ThreadLocal的作用"></a>ThreadLocal的作用</h3><p>ThreadLocal可以理解为：线程局部变量， 是每一个线程所单独持有的。其他线程不能对其进行访问， 通常是类中的 private static 字段,是对该字段初始值的一个拷贝，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联，</p>
<p>在并发编程的时候，成员变量如果不做任何处理其实是线程不安全的，各个线程都在操作同一个变量，显然是不行的，并且我们也知道volatile这个关键字也是不能保证线程安全的。当然我们可以使用synchorinized 关键字来为此变量加锁，进行同步处理，从而限制只能有一个线程来使用此变量，但是加锁会大大影响程序执行效率，此外我们还可以使用ThreadLocal来解决对某一个变量的访问冲突问题。</p>
<p>当使用ThreadLocal维护变量的时候 为每一个使用该变量的线程提供一个独立的变量副本，即每个线程内部都会有一个该变量，这样同时多个线程访问该变量并不会彼此相互影响，因此他们使用的都是自己从内存中拷贝过来的变量的副本， 这样就不存在线程安全问题，也不会影响程序的执行性能。</p>
<h3 id="深入了解ThreadLocal使用"><a href="#深入了解ThreadLocal使用" class="headerlink" title="深入了解ThreadLocal使用"></a>深入了解ThreadLocal使用</h3><p>先不去分析源码，仅仅写个例子，根据例子学习ThreadLocal的简单使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ThreadTest &#123;</div><div class="line">  //定义一个全局ThreadLocal</div><div class="line">	public static ThreadLocal&lt;String&gt; locals= new ThreadLocal&lt;String&gt;();</div><div class="line">  </div><div class="line">  //开启三个线程</div><div class="line">	public void threadLocalTest()&#123;</div><div class="line">		ThreadLocalTest test1 = new ThreadLocalTest(&quot;AA&quot;);</div><div class="line">		ThreadLocalTest test2 = new ThreadLocalTest(&quot;BB&quot;);</div><div class="line">		ThreadLocalTest test3 = new ThreadLocalTest(&quot;CC&quot;);</div><div class="line">		test1.start();</div><div class="line">		test2.start();</div><div class="line">		test3.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在线程里往ThreadLocal塞值，再打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalTest extends Thread &#123;</div><div class="line"></div><div class="line">	private int a = 5;</div><div class="line"></div><div class="line">	public ThreadLocalTest(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		super.run();</div><div class="line">		try &#123;</div><div class="line">			for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">				a += 1;</div><div class="line">				ThreadTest.locals.set(a + &quot;&quot;);</div><div class="line">				Log.e(this.getName(), &quot;value ===== &quot; + ThreadTest.locals.get());</div><div class="line">				Thread.sleep(300);</div><div class="line">			&#125;</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">10-24 10:31:46.340 9307-9350/com.t9.news E/AA: value ===== 6</div><div class="line">10-24 10:31:46.340 9307-9351/com.t9.news E/BB: value ===== 6</div><div class="line">10-24 10:31:46.343 9307-9352/com.t9.news E/CC: value ===== 6</div><div class="line">10-24 10:31:46.640 9307-9350/com.t9.news E/AA: value ===== 7</div><div class="line">10-24 10:31:46.641 9307-9351/com.t9.news E/BB: value ===== 7</div><div class="line">10-24 10:31:46.644 9307-9352/com.t9.news E/CC: value ===== 7</div><div class="line">10-24 10:31:46.940 9307-9350/com.t9.news E/AA: value ===== 8</div><div class="line">10-24 10:31:46.941 9307-9351/com.t9.news E/BB: value ===== 8</div><div class="line">10-24 10:31:46.944 9307-9352/com.t9.news E/CC: value ===== 8</div><div class="line">10-24 10:31:47.240 9307-9350/com.t9.news E/AA: value ===== 9</div><div class="line">10-24 10:31:47.241 9307-9351/com.t9.news E/BB: value ===== 9</div><div class="line">10-24 10:31:47.244 9307-9352/com.t9.news E/CC: value ===== 9</div><div class="line">10-24 10:31:47.540 9307-9350/com.t9.news E/AA: value ===== 10</div><div class="line">10-24 10:31:47.541 9307-9351/com.t9.news E/BB: value ===== 10</div><div class="line">10-24 10:31:47.545 9307-9352/com.t9.news E/CC: value ===== 10</div></pre></td></tr></table></figure></p>
<p>看到每个线程的里都有自己的String，并且互不影响—-,不存在一个线程修改另一个线程中值得情况，<strong>对于同一个ThreadLocal对象而言，内部数据仅为自己独有，其他线程无法修改</strong></p>
<h3 id="ThreadLocal的理解"><a href="#ThreadLocal的理解" class="headerlink" title="ThreadLocal的理解"></a>ThreadLocal的理解</h3><p>了解了ThreadLocal的使用，接下来肯定要看看源码，分析内部实现方式。</p>
<p>就从ThreadLocal 几个主要方法来学习<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public T get()</div><div class="line">public void set(T value) </div><div class="line">public void remove()</div></pre></td></tr></table></figure></p>
<p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本</p>
<p>首先我们来看一下ThreadLocal类是如何为每个线程创建一个变量的副本的。</p>
<h4 id="先来看get方法："><a href="#先来看get方法：" class="headerlink" title="先来看get方法："></a>先来看get方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Returns the value in the current thread&apos;s copy of this</div><div class="line">    * thread-local variable.  If the variable has no value for the</div><div class="line">    * current thread, it is first initialized to the value returned</div><div class="line">    * by an invocation of the &#123;@link #initialValue&#125; method.</div><div class="line">    *</div><div class="line">    * @return the current thread&apos;s value of this thread-local</div><div class="line">    */</div><div class="line">   public T get() &#123;</div><div class="line">       //先获取当前线程</div><div class="line">       Thread t = Thread.currentThread();</div><div class="line">       //然后getMap(t)方法获取到一个map，类型为ThreadLocalMap</div><div class="line">       ThreadLocalMap map = getMap(t);</div><div class="line">       //不为空</div><div class="line">       if (map != null) &#123;</div><div class="line">       //然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是  this，而不是当前线程t。</div><div class="line">           ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">           if (e != null) &#123;</div><div class="line">           //如果获取成功，则返回value值</div><div class="line">               @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">               T result = (T)e.value;</div><div class="line">               return result;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       //否则调用setInitialValue方法返回value</div><div class="line">       return setInitialValue();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>仔细看看每一步的操作：</p>
<ul>
<li>getMap(t)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Get the map associated with a ThreadLocal. Overridden in</div><div class="line">     * InheritableThreadLocal.</div><div class="line">     *</div><div class="line">     * @param  t the current thread</div><div class="line">     * @return the map</div><div class="line">     */</div><div class="line">    ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    //返回当前线程中的成员变量threadLocals</div><div class="line">        return t.threadLocals;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>那么继续查看，进入Thread.class ，成员变量threadLocals是什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</div><div class="line">     * by the ThreadLocal class. */</div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</div></pre></td></tr></table></figure></p>
<p>ThreadLocalMap是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static class ThreadLocalMap &#123;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * The entries in this hash map extend WeakReference, using</div><div class="line">         * its main ref field as the key (which is always a</div><div class="line">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">         * == null) mean that the key is no longer referenced, so the</div><div class="line">         * entry can be expunged from table.  Such entries are referred to</div><div class="line">         * as &quot;stale entries&quot; in the code that follows.</div><div class="line">         */</div><div class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</div><div class="line">            /** The value associated with this ThreadLocal. */</div><div class="line">            Object value;</div><div class="line"></div><div class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">                super(k);</div><div class="line">                value = v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值</p>
<p>如果getMap为null,则返回setInitialValue()</p>
<ul>
<li><p>setInitialValue()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Variant of set() to establish initialValue. Used instead</div><div class="line"> * of set() in case user has overridden the set() method.</div><div class="line"> *</div><div class="line"> * @return the initial value</div><div class="line"> */</div><div class="line">private T setInitialValue() &#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    //就是如果map不为空，就设置键值对，</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">    //为空，再创建Map</div><div class="line">        createMap(t, value);</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>createMap(t, value)的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Create the map associated with a ThreadLocal. Overridden in</div><div class="line"> * InheritableThreadLocal.</div><div class="line"> *</div><div class="line"> * @param t the current thread</div><div class="line"> * @param firstValue value for the initial entry of the map</div><div class="line"> */</div><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>创建ThreadLocalMap对象并赋值给Thread中的threadLocals</p>
<p>经过这一系列流程，ThreadLocal是为每个线程创建变量的副本就很清晰：</p>
<ul>
<li><p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
</li>
<li><p>初始化Thread时，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
</li>
<li>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1。每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。<br>2。将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦<br>3.通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中<br>4.为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量<br>5.在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。<br>因为get方法中，getMap()默认为null，则返回setInitialValue(),setInitialValue()方法中， T value = initialValue() 默认返回null，最终会报空指针异常</p>
<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920407.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java进阶 ——— Java多线程（三）之多线程同步问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/18/Java进阶 ——— Java多线程（三）之多线程同步问题/" class="article-date">
      <time datetime="2018-10-18T15:06:53.581Z" itemprop="datePublished">2018-10-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/18/Java进阶 ——— Java多线程（三）之多线程同步问题/">Java进阶 ——— Java多线程（三）之多线程同步问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>接上一篇，<a href="https://blog.csdn.net/dazhaoDai/article/details/83120326" target="_blank" rel="external">Java进阶 ——— Java多线程（二）之如何开启多线程</a><br>介绍了Java多线程的开启方法，但是多线程运行的安全问题，将是本篇的重点</p>
<p><strong>延伸阅读,Java多线程系列文章</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/dazhaoDai/article/details/83117618" target="_blank" rel="external">Java进阶 ——— Java多线程（一）之进程和线程</a><br><a href="https://blog.csdn.net/dazhaoDai/article/details/83120326" target="_blank" rel="external">Java进阶 ——— Java多线程（二）之如何开启多线程</a></p>
</blockquote>
<p>在第一篇文章中，提到要实现多线程安全，就要实现线程同步，那么线程同步有哪些方法呢？</p>
<p>介绍线程同步之前，先大概了解一下多线程的原理。</p>
<blockquote>
<p>线程的执行是CPU随机调度的，比如我们开启N个线程，这N个线程并不是同时执行的，而是CPU快速的在这N个线程之间切换执行，由于切换速度极快使我们感觉同时执行罢了。发生上面问题的本质就是<code>CPU对线程执行的随机调度</code>，比如A线程此时正在打印信息还没打印完毕此时CPU切换到B线程执行了，B线程执行完了又切换回A线程执行就会导致第一篇文章中打印错乱问题。</p>
</blockquote>
<p>线程同步问题往往发生在多个线程调用同一方法或者操作同一变量，但是我们要知道其本质就是CPU对线程的随机调度，CPU无法保证一个线程执行完其逻辑才去调用另一个线程执行。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>所以解决线程同步的思路就是：保证一个线程在执行方法的时候如果没执行完那么另一个线程不能执行此方法，换句话说就是只能等待别的线程执行完毕才能执行，确保数据在任何时刻只有一个线程可以操作，保证数据完整性</p>
<p>为了解决线程同步问题，引入<code>锁</code>的概念</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized同步有两种方式，同步代码块和同步方法</p>
<h5 id="synchronized-同步方法"><a href="#synchronized-同步方法" class="headerlink" title="synchronized 同步方法"></a>synchronized 同步方法</h5><p>在方法上加上synchronized关键字，实际上锁的是this，即当前类对象,<br>如下列代码，例如外部要调用run方法，则需要创建ThreadRunnable对象实例，此时添加在run方法上的锁，实际是对实例对象加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class  ThreadRunnable implements Runnable &#123;</div><div class="line">		@Override</div><div class="line">		public synchronized void run() &#123;</div><div class="line">				age++;</div><div class="line">				System.out.println(Thread.currentThread().getName() + &quot;----&quot; + age);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="synchronized-同步代码块"><a href="#synchronized-同步代码块" class="headerlink" title="synchronized 同步代码块"></a>synchronized 同步代码块</h5><p>同步代码块写法：synchronized(obj){}，其中obj为锁对象，此处我们传入this，同样方法的锁也为当前对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class  ThreadRunnable implements Runnable &#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		synchronized (this)&#123;  //对代码块添加锁，保证线程同步</div><div class="line">			age++;</div><div class="line">			System.out.println(Thread.currentThread().getName() + &quot;----&quot; + age);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="synchronized-修饰静态类或静态方法"><a href="#synchronized-修饰静态类或静态方法" class="headerlink" title="synchronized 修饰静态类或静态方法"></a>synchronized 修饰静态类或静态方法</h5><p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static int count = 0;</div><div class="line">public synchronized static void staticMethod()&#123;</div><div class="line">	for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">		count++;</div><div class="line">		System.out.println(count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="synchronized修饰一个类"><a href="#synchronized修饰一个类" class="headerlink" title="synchronized修饰一个类"></a>synchronized修饰一个类</h5><p>synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class  ThreadRunnable implements Runnable &#123;</div><div class="line">	int a = 0;</div><div class="line">	@Override</div><div class="line">	public synchronized void run() &#123;</div><div class="line">		synchronized (ThreadRunnable.class)&#123;</div><div class="line">			a++;</div><div class="line">			System.out.println(Thread.currentThread().getName() + &quot;----&quot; + a);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>synchronized总结：</strong></p>
<ul>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。</li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁（接下来会将到死锁的形成和解决方式），所以尽量避免无谓的同步控制。<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4>Lock与synchronized有什么区别呢？Lock是在Java1.6被引入进来的，Lock的引入让锁有了可操作性，<br>可操作性：就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷。</li>
</ul>
<p>Lock接口的实现子类之一ReentrantLock，翻译过来就是重入锁，就是支持重新进入的锁，该锁能够支持一个线程对资源的重复加锁，也就是说在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞，同时还支持获取锁的公平性和非公平性，所谓公平性就是多个线程发起lock()请求，先发起的线程优先获取执行权，非公平性就是获取锁与是否优先发起lock()操作无关。默认情况下是不公平的锁，为什么要这样设计呢？现实生活中我们都希望公平的啊？我们想一下，现实生活中要保证公平就必须额外开销，比如地铁站保证有序公平进站就必须配备额外人员维持秩序，程序中也是一样保证公平就必须需要额外开销，这样性能就下降了，所以公平与性能是有一定矛盾的，除非公平策略对你的程序很重要，比如必须按照顺序执行线程，否则还是使用不公平锁为好。</p>
<p>先通过代码了解 Lock的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class ThreadTest &#123;</div><div class="line"></div><div class="line">	private ReentrantLock lock = new ReentrantLock();</div><div class="line">	public void threadTest() &#123;</div><div class="line"></div><div class="line">		ThreadRunnable runnable = new ThreadRunnable();</div><div class="line">		Thread thread = new Thread();</div><div class="line">		Thread thread1 = new Thread(runnable);</div><div class="line">		Thread thread2 = new Thread(runnable);</div><div class="line">		Thread thread3 = new Thread(runnable);</div><div class="line">		Thread thread4 = new Thread(runnable);</div><div class="line">		Thread thread5 = new Thread(runnable);</div><div class="line">		Thread thread6 = new Thread(runnable);</div><div class="line">		Thread thread7 = new Thread(runnable);</div><div class="line">		thread.start();</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">		thread3.start();</div><div class="line">		thread4.start();</div><div class="line">		thread5.start();</div><div class="line">		thread6.start();</div><div class="line">		thread7.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	class  ThreadRunnable implements Runnable &#123;</div><div class="line">		int a = 0;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			lock.lock(); // 获取锁对象</div><div class="line">			try &#123;</div><div class="line">				a++;</div><div class="line">				System.out.println(Thread.currentThread().getName() + &quot;----&quot; + a);</div><div class="line">			&#125; finally &#123;</div><div class="line">        //为了防止我们代码出现异常，所以我们的释放锁操作放在finally中，因为finally中的代码无论如何都是会执行的</div><div class="line">				lock.unlock(); //释放锁对象</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看一下运行结果，程序执行是没有问题的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">10-18 14:40:33.985 2847-3642/com.t9.news I/System.out: Thread-14----1</div><div class="line">10-18 14:40:33.987 2847-3641/com.t9.news I/System.out: Thread-13----2</div><div class="line">10-18 14:40:33.990 2847-3643/com.t9.news I/System.out: Thread-15----3</div><div class="line">10-18 14:40:33.994 2847-3645/com.t9.news I/System.out: Thread-17----4</div><div class="line">10-18 14:40:33.995 2847-3640/com.t9.news I/System.out: Thread-12----5</div><div class="line">10-18 14:40:33.997 2847-3639/com.t9.news I/System.out: Thread-11----6</div><div class="line">10-18 14:40:33.998 2847-3644/com.t9.news I/System.out: Thread-16----7</div></pre></td></tr></table></figure></p>
<p>其实在Lock还有几种获取锁的方式，我们这里再说一种就是tryLock()这个方法跟Lock()是有区别的，Lock在获取锁的时候如果拿不到锁就一直处于等待状态，直到拿到锁，但是tryLock()却不是这样的，tryLock是有一个Boolean的返回值的，如果没有拿到锁直接返回false，停止等待，它不会像Lock()那样去一直等待获取锁。</p>
<p>修改代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class  ThreadRunnable implements Runnable &#123;</div><div class="line">		int a = 0;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			if (lock.tryLock())&#123; //获取锁对象</div><div class="line">				try &#123;</div><div class="line">					a++;</div><div class="line">					System.out.println(Thread.currentThread().getName() + &quot;----&quot; + a);</div><div class="line">				&#125; finally &#123;</div><div class="line">					lock.unlock(); //释放锁对象</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，查看结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-18 14:43:21.365 3846-3867/com.t9.news I/System.out: Thread-5----1</div><div class="line">10-18 14:43:21.368 3846-3866/com.t9.news I/System.out: Thread-4----2</div><div class="line">10-18 14:43:21.370 3846-3870/com.t9.news I/System.out: Thread-8----3</div><div class="line">10-18 14:43:21.374 3846-3869/com.t9.news I/System.out: Thread-7----4</div><div class="line">10-18 14:43:21.375 3846-3871/com.t9.news I/System.out: Thread-9----5</div></pre></td></tr></table></figure></p>
<p>很明显，有三个线程没有获取到锁对象，这时候就不等待了。那么这种方法肯定不完美，想让所有线程获取对象，但是线程发现获取不到就放弃了，<br>其实tryLock()方法还可以设置获取的等待时长。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">	class ThreadRunnable implements Runnable &#123;</div><div class="line">		int a = 0;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			try &#123;</div><div class="line">				// 如果5秒内获取不到锁对象，那就不再等待</div><div class="line">				if (lock.tryLock(5, TimeUnit.SECONDS)) &#123; </div><div class="line">					try &#123;</div><div class="line">						a++;</div><div class="line">						System.out.println(Thread.currentThread().getName() + &quot;----&quot; + a);</div><div class="line">					&#125; finally &#123;</div><div class="line">						lock.unlock(); //释放锁对象</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看结果：所有线程都获取到锁对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">10-18 14:50:48.466 4031-4053/com.t9.news I/System.out: Thread-5----1</div><div class="line">10-18 14:50:48.466 4031-4057/com.t9.news I/System.out: Thread-9----2</div><div class="line">10-18 14:50:48.470 4031-4056/com.t9.news I/System.out: Thread-8----3</div><div class="line">10-18 14:50:48.473 4031-4054/com.t9.news I/System.out: Thread-6----4</div><div class="line">10-18 14:50:48.476 4031-4055/com.t9.news I/System.out: Thread-7----5</div><div class="line">10-18 14:50:48.477 4031-4052/com.t9.news I/System.out: Thread-4----6</div><div class="line">10-18 14:50:48.481 4031-4051/com.t9.news I/System.out: Thread-3----7</div></pre></td></tr></table></figure></p>
<h4 id="Lock与synchronized同步方式优缺点"><a href="#Lock与synchronized同步方式优缺点" class="headerlink" title="Lock与synchronized同步方式优缺点"></a>Lock与synchronized同步方式优缺点</h4><ul>
<li><p>实现<br>Lock 的锁定是通过代码实现的，而 synchronized 是在 JVM 层面上实现的(所有对象都自动含有单一的锁。JVM负责跟踪对象被加锁的次数。如果一个对象被解锁，其计数变为0。在线程第一次给对象加锁的时候，计数变为1。每当这个相同的线程在此对象上获得锁时，计数会递增。只有首先获得锁的线程才能继续获取该对象上的多个锁。每当线程离开一个synchronized方法，计数递减，当计数为0的时候，锁被完全释放，此时别的线程就可以使用此资源)。</p>
</li>
<li><p>释放<br>synchronized 在锁定时如果方法块抛出异常，JVM 会自动将锁释放掉，不会因为出了异常没有释放锁造成线程死锁。但是 Lock 的话就享受不到 JVM 带来自动的功能，出现异常时必须在 finally 将锁释放掉，否则将会引起死锁。</p>
</li>
<li><p>资源<br>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronized，另外可读性非常好。在资源竞争激烈情况下，Lock同步机制性能会更好一些。</p>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4></li>
</ul>
<hr>
<p><a href="https://www.cnblogs.com/leipDao/p/8295766.html" target="_blank" rel="external">https://www.cnblogs.com/leipDao/p/8295766.html</a><br><a href="http://www.importnew.com/21866.html" target="_blank" rel="external">http://www.importnew.com/21866.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java进阶 ——— Java多线程（二）之如何开启多线程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/18/Java进阶 ——— Java多线程（二）之如何开启多线程/" class="article-date">
      <time datetime="2018-10-17T16:35:52.624Z" itemprop="datePublished">2018-10-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/18/Java进阶 ——— Java多线程（二）之如何开启多线程/">Java进阶 ——— Java多线程（二）之如何开启多线程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>第一篇文章讲到了Java多线程的概念和作用，本篇文章则介绍在Java中如何开启多线程。</p>
<p><strong>延伸阅读,Java多线程系列文章</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/dazhaoDai/article/details/83117618" target="_blank" rel="external">Java进阶 ——— Java多线程（一）之进程和线程</a><br><a href="https://blog.csdn.net/dazhaoDai/article/details/83120326" target="_blank" rel="external">Java进阶 ——— Java多线程（二）之如何开启多线程</a></p>
<h3 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h3><p>Java开启多线程有三种方式</p>
</blockquote>
<p><a href="#1">继承Thread类</a><br><a href="#2">实现Runnable接口</a><br><a href="#3">java.util.concurrent.ThreadFactory 中的线程创建
</a></p>
<h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title=" 继承Thread类 "></a><span id="1"> 继承Thread类 </span></h4><ul>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务。因此把run方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。<code>切记是调用start()方法</code><br>示例代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ThreadTest &#123;</div><div class="line"></div><div class="line">	private int age = 10;</div><div class="line">	public  void threadTest()&#123;</div><div class="line">		</div><div class="line">		for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">			Thread thread =	new NewThread();</div><div class="line">			thread.start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class NewThread extends Thread&#123;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			age++;</div><div class="line">			System.out.println(age);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>输出日志<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fwbo6oihpzj20s80agdjj.jpg" alt=""></p>
<p><strong>注意</strong><br>通过下列匿名内部类的方式也可以开启多线程，本质也是实现了Runnable接口，并作为参数传递给Thread类，但是<code>不推荐</code>这样实现，因为在Android中，例如在Activity中使用匿名内部类方式，匿名内部类会持有外部类的引用，在Activity销毁时，如果线程执行未结束，导致Activity占用内存无法释放，造成内存泄漏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">  * 避免这种方式</div><div class="line">  /</div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">			</div><div class="line">			public void run() &#123;</div><div class="line">				//执行体</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div></pre></td></tr></table></figure></p>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title=" 实现Runnable接口 "></a><span id="2"> 实现Runnable接口 </span></h4><ul>
<li>定义Runnable接口的实现类，并重写该接口的run方法，该run方法的方法体同样是该线程的线程执行体</li>
<li>创建Runnable实现类的实例对象，并以此实例对象作为Thread的target来创建Thread类，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。<code>切记是调用start()方法</code><br>示例代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ThreadTest &#123;</div><div class="line"></div><div class="line">	private int age = 10;</div><div class="line">	public  void threadTest()&#123;</div><div class="line">        //实际的线程依然需要Thread实例对象，Thread才真正创建线程对象</div><div class="line">		for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">			Thread thread =	new Thread(new ThreadRunnable());</div><div class="line">			thread.start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class ThreadRunnable implements Runnable &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			age++;</div><div class="line">			System.out.println(Thread.currentThread().getName() +&quot;----&quot;+ age);		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>注意</strong><br>Runable实现类里包含run方法，仅仅作为线程执行体，而实际的线程对象依然是Thread实例对象，Thread为真正创建线程的对象。</p>
</blockquote>
<h5 id="实现Runnable接口比继承Thread类所具有的优势："><a href="#实现Runnable接口比继承Thread类所具有的优势：" class="headerlink" title="实现Runnable接口比继承Thread类所具有的优势："></a>实现Runnable接口比继承Thread类所具有的优势：</h5><ul>
<li>因为Java不支持多继承，但可以多实现，所以实现Runnable接口可以有效避免Java中单继承的限制。</li>
<li>线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</li>
<li>Java推荐使用组合而不是继承</li>
</ul>
<h4 id="java-util-concurrent-ThreadFactory-中的线程创建"><a href="#java-util-concurrent-ThreadFactory-中的线程创建" class="headerlink" title=" java.util.concurrent.ThreadFactory 中的线程创建"></a><span id="3"> java.util.concurrent.ThreadFactory 中的线程创建</span></h4><p>java.util.concurrent 包中包含一个将线程创建抽象化的ThreadFactory 接口。利用该接口，我们可以将以Runnable 作为传入参数并通过new 创建Thread 实例的处理隐藏在ThreadFactory 内部。典型用法如下所示。默认的ThreadFactory 对象是通过Executors.defaultThreadFactory 方法获取的。</p>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public  void threadTest()&#123;</div><div class="line"></div><div class="line">		for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">			ThreadFactory factory = Executors.defaultThreadFactory();</div><div class="line">            //此处的ThradRunnable是第二种方式中实现Runnable接口的类</div><div class="line">			factory.newThread(new ThreadRunnable()).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面罗列了三种启动多线程的方式，包括继承Thread类，实现Runnable接口，使用ThreadFactory线程创建，推荐使用第二种，毕竟组合优于继承</p>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><p><a href="http://www.cnblogs.com/albertrui/p/8376790.html" target="_blank" rel="external">http://www.cnblogs.com/albertrui/p/8376790.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java进阶 ——— Java多线程（一）之进程和线程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/17/Java进阶 ——— Java多线程（一）之进程和线程/" class="article-date">
      <time datetime="2018-10-17T12:58:20.298Z" itemprop="datePublished">2018-10-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/17/Java进阶 ——— Java多线程（一）之进程和线程/">Java进阶 ——— Java多线程（一）之进程和线程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>讲到线程，不可避免的提到进程。而因为线程无法脱离进程单独存在，那什么是进程？<br> <strong>延伸阅读,Java多线程系列文章</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/dazhaoDai/article/details/83117618" target="_blank" rel="external">Java进阶 ——— Java多线程（一）之进程和线程</a><br><a href="https://blog.csdn.net/dazhaoDai/article/details/83120326" target="_blank" rel="external">Java进阶 ——— Java多线程（二）之如何开启多线程</a></p>
<h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h3><p>进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的最小单位。<br>例如手机运行的众多APP，每个可以理解为一个进程（实际上很多APP运行多个进程），每个APP直接互相独立，互不干扰。</p>
</blockquote>
<h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程：进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。也就是程序执行的最小单位。<br>例如优酷APP，我们看视频的同时还可以缓存视频。看视频和缓存视频就是运行在进程中的两个线程。</p>
<h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><p>进程是一个独立的空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<ul>
<li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<blockquote>
<p>举个不太准确的例子<br>北京火车站负责北京到上海的铁路运输管理。北京火车站就是一个进程。这个进程负责整个线路的调度和分配。而北京到上海的线路，就是线程。这个线程是真正负责运送旅客和货物。</p>
</blockquote>
</li>
</ul>
<h3 id="为什么要多线程？"><a href="#为什么要多线程？" class="headerlink" title="为什么要多线程？"></a>为什么要多线程？</h3><p>现在要从北京运送大量旅客到上海，要在一天全部运送。如果只有一个线路，一辆火车去运送，那肯定是搞不定的，旅客在北京等的都疯了。</p>
<h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><p>那么是不是我可以加开多辆火车？然后依次送到上海？理论上是可以的。这种在一条线路上，所有火车依次行驶，就是<code>串行</code>，火车1、火车2、火车3依次行驶。只有火车1开动，火车2才能行驶。<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fwbf8yro3lj20uy0f6dga.jpg" alt=""><br>那如果这个时候火车1出现故障，无法前进，该怎么办呢？或者铁路上只能同时开10辆火车，但是依然承载不了这么多旅客，一天时间还是运送不完？</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>既然一条线路运送不了，那我开五条线路，每个线路都可以承载10辆火车，五个线路同时运行。不就可以满足了吗？<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fwbgrnwhkqj20vq0nkabn.jpg" alt=""><br>像上面这样，在一个进程中开启多个线程运行某个任务，就是多线程模式，多个线程同时运行，称为<code>并行</code></p>
<h3 id="如何开启多线程？"><a href="#如何开启多线程？" class="headerlink" title="如何开启多线程？"></a>如何开启多线程？</h3><p>既然要开启多线程，该如何开启多线程呢？<br>在本篇文章，介绍了如何开启多线程<a href="https://blog.csdn.net/dazhaoDai/article/details/83120326" target="_blank" rel="external">Java进阶 ——— Java多线程（二）之如何开启多线程</a></p>
<h3 id="多线程的安全问题"><a href="#多线程的安全问题" class="headerlink" title="多线程的安全问题"></a>多线程的安全问题</h3><p>像上面这样，开启多个线程，同时运行，理论上是非常完美的解决办法。但是这个时候就会出现多线程的安全问题。</p>
<blockquote>
<p>但是这时候每个线程接到通知：在天津站有也有不定量的旅客要乘车去上海。<br>1.第一条线路的第一辆火车到达天津，如果旅客全部上车了，后面的火车或者其他线路的火车不知道，到了天津站也停了，发现旅客全部上车走了…..<br>2.如果需要三辆火车才能接走全部天津站的旅客，那到底哪几条线路的哪几趟火车到天津站停车呢？<br>3.如果三辆车同时接近天津站，但是天津站站台每次只能停一辆火车，那谁先进站呢？</p>
</blockquote>
<p>当然，这是假想的问题，实际开发工作中，多线程的问题远不止这些，下面用代码来演示多线程的安全问题。<br>开启100个线程同时修改成员变量age，并打印值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ThreadTest &#123;</div><div class="line"></div><div class="line">	private int age = 10;</div><div class="line">	public  void threadTest()&#123;</div><div class="line"></div><div class="line">		for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">			Thread thread =	new Thread(new ThreadRunnable());</div><div class="line">			thread.start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	class ThreadRunnable implements Runnable &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			age++;</div><div class="line">			System.out.println(age);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>理想状态下，应该是线程依次增加age的值，从11增加到109。<br>来看下打印的结果<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fwbi32370uj20ia0ga43n.jpg" alt=""></p>
<p>很明显，这个方法中线程并不是安全的，出现这种的原因有很多，最常见的原因就是，当某个线程1刚修改age的值，正要打印age的值，这时另一个线程2、3进入，又修改了age的值，并且打印结束，这时线程1才打印出age的值。</p>
<h4 id="什么是线程安全呢？"><a href="#什么是线程安全呢？" class="headerlink" title="什么是线程安全呢？"></a>什么是线程安全呢？</h4><p>简单理解：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的</p>
<p>或者说：一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。<code>线程安全问题都是由全局变量及静态变量引起的</code></p>
<p>所以为了保证线程安全呢，就需要进行线程同步</p>
<h4 id="什么是线程同步？"><a href="#什么是线程同步？" class="headerlink" title="什么是线程同步？"></a>什么是线程同步？</h4><p>就是当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问</p>
<h4 id="如何实现线程同步？"><a href="#如何实现线程同步？" class="headerlink" title="如何实现线程同步？"></a>如何实现线程同步？</h4><p>那么如何实现线程同步问题呢？下一篇文章我们继续了解如何实现线程同步？Java提供了哪些方式实现线程同步？</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>本篇文章主要通过例子讲解什么是进程和线程，什么是多线程，什么是线程安全，什么是线程同步问题</p>
<h5 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h5><hr>
<p><a href="https://www.cnblogs.com/lgk8023/p/6430592.html" target="_blank" rel="external">https://www.cnblogs.com/lgk8023/p/6430592.html</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0OTQ4NzY5NA==&amp;mid=2247484054&amp;idx=1&amp;sn=079565e4cda2298641f092f60033ace5&amp;chksm=e9918ab7dee603a173476c4cd4f44a570aa31009a34f79615ba1fc508828cc0b33748b08fa4b&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI0OTQ4NzY5NA==&amp;mid=2247484054&amp;idx=1&amp;sn=079565e4cda2298641f092f60033ace5&amp;chksm=e9918ab7dee603a173476c4cd4f44a570aa31009a34f79615ba1fc508828cc0b33748b08fa4b&amp;scene=21#wechat_redirect</a></p>
<p><a href="https://www.cnblogs.com/duende99/p/7047067.html" target="_blank" rel="external">https://www.cnblogs.com/duende99/p/7047067.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java进阶 ——— 局部内部类访问局部变量为什么必须加final关键字" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/16/Java进阶 ——— 局部内部类访问局部变量为什么必须加final关键字/" class="article-date">
      <time datetime="2018-10-16T12:48:48.149Z" itemprop="datePublished">2018-10-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/Java进阶 ——— 局部内部类访问局部变量为什么必须加final关键字/">Java进阶 ——— 局部内部类访问局部变量为什么必须加final关键字</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>在Java中，局部内部类如果调用了方法中的变量，那么该变量必须申明为final类型，如果不申明，则编译就会出错。</p>
<blockquote>
<p><code>这里的内部类指的是方法内部类或匿名内部类，不包含静态内部类和成员内部类</code></p>
</blockquote>
<p>这里通过一个例子类分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class InnerClass &#123;</div><div class="line">  </div><div class="line">	private int defaultAge = 5;</div><div class="line">  局部变量 age，必须添加final关键字，这里先不加</div><div class="line">	public void addAge( int age)&#123;</div><div class="line">  </div><div class="line">    //局部内部类</div><div class="line">		class NewAge&#123;</div><div class="line">			private int getAge()&#123;</div><div class="line">				return age + defaultAge;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		NewAge newAge = new NewAge();</div><div class="line">		System.out.print(newAge.getAge());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>强行不加final，编译，则会报错：</p>
<blockquote>
<p><code>Error:(16, 12) 错误: 从内部类中访问本地变量age; 需要被声明为最终类型</code></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4>1.<strong>生命周期不同</strong>： 为什么必须局部变量加final关键字呢？因为局部变量直接存储在栈中，当方法执行结束，非final的局部变量就被销毁，而局部内部类对局部变量的引用依然存在，当局部内部类要调用局部变量时，就会出错，出现非法引用。<code>简单来说，就是非final的局部变量的生命周期比局部内部类的生命周期短</code>，是不是直接可以拷贝变量到局部内部类？这样内部类中就可以使用而且不担心生命周期问题呢？也是不可以的，因为直接拷贝又会出现第二个问题，就是数据不同步<br>2.<strong>数据不同步</strong>：内部类并不是直接使用传递进来的参数，而是将传递进来的参数通过自己的构造器备份到自己内部，表面看是同一个变量，实际调用的是自己的属性而不是外部类方法的参数，如果在内部类中，修改了这些参数，并不会对外部变量产生影响，仅仅改变局部内部类中备份的参数。但是在外部调用时发现值并没有被修改，这种问题就会很尴尬，造成数据不同步。<code>所以使用final避免数据不同步的问题</code></li>
<li><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4>那为什么添加final修饰的局部变量，就可以被局部内部类引用呢？<br>若定义为final，则java编译器则会在内部类NewAge内生成一个外部变量的拷贝，而且可以既可以保证内部类可以引用外部属性，又能保证值的唯一性<br><code>也就是拷贝了一个变量的副本，提供给局部内部类,这个副本的生命周期和局部内部类一样长，并且这个副本不可以修改，保证了数据的同步</code><br><strong>注意</strong>：<code>在Java8 中，被局部内部类引用的局部变量，默认添加final，所以不需要添加final关键词</code></li>
</ul>
</blockquote>
<ul>
<li><h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4>如果有兴趣，可以看看编译后的字节码，即.class文件<blockquote>
<p>延伸 <a href="https://blog.csdn.net/dazhaoDai/article/details/83095602" target="_blank" rel="external"><br>如何查看Java字节码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class InnerClass$1NewAge &#123;</div><div class="line">    //可以看到，局部内部类中的使用的age，是通过构造函数传递进来，并不是直接引用外部变量。</div><div class="line">    InnerClass$1NewAge(InnerClass var1, int var2) &#123;</div><div class="line">        this.this$0 = var1;</div><div class="line">        this.val$age = var2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getAge() &#123;</div><div class="line">        return this.val$age + InnerClass.access$000(this.this$0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>InnerClass类编译后，在文件夹会出现InnerClass.class和InnerClass$1NewAge.class，这说明外部类的方法 和内部类处于同一级。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>局部内部类引用局部变量，不添加final，会出现生命周期不同，导致非法引用问题，而且直接拷贝会出现数据不同步问题，所以使用final，保证了合法引用，而且数据不可修改</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java进阶 ——— 如何查看字节码" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/16/Java进阶 ——— 如何查看字节码/" class="article-date">
      <time datetime="2018-10-16T12:48:33.139Z" itemprop="datePublished">2018-10-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/Java进阶 ——— 如何查看字节码/">Java进阶 ——— 如何查看字节码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>深入学习Java语言，也免不了要去研究JVM类加载、JVM字节码相关的东西，这时就需要经常查看字节码。 </p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="1-使用命令行"><a href="#1-使用命令行" class="headerlink" title="1.使用命令行"></a>1.使用命令行</h4><p>在编译后，进入字节码存放的文件夹，例如：FileA\Hello.class<br>使用命令行窗口<br><code>java -c FileA\Hello.class</code>，即可在窗口浏览字节码文件</p>
<h4 id="2-外接工具的方式"><a href="#2-外接工具的方式" class="headerlink" title="2.外接工具的方式"></a>2.外接工具的方式</h4><p>上面的描述编译成Hello.class文件（或者找到ide中相关out文件夹中的那些.class文件），然后下载Java Bytecode Editor，解压，直接运行jbe.sh即可看到UI面板，打开Hello.class文件即可看到类似下图的目录，将能看到非常丰富的类信息。<br><img src="http://ww1.sinaimg.cn/mw690/8f176eddly1fwa8trfn6oj20so0lon3c.jpg" alt=""></p>
<h4 id="3-使用AndroidStudio-内置插件"><a href="#3-使用AndroidStudio-内置插件" class="headerlink" title="3.使用AndroidStudio 内置插件"></a>3.使用AndroidStudio 内置插件</h4><p>在AndroidStudio 面板， AndroidStudio -&gt; Preferences -&gt; </p>
<p>Plugins -&gt;jclasslib Bytecode Viewer -&gt; Browse repositories -&gt; install -restore AndroidStudio，重启AndroidStudio后，在选中要查看的.java文件， View -&gt; Show bytecode with jclasslib，此时在ide的右边就会看到类似下图的界面，非常丰富的类信息<br><img src="http://ww1.sinaimg.cn/mw690/8f176eddly1fwa8yz8kmej20o00euwfx.jpg" alt=""></p>
<p>以上就是三种查看字节码的方法<br>参考：</p>
<hr>
<p><a href="https://blog.csdn.net/kwame211" target="_blank" rel="external">https://blog.csdn.net/kwame211</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java进阶 ——— 面试必备 Java单链表反转" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/15/Java进阶 ——— 面试必备 Java单链表反转/" class="article-date">
      <time datetime="2018-10-15T08:57:32.658Z" itemprop="datePublished">2018-10-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/Java进阶 ——— 面试必备 Java单链表反转/">Java进阶 ——— 面试必备 Java单链表反转</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>关于链表操作，基本面试都会考察，每次都是看了就懂，过后就忘。看了<br><a href="https://blog.csdn.net/guyuealian/article/details/51119499" target="_blank" rel="external">Java单链表反转</a>文章，分析的很清晰，很好理解。</p>
<h4 id="单链表的结点结构"><a href="#单链表的结点结构" class="headerlink" title="单链表的结点结构:　"></a>单链表的结点结构:　</h4><p><img src="http://ww1.sinaimg.cn/mw690/8f176eddly1fw8zo5ytg4j205k01wglr.jpg" alt=""></p>
<ul>
<li>data域：存储数据元素信息的域称为数据域；　</li>
<li>next域：存储直接后继位置的域称为指针域，它是存放结点的直接后继的地址（位置）的指针域（链域）。</li>
<li>data域+ next域：组成数据ai的存储映射，称为结点；</li>
<li>注意： <blockquote>
<p>①链表通过每个结点的链域将线性表的n个结点按其逻辑顺序链接在一起的。 　　</p>
<pre><code>②每个结点只有一个链域的链表称为单链表（Single Linked List）。
</code></pre><p>   所谓的链表就好像火车车厢一样，从火车头开始，每一节车厢之后都连着后一节车厢。</p>
</blockquote>
</li>
</ul>
<p>要实现单链表存储，首先是创建一结点类，其Java代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Node &#123;</div><div class="line">	private int Data;// 数据域</div><div class="line">	private Node Next;// 指针域</div><div class="line">	public Node(int Data) &#123;</div><div class="line">		// super();</div><div class="line">		this.Data = Data;</div><div class="line">	&#125;</div><div class="line">	public int getData() &#123;</div><div class="line">		return Data;</div><div class="line">	&#125;</div><div class="line">	public void setData(int Data) &#123;</div><div class="line">		this.Data = Data;</div><div class="line">	&#125;</div><div class="line"> </div><div class="line">	public Node getNext() &#123;</div><div class="line">		return Next;</div><div class="line">	&#125;</div><div class="line">	public void setNext(Node Next) &#123;</div><div class="line">		this.Next = Next;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="实现反转的方法："><a href="#实现反转的方法：" class="headerlink" title="实现反转的方法："></a>实现反转的方法：</h4><h5 id="递归反转法"><a href="#递归反转法" class="headerlink" title="递归反转法"></a>递归反转法</h5><p>在反转当前节点之前先反转后续节点。这样从头结点开始，层层深入直到尾结点才开始反转指针域的指向。简单的说就是从尾结点开始，逆向反转各个结点的指针域指向，其过程图如下所示：</p>
<ul>
<li>head：是前一结点的指针域（PS：前一结点的指针域指向当前结点）</li>
<li>head.getNext()：是当前结点的指针域（PS：当前结点的指针域指向下一结点）</li>
<li>reHead：是反转后新链表的头结点（即原来单链表的尾结点）</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/mw690/8f176eddly1fw8zp2l60bj21140p6q63.jpg" alt=""></p>
<p>Java代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class ReverseNode &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Node head = new Node(0);</div><div class="line">		Node node1 = new Node(1);</div><div class="line">		Node node2 = new Node(2);</div><div class="line">		Node node3 = new Node(3);</div><div class="line">		Node node4 = new Node(4);</div><div class="line">		Node node5 = new Node(5);</div><div class="line"></div><div class="line">		head.setNext(node1);</div><div class="line">		node1.setNext(node2);</div><div class="line">		node2.setNext(node3);</div><div class="line">		node3.setNext(node4);</div><div class="line">		node4.setNext(node5);</div><div class="line"></div><div class="line">		// 打印反转前的链表</div><div class="line">		Node h = head;</div><div class="line">		while (null != h) &#123;</div><div class="line">			System.out.print(h.getData() + &quot; &quot;);</div><div class="line">			h = h.getNext();</div><div class="line">		&#125;</div><div class="line">		// 调用反转方法</div><div class="line">		head = Reverse1(head);</div><div class="line"></div><div class="line">		System.out.println(&quot;\n**************************&quot;);</div><div class="line">		// 打印反转后的结果</div><div class="line">		while (null != head) &#123;</div><div class="line">			System.out.print(head.getData() + &quot; &quot;);</div><div class="line">			head = head.getNext();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 递归，在反转当前节点之前先反转后续节点</div><div class="line">	private static Node Reverse1(Node head) &#123;</div><div class="line">		// head看作是前一结点，head.getNext()是当前结点，reHead是反转后新链表的头结点</div><div class="line">		if(null == head || head.getNext() == null)&#123;</div><div class="line">			//若为空链，或尾节点，则直接返回</div><div class="line">			return head;</div><div class="line">		&#125;</div><div class="line">		//先反转后续节点</div><div class="line">		Node reHead = Reverse1(head.getNext());</div><div class="line">		head.getNext().setNext(head); //将当前节点的指针域指向上一节点</div><div class="line">		head.setNext(null); //前一节点的指针域改为null</div><div class="line">		return reHead;  //返回反转后的新链表的节点</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="遍历反转法："><a href="#遍历反转法：" class="headerlink" title="遍历反转法："></a>遍历反转法：</h5><p>递归反转法是从后往前逆序反转指针域的指向，而遍历反转法是从前往后反转各个结点的指针域的指向。<br>   基本思路是：将当前节点cur的下一个节点 cur.getNext()缓存到temp后，然后更改当前节点指针指向上一结点pre。也就是说在反转当前结点指针指向前，先把当前结点的指针域用tmp临时保存，以便下一次使用，其过程可表示如下：</p>
<ul>
<li>pre：上一结点</li>
<li>cur: 当前结点</li>
<li>tmp: 临时结点，用于保存当前结点的指针域（即下一结点）</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/mw690/8f176eddly1fw9047w6hmj210o0toads.jpg" alt=""></p>
<p>Java代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class ReverseNode &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Node head = new Node(0);</div><div class="line">		Node node1 = new Node(1);</div><div class="line">		Node node2 = new Node(2);</div><div class="line">		Node node3 = new Node(3);</div><div class="line">		Node node4 = new Node(4);</div><div class="line">		Node node5 = new Node(5);</div><div class="line"></div><div class="line">		head.setNext(node1);</div><div class="line">		node1.setNext(node2);</div><div class="line">		node2.setNext(node3);</div><div class="line">		node3.setNext(node4);</div><div class="line">		node4.setNext(node5);</div><div class="line"></div><div class="line">		// 打印反转前的链表</div><div class="line">		Node h = head;</div><div class="line">		while (null != h) &#123;</div><div class="line">			System.out.print(h.getData() + &quot; &quot;);</div><div class="line">			h = h.getNext();</div><div class="line">		&#125;</div><div class="line">		// 调用反转方法</div><div class="line">		head = Reverse2(head);</div><div class="line"></div><div class="line">		System.out.println(&quot;\n**************************&quot;);</div><div class="line">		// 打印反转后的结果</div><div class="line">		while (null != head) &#123;</div><div class="line">			System.out.print(head.getData() + &quot; &quot;);</div><div class="line">			head = head.getNext();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//遍历，将当前节点的下一个节点缓存后更改当前节点指针</div><div class="line">	private static Node Reverse2(Node head) &#123;</div><div class="line">		//若为空链，或尾节点，则直接返回</div><div class="line">		if(null == head )&#123;</div><div class="line">			return head;</div><div class="line">		&#125;</div><div class="line">		Node pre = head; //上一节点</div><div class="line">		Node cur = head.getNext(); //当前节点</div><div class="line">		Node temp; //临时节点，用于保存当前节点的指针域（即下一节点）</div><div class="line">		while (cur != null)&#123;  //如果为null，则是尾节点</div><div class="line">			temp = cur.getNext(); //下一节点</div><div class="line">			cur.setNext(pre); //将指针域指向上一节点</div><div class="line"></div><div class="line">			//节点继续向下移动</div><div class="line">			pre = cur;</div><div class="line">			cur = temp;</div><div class="line">		&#125;</div><div class="line">		head.setNext(null); //最后将原链表的头结点指针域设置为null，此时原链表的头结点为新链表的尾节点</div><div class="line">		//此时pre已经移动到原链表的尾节点，也是新链表的头结点。</div><div class="line">		return pre;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面就是两种方式反转单链表</p>
<ul>
<li>递归：先反转后续节点，再反转当前</li>
<li>遍历：更改当前节点的指针域，指向上一节点，遍历执行</li>
</ul>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><p>本文参考以下链接</p>
<hr>
<p><a href="https://blog.csdn.net/guyuealian/article/details/51119499" target="_blank" rel="external">https://blog.csdn.net/guyuealian/article/details/51119499</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶 ——— Android 深入理解AIDL进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android进阶 ——— Android 深入理解AIDL进程间通信/" class="article-date">
      <time datetime="2018-08-24T07:23:07.051Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android进阶 ——— Android 深入理解AIDL进程间通信/">Android进阶 ——— Android 深入理解AIDL进程间通信</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>关于AIDL的资料，层出不穷，但是能让人简单明了理解的文章不多，那么我们就自己撸一遍，清晰明了的理解一下AIDL的原理。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在理解AIDL原理之前，先写一个简单的使用AIDL进行进程间通信的例子，根据这个例子来由浅及深的理解AIDL。</p>
<p>先来定义实体类：UserBean.java<br>注意：<strong>如果要在AIDL中使用实体类，实体类必须要实现序列化接口，这里实现的是Android自带的Parcelable接口</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.t9.news.Model;</div><div class="line"></div><div class="line">import android.os.Parcel;</div><div class="line">import android.os.Parcelable;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/5/11</div><div class="line"> * function:com.t9.news.Model</div><div class="line"> */</div><div class="line"></div><div class="line">public class UserBean implements Parcelable&#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private String name;</div><div class="line"></div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	protected UserBean(Parcel in) &#123;</div><div class="line">		age = in.readInt();</div><div class="line">		name = in.readString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">		dest.writeInt(age);</div><div class="line">		dest.writeString(name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public int describeContents() &#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static final Creator&lt;UserBean&gt; CREATOR = new Creator&lt;UserBean&gt;() &#123;</div><div class="line">		@Override</div><div class="line">		public UserBean createFromParcel(Parcel in) &#123;</div><div class="line">			return new UserBean(in);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public UserBean[] newArray(int size) &#123;</div><div class="line">			return new UserBean[size];</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明好了实体类，就需要额外在AIDL中声明实体类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// UserBean.aidl</div><div class="line">package com.t9.news.Model;</div><div class="line"></div><div class="line">parcelable UserBean;</div></pre></td></tr></table></figure></p>
<p>在AIDL 中使用实体类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// IMyAidlInterface.aidl</div><div class="line">package com.t9.news;</div><div class="line"></div><div class="line">// Declare any non-default types here with import statements</div><div class="line">import com.t9.news.Model.UserBean;</div><div class="line">interface IUser &#123;</div><div class="line"></div><div class="line">    List&lt;UserBean&gt; getUser();</div><div class="line"></div><div class="line">    void addUser(in UserBean user);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看一下项目的结构<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fw5j8ufq7xj20no0mo77l.jpg" alt=""></p>
<p>然后Build 一下 Project，结束之后就生成了Binder代码，来看看Binder代码生成的位置<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fw5j8ufs5uj20pq0jawh5.jpg" alt=""></p>
<p>这时候可以点开看一下这个类，十有八九会被吓到，先不去管它，稍后再来分析。</p>
<p>来声明一个Service：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">package com.t9.news;</div><div class="line"></div><div class="line">import android.app.Service;</div><div class="line">import android.content.Intent;</div><div class="line">import android.os.IBinder;</div><div class="line">import android.os.RemoteException;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">import com.t9.news.Model.UserBean;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 2018/5/11</div><div class="line"> * function:com.t9.news</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyService extends Service &#123;</div><div class="line"></div><div class="line">	private String TAG = this.getClass().getName();</div><div class="line">	@Override</div><div class="line">	public void onCreate() &#123;</div><div class="line">		super.onCreate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	List&lt;UserBean&gt; list = new ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	private IBinder binder = new IUser.Stub() &#123;</div><div class="line">		@Override</div><div class="line">		public List&lt;UserBean&gt; getUser() throws RemoteException &#123;</div><div class="line">			if (list.size() &lt;= 0)&#123;</div><div class="line">				for(int i = 0; i &lt; 5; i++)&#123;</div><div class="line">					UserBean bean = new UserBean();</div><div class="line">					bean.setAge(5 * i);</div><div class="line">					bean.setName(&quot;android-&quot; + i);</div><div class="line">					list.add(bean);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			return list;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void addUser(UserBean user) throws RemoteException &#123;</div><div class="line">			Log.e(TAG, user.getName());</div><div class="line">			list.add(user);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	@Nullable</div><div class="line">	@Override</div><div class="line">	public IBinder onBind(Intent intent) &#123;</div><div class="line">		return binder;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义的Service比较简单。new 了一个 IUser.Stub()并把它向上转型成了IBinder，最后在onBind方法中返回回去。在 IUser.Stub()的内部我们重写getUser()、addUser(UserBean user)方法，这就是AIDL中声明的IUser接口中的两个方法。<br>既然是跨进程通信，那么将Service设置到另一个进程中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=&quot;com.t9.news.MyService&quot;</div><div class="line">    android:process=&quot;:newProcess&quot;</div><div class="line">    /&gt;</div></pre></td></tr></table></figure></p>
<p>定义为启动在新进程中，只需要在AndroidMainfest.xml中声明是加上一个process属性即可,不过这里有两个地方值得注意：<br>1.组件默认的进程名就是包名；<br>2.定义新的进程名的时候需要以包的形式(eg: com.xu.aidl)。</p>
<p>好，准备工作完成，在Activity中绑定Service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">package com.t9.News.HomePage.View.Activity</div><div class="line">import android.Manifest</div><div class="line">import android.content.ComponentName</div><div class="line">import android.content.Context</div><div class="line">import android.content.Intent</div><div class="line">import android.content.ServiceConnection</div><div class="line">import android.os.IBinder</div><div class="line">import android.os.RemoteException</div><div class="line">import android.util.Log</div><div class="line">import com.t9.news.Application</div><div class="line">import com.t9.news.R</div><div class="line">import com.t9.news.IUser</div><div class="line">import com.t9.news.Model.UserBean</div><div class="line">import com.t9.news.MyService</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dai</div><div class="line"> * Created time 19:06</div><div class="line"> * function:com.t9.news.Main.View.Activity</div><div class="line"> */</div><div class="line">class MainActivity : BaseActivity() &#123;</div><div class="line"></div><div class="line">    private val TAG = this.javaClass.simpleName;</div><div class="line"></div><div class="line">    override fun getLayoutId(): Int &#123;</div><div class="line">        return R.layout.activity_main</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun initView() &#123;</div><div class="line">        initService()</div><div class="line">    &#125;</div><div class="line">    fun initService()&#123;</div><div class="line">        val service = Intent(this@MainActivity, MyService::class.java)</div><div class="line">        bindService(service, serviceConnection, Context.BIND_AUTO_CREATE)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private var iUser : IUser? = null</div><div class="line">    private val serviceConnection = object : ServiceConnection &#123;</div><div class="line">        override fun onServiceConnected(name: ComponentName, service: IBinder) &#123;</div><div class="line">            iUser = IUser.Stub.asInterface(service)</div><div class="line">            Log.e(TAG,&quot;连接Service成功&quot;)</div><div class="line">            try &#123;</div><div class="line">               val list : List&lt;UserBean&gt;  = iUser!!.user</div><div class="line">                for (user in list)&#123;</div><div class="line">                    Log.e(TAG, &quot;name = &quot; + user.name + &quot; age: = &quot; + user.age)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                val user:UserBean = UserBean();</div><div class="line">                user.name = &quot;张三&quot;</div><div class="line">                user.age = 111</div><div class="line">                iUser!!.addUser(user)</div><div class="line">            &#125; catch (e: RemoteException) &#123;</div><div class="line">                e.printStackTrace()</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        override fun onServiceDisconnected(name: ComponentName) &#123;</div><div class="line">            Log.e(TAG,&quot;连接Service断开&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于主要是Service和Activity间的通信，所以为了让代码整洁就没有写UI了。</p>
<p>在onCreate(Bundle savedInstanceState)中，我们调用了自己定义的一个方法initService()，这个方法里面我们生成了一个Intent，然后 bindService了这个Intent传入了三个参数分别是Intent、ServiceConnection、Flag。</p>
<p>Intent我们就不用说了，我们看看后面两个参数：<br>在Activity中，我们new了一个ServiceConnection并实现了他的两个方法onServiceConnected、onServiceDisconnected。在onServiceConnected中我们通过IUser.Stub.asInterface(service)把传来的IBinder转换成了我们定义的iUser。然后我们调用了getUser方法，传递了个字符串和获取从MyService传来的字符串，并且打印了Log。<br>然后又new 一个UserBean对象，传递给MyService。</p>
<p>然后，我们的编码就完成了，运行并观察Log:</p>
<ul>
<li><p>MainActivity 中 Log：<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fw5jaijka0j211806gq8a.jpg" alt=""></p>
</li>
<li><p>MyService中Log：<br><img src="http://ww1.sinaimg.cn/large/8f176eddly1fw5jahze2hj210407mdi3.jpg" alt=""></p>
</li>
</ul>
<p>根据运行结果，在这两个不同的进程中都得到了我们想要的结果，所以，一个用aidl实现的跨进程通信就这样完成了。</p>
<h4 id="AIDL的理解"><a href="#AIDL的理解" class="headerlink" title="AIDL的理解"></a>AIDL的理解</h4><p>回过头来，我们再来分析之前的 debug 目录下的 IUser.java 类</p>
<ul>
<li><strong>先来看MyService 中 Binder</strong></li>
</ul>
<p>还记得我们在MyService中利用new IUser.Stub()向上转型成了IBinder然后在onBind方法中返回的。那我们就看看IUser.Stub()吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static abstract class Stub extends android.os.Binder implements com.t9.news.IUser&#123;</div><div class="line">		......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Stub 是 IUser 中静态抽象类，继承了 Binder，并且 实现 IUser接口，这就说明我们定义IUser.Stub的时候为什么需要实现IUser中的方法了，也说明了为什么我们可以把IUser.Stub向上转型成IBinder了。</p>
<ul>
<li><strong>Activity中的IMyInterface </strong><br>在Activity中，通过ServiceConnection连接MyService并成功回调onServiceConnected中我们把传回来的IBinder通过IUser.Stub.asInterface(service)转换成为IUser，那就来看看这里是如何转换的吧:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//这个接口里 有一个静态的抽象类Stub(注意这个名字是固定的 永远都是Stub 不会是其他)</div><div class="line"> //并且这个Stub是Binder的子类，并且实现了IUser 这个接口</div><div class="line">public static abstract class Stub extends android.os.Binder implements com.t9.news.IUser&#123;</div><div class="line">	//这个东西就是唯一的binder标示 可以看到就是IUser的全路径名</div><div class="line">	private static final java.lang.String DESCRIPTOR = &quot;com.t9.news.IUser&quot;;</div><div class="line">	/** Construct the stub at attach it to the interface. */</div><div class="line">	/**</div><div class="line">	   * 这个就是Stub的构造方法，回顾一下 我们如果写好aidl文件以后 写的service里面 是怎么写的？</div><div class="line">       * private final IUser.Stub mBinder = new IUser.Stub() &#123;&#125;</div><div class="line">        * 我们都是这么写的 对吧~~所以想想我们的service里面的代码 就能辅助理解 这里的代码了</div><div class="line">        */</div><div class="line">	public Stub()</div><div class="line">	&#123;</div><div class="line">	this.attachInterface(this, DESCRIPTOR);</div><div class="line">	&#125;</div><div class="line">	 //这个方法 其实就做了一件事，如果是同一个进程，那么就返回Stub对象本身</div><div class="line">    //如果不是同一个进程，就返回Stub.Proxy这个代理对象了</div><div class="line">	public static com.t9.news.IUser asInterface(android.os.IBinder obj)&#123;</div><div class="line">		if ((obj==null)) &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">		//检查Binder是不是在当前进程</div><div class="line">		android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">		//如果是同1个进程，也就是说进程内通信的话 我们就返回括号内里的对象</div><div class="line">		if (((iin!=null)&amp;&amp;(iin instanceof com.t9.news.IUser))) &#123;</div><div class="line">			return ((com.t9.news.IUser)iin);</div><div class="line">		&#125;</div><div class="line">		 //如果不是同一进程，是2个进程之间相互通信，那我们就得返回这个Stub.Proxy 看上去叫Stub 代理的对象了</div><div class="line">		return new com.t9.news.IUser.Stub.Proxy(obj);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>首先，我们因该明白的是，传回来的IBinder就是我们在Service的onBind( )方法所return的IBinder，然后我们调用Stub中的静态方法asInterface并把返回来的IBinder当参数传进去。<br>在asInterface方法中，首先判断了传进来的IBinder是不是null，如果为null就返回一个null;接着就判断传进来的IBinder是不是就在当前进程里面，如果是的话就直接返回IUser，不是的话就返回IUser.Stub.Proxy(obj)。<br>这里我觉得需要明白的是：直接返回的IUser是实现了定义的接口方法getUser、AddUser的。因为在IUser.Stub中所实现的。当然如果是在同一进程中，那么我们调用IUser的方法时就是在本地调用方法，直接调用就可以了。</p>
<p>如果没在同一进程，就会返回IUser.Stub.Proxy(obj):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">//注意这里的Proxy 这个类名也是不变的，从前文我们知道 只有在多进程通信的情况下  才会返回这个代理的对象</div><div class="line">private static class Proxy implements com.t9.news.IUser&#123;</div><div class="line">	private android.os.IBinder mRemote;</div><div class="line">	Proxy(android.os.IBinder remote)&#123;</div><div class="line">		mRemote = remote;</div><div class="line">	&#125;</div><div class="line">	@Override public android.os.IBinder asBinder()&#123;</div><div class="line">		return mRemote;</div><div class="line">	&#125;</div><div class="line">	public java.lang.String getInterfaceDescriptor()&#123;</div><div class="line">		return DESCRIPTOR;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">   //这里我们一共有2个方法 一个getUser 一个addUser 我们就分析一个方法就可以了</div><div class="line">        //并且要知道 这2个方法运行在客户端！！！！！！！！！！！！！！！！</div><div class="line">         //首先就是创建了3个对象_data 输入对象，_reply输出对象，_result返回值对象</div><div class="line">         //然后把参数信息 写入到_data里，接着就调用了transact这个方法 来发送rpc请求，然后接着</div><div class="line">         //当前线程挂起， 服务端的onTransace方法才被调用，调用结束以后 当前线程继续执行，直到</div><div class="line">         //从_reply中取出rpc的返回结果 然后返回_reply的数据</div><div class="line"></div><div class="line">        //所以这里我们就要注意了，客户端发起调用远程请求时，当前客户端的线程就会被挂起了，</div><div class="line">        //所以如果一个远程方法 很耗时，我们客户端就一定不能在ui main线程里在发起这个rpc请求，不然就anr了。</div><div class="line">	@Override public java.util.List&lt;com.t9.news.Model.UserBean&gt; getUser() throws android.os.RemoteException&#123;</div><div class="line">		android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">		android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">		java.util.List&lt;com.t9.news.Model.UserBean&gt; _result;</div><div class="line">		try &#123;</div><div class="line">			_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">			//传送数据到服务端</div><div class="line">			mRemote.transact(Stub.TRANSACTION_getUser, _data, _reply, 0);</div><div class="line">			_reply.readException();</div><div class="line">			//接受从服务端传回的数据</div><div class="line">			_result = _reply.createTypedArrayList(com.t9.news.Model.UserBean.CREATOR);</div><div class="line">		&#125;</div><div class="line">		finally &#123;</div><div class="line">			_reply.recycle();</div><div class="line">			_data.recycle();</div><div class="line">		&#125;</div><div class="line">		return _result;</div><div class="line">	&#125;</div><div class="line">	@Override public void addUser(com.t9.news.Model.UserBean user) throws android.os.RemoteException&#123;</div><div class="line">		android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">		android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">		try &#123;</div><div class="line">			_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">			if ((user!=null)) &#123;</div><div class="line">			_data.writeInt(1);</div><div class="line">			user.writeToParcel(_data, 0);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			_data.writeInt(0);</div><div class="line">		&#125;</div><div class="line">			mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0);</div><div class="line">			_reply.readException();</div><div class="line">		&#125;</div><div class="line">		finally &#123;</div><div class="line">			_reply.recycle();</div><div class="line">			_data.recycle();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Proxy中，我们首先把Service连接成功返回的IBinder它的内部变量mRemote,这里在提一下，这里得IBinder还是是MyService中onBind所返回的。然后，当我们调用IMyInterface的方法的时候，其实就是调用的Proxy的方法了，这也是为什么这个类叫做Porxy的原因了。</p>
<p>当调用IUser.getUser() ，我们就看Proxy中的getInfor,先获取了两个Parcel对象 _data、_data，从变量名就可以看出，一个是传送数据的，另一个则是接受返回数据的。接着，向_data中写入了DESCRIPTOR(也就是这个类的全名)，再写入了方法参数。然后就到了最重要的一步了，</p>
<p>mRemote.transact(Stub.TRANSACTION_getInfor, _data, _reply, 0);<br>这里我们调用了IBinder的transact方法，来把数据传给远端的服务器。然后在我们远程的MyService中，里面的Stub中就会回调onTransact（）（因为你把数据传个远程的服务，远端的服务收到数据也就回调了）</p>
<p>注意：这里是在远程的服务里调用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> //只有在多进程通信的时候 才会调用这个方法 ，同一个进程是不会调用的。</div><div class="line"></div><div class="line">     //首先 我们要明白 这个方法 一般情况下 都是返回true的，也只有返回true的时候才有意义，如果返回false了 就代表这个方法执行失败，</div><div class="line">     //所以我们通常是用这个方法来做权限认证的，其实也很好理解，既然是多进程通信，那么我们服务端的进程当然不希望谁都能过来调用</div><div class="line">     //所以权限认证是必须的，关于权限认证的代码 以后我再讲 先略过。</div><div class="line"> </div><div class="line">     //除此之外 ，onTransact 这个方法 就是运行在Binder线程池中的，一般就是客户端发起请求，然后android底层代码把这个客户端发起的</div><div class="line">     //请求 封装成3个参数 来调用这个onTransact方法，第一个参数code 就代表客户端想要调用服务端 方法的 标志位。</div><div class="line">     //其实也很好理解 服务端可能有n个方法 每个方法 都有一个对应的int值来代表，这个code就是这个int值，用来标示客户端想调用的服务端的方法</div><div class="line">     //data就是方法参数，reply就是方法返回值。都很好理解</div><div class="line"> </div><div class="line">     //其实隐藏了很重要的一点，这个方法既然是运行在binder线程池中的，所以在这个方法里面调用的服务器方法也是运行在Binder线程池中的，</div><div class="line">     //所以我们要记得 如果你的服务端程序 有可能和多个客户端相联的话，你方法里使用的那些参数 必须要是支持异步的，否则的话</div><div class="line">     //值就会错乱了！这点一定要记住！结论就是Binder方法 一定要是同步方法！！！！！！</div><div class="line">@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;</div><div class="line">	switch (code)&#123;</div><div class="line">		case INTERFACE_TRANSACTION:&#123;</div><div class="line">			reply.writeString(DESCRIPTOR);</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">		case TRANSACTION_getUser:&#123;</div><div class="line">			data.enforceInterface(DESCRIPTOR);</div><div class="line">			// 远程服务调用自己本地实现的方法获取返回值</div><div class="line">			java.util.List&lt;com.t9.news.Model.UserBean&gt; _result = this.getUser();</div><div class="line">			reply.writeNoException();</div><div class="line">			//写入返回值</div><div class="line">			reply.writeTypedList(_result);</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">		case TRANSACTION_addUser:&#123;</div><div class="line">			data.enforceInterface(DESCRIPTOR);</div><div class="line">			com.t9.news.Model.UserBean _arg0;</div><div class="line">			if ((0!=data.readInt())) &#123;</div><div class="line">				_arg0 = com.t9.news.Model.UserBean.CREATOR.createFromParcel(data);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				_arg0 = null;</div><div class="line">			&#125;</div><div class="line">			this.addUser(_arg0);</div><div class="line">			reply.writeNoException();</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return super.onTransact(code, data, reply, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>nTransact方法是在Stub的内部实现的。</p>
<p>先看一下它的四个参数： </p>
<ul>
<li>code：每个方法都有一个int类型的数字用来区分（后面中的swicth），在我们例子中也就是我们Proxy中的Stub.TRANSACTION_geIUser。 </li>
<li>data:传过来的数据，其中包含我们的参数，以及类的描述。 </li>
<li>reply:传回的数据，我们要写入是否发生了Exception,以及返回值 </li>
<li>flags:该方法是否有返回值 ，0表示有返回值。</li>
</ul>
<p>调用onTransact就表示有数据传来，首先就会通过swicth判断是哪个方法，然后取出方法参数，调用本地实现的方法获取返回值，写入返回值到reply。最后，返回true，才会把数据发送出去，发挥false就不会把结果返回给Activity了。这里也就是说，只有返回true,我们Proxy中才能接受从远端传回的数据。</p>
<p>注意：Service也是把数据发送出来，让客户端接受的。</p>
<p>Service发出了数据，客户端接收到了，就会一层一层返回去。所以，当我们简单的调用IUser的getUser时候，先是Proxy的transact发送出数据，然后服务端的onTransact接受并处理传来的数据，再把处理得到的数据写入返回值并发送给客户端，客户端读取值后就成为调用方法的返回值返回了。</p>
<p>到这里 相信大家 至少在应用层上面，就对Binder就一个很直观的理解了，对于进程间通信来说，具体的流程就分为如下几步：</p>
<ul>
<li><p>1.Client 发起远程调用请求 也就是RPC 到Binder。同时将自己挂起，挂起的原因是要等待RPC调用结束以后返回的结果</p>
</li>
<li><p>2.Binder 收到RPC请求以后 把参数收集一下，调用transact方法，把RPC请求转发给service端。</p>
</li>
<li><p>3.service端 收到rpc请求以后 就去线程池里 找一个空闲的线程去走service端的 onTransact方法 ，实际上也就是真正在运行service端的 方法了，等方法运行结束 就把结果 写回到binder中。</p>
</li>
<li><p>4.Binder 收到返回数据以后 就唤醒原来的Client 线程，返回结果。至此，一次进程间通信 的过程就结束了</p>
</li>
</ul>
<p>关于AIDL的基本原理就是这样了，看明白了AIDL，才发现原来AIDL不过就是帮我们生成了那些数据写入，传送，读取的方法而已。</p>
<hr>
<p>参考<br><a href="https://www.cnblogs.com/punkisnotdead/p/5163464.html" target="_blank" rel="external">https://www.cnblogs.com/punkisnotdead/p/5163464.html</a><br><a href="https://blog.csdn.net/u011974987/article/details/51243539" target="_blank" rel="external">https://blog.csdn.net/u011974987/article/details/51243539</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android 进阶  ------ Android 单元测试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Android 进阶  ------ Android 单元测试/" class="article-date">
      <time datetime="2018-08-24T07:22:56.164Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Android 进阶  ------ Android 单元测试/">Android 进阶  ------ Android 单元测试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h5 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h5><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。比如我们可以测试一个类，或者一个类中的一个方法。</p>
<h5 id="为什么要进行单元测试？"><a href="#为什么要进行单元测试？" class="headerlink" title="为什么要进行单元测试？"></a>为什么要进行单元测试？</h5><p>为什么要进行单元测试？说白了就是单元测试有什么好处，其实测试的好处无非就是减少bug、提高代码质量、使代码易于维护等。</p>
<p>这样表达可能不太好理解，举个例子</p>
<p>比如我们APP启动，从初始化到启动页，再进入首页，需要很长的流程，如果主页需要请求数据，每次都要启动APP，经过一系列流程进入主页，才能测试主页请求数据模块，效率低下。<br>当然我们也能在初始化时请求数据，但是这样需要更改代码逻辑，同样需要启动APP，而如果用单元测试，我们可以直接测试请求数据模块，不需要任何逻辑修改。提高效率</p>
<h5 id="开始进行单元测试"><a href="#开始进行单元测试" class="headerlink" title="开始进行单元测试"></a>开始进行单元测试</h5><p>AS创建工程时，src下创建 androidTest 和 test 目录，这两个目录有什么区别呢？</p>
<table>
<thead>
<tr>
<th>src/test</th>
<th>src/androidTest</th>
</tr>
</thead>
<tbody>
<tr>
<td>位于src/tests目录下的测试是运行在本地电脑Java虚拟机上的单元测试。编写测试，实现功能使测试通过，然后再添加更多的测试…这种工作方式使快速迭代成为可能，我们称之为测试驱动开发</td>
<td>跟src/test不同的是运行在设备上，并充分利用Android框架的测试</td>
</tr>
</tbody>
</table>
<blockquote>
<p>简单来说，src/test不需要你连接设备，而src/androidTest需要连接设备测试。</p>
</blockquote>
<h5 id="一、先说一下src-tests"><a href="#一、先说一下src-tests" class="headerlink" title="一、先说一下src/tests"></a>一、先说一下src/tests</h5><p>首先确认app下gradle中存在依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    testCompile &apos;junit:junit:4.12&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有个 快速排序的类，对一个数组进行快速排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class FastSort &#123;</div><div class="line"></div><div class="line">	public  void main()&#123;</div><div class="line">		int[] a = new int[]&#123;5,10,34,2,45,38,23,70,1,32,20,17,4,80,14,100&#125;;</div><div class="line">		quick_sort(a,0,a.length - 1);</div><div class="line">		for (int i : a) &#123;</div><div class="line">			System.out.println(i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	 void quick_sort(int a[],int l,int r)&#123;</div><div class="line">		if (l &lt; r)&#123;</div><div class="line">			int i = adjustArray(a,l,r);</div><div class="line">			quick_sort(a,l,i-1);</div><div class="line">			quick_sort(a,i+1,r);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private  int adjustArray(int a[],int l,int r)&#123;</div><div class="line">		int i = l,j = r,x = a[i];</div><div class="line">		while (i &lt; j)&#123;</div><div class="line"></div><div class="line">			while (i &lt; j &amp;&amp; a[j] &gt;= x)&#123;   //如果 a[j] &gt; x ，不用管，j-1,倒着比较下一个</div><div class="line">				j--;</div><div class="line">			&#125;</div><div class="line">			if (i &lt; j)&#123;  // a[j] &lt; x 跳出while循环</div><div class="line">				a[i] = a[j];    //将a[j]的值赋给a[i]被挖出的位置，默认是数组都一个</div><div class="line">				i++;   //i++,为后面i开始自增，提前增加</div><div class="line">			&#125;</div><div class="line"></div><div class="line"></div><div class="line">			while (i &lt; j &amp;&amp; a[i] &lt; x)&#123; //如果 a[i] &lt;  x ，不用管，x+1,比较下一个</div><div class="line">				i++;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			if (i &lt; j)&#123;  // a[i] &gt; x 跳出while循环</div><div class="line">				a[j] = a[i];   //将a[i]的值赋给上面a[j]被挖出的位置</div><div class="line">				j--;   //j--,为后面j继续自减，提前减少</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		a[i] = x;</div><div class="line">		return i;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然工具类写好了，当然要测试一下排序方法对不对了，这时候直接用单元测试来检验一下。</p>
<ul>
<li>AS为我们提供了创建测试类的快捷方法：</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/10/12/iNpzwD.png" alt="这里写图片描述"></p>
<ul>
<li><p>右键 –&gt;  Go To –&gt; Test<br><img src="https://s1.ax1x.com/2018/10/12/iN9CYd.png" alt="这里写图片描述"></p>
</li>
<li><p>勾选上所有方法，点击 OK，一路点击OK，完成测试类创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class FastSortTest extends TestCase &#123;</div><div class="line">	public void setUp() throws Exception &#123;</div><div class="line">		super.setUp();</div><div class="line">	&#125;</div><div class="line">	public void tearDown() throws Exception &#123;</div><div class="line">	&#125;</div><div class="line">	public void testMain() throws Exception &#123;</div><div class="line">	&#125;</div><div class="line">	public void testQuick_sort() throws Exception &#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>setUp：在测试开始之前回调的方法（ 比如说初始化我们的类）。<br>tearDown()：测试结束的回调方法。 </p>
</blockquote>
<ul>
<li>来添加测试代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class FastSortTest extends TestCase &#123;</div><div class="line"></div><div class="line">	private FastSort sort;</div><div class="line">	public void setUp() throws Exception &#123;</div><div class="line">		super.setUp();</div><div class="line">		sort = new FastSort();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void tearDown() throws Exception &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void testMain() throws Exception &#123;</div><div class="line">		sort.main();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void testQuick_sort() throws Exception &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>sort.main()方法，检测快速排序方法的正确性</p>
<ul>
<li>开始测试<br>右键点击FastSortTest类 —&gt; ‘Run FastSortTest’，也可以通过命令行运行测试，在工程目录内输入：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew test</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/10/12/iN9PfA.md.png" alt="这里写图片描述"></p>
<p>测试结束，可以看到，sortMain()方法通过测试<br><img src="https://s1.ax1x.com/2018/10/12/iN99FH.md.png" alt="这里写图片描述"></p>
<p>成功完成了 src/test  单元测试，</p>
<hr>
<p>这里简单介绍了 src/test 测试，关于其他用法，大家可以去深入研究一下</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Flutter初体验（二）---- 创建第一个Flutter APP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/24/Flutter初体验（二）---- 创建第一个Flutter APP/" class="article-date">
      <time datetime="2018-08-24T07:22:24.197Z" itemprop="datePublished">2018-08-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/Flutter初体验（二）---- 创建第一个Flutter APP/">Flutter初体验（二）---- 创建第一个Flutter APP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在第一篇文章<a href="http://blog.csdn.net/dazhaodai/article/details/79526401" target="_blank" rel="external"> Flutter初体验（一）—Mac 安装配置</a>，学习了配置 Flutter 开发环境，并运行了Demo项目，本篇根据官方教程，学习创建自己的第一个Flutter APP。</p>
<hr>
<pre><code>参考文档 https://flutter.io/get-started/codelab/
</code></pre><hr>
<h4 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h4><p>您将实施一个简单的移动应用程序，为一家创业公司生成建议名称。用户可以选择和取消选择名称，保存最好的名称。该代码一次生成十个名称。当用户滚动时，会生成新批次的名称。用户可以点击应用栏右上方的列表图标以移动到仅列出收藏名称的新路线</p>
<ul>
<li><p>下面的GIF动画显示我们将要完成应用程序    </p>
<p><img src="https://flutter.io/get-started/codelab/images/startup-namer-app.gif" alt=""></p>
</li>
</ul>
<h5 id="学习成果："><a href="#学习成果：" class="headerlink" title="学习成果："></a>学习成果：</h5><ul>
<li>Flutter应用程序的基本结构</li>
<li>学习查找和使用包来扩展功能</li>
<li>使用热重载加快开发周期</li>
<li>如何实现状态化组件</li>
<li>如何创建一个无限的，延迟加载的列表</li>
<li>如何创建并导航到第二个屏幕</li>
<li>如何使用主题更改应用程序的外观</li>
</ul>
<h3 id="第1步-：创建一个运行的Flutter-应用程序"><a href="#第1步-：创建一个运行的Flutter-应用程序" class="headerlink" title="第1步 ：创建一个运行的Flutter 应用程序"></a>第1步 ：创建一个运行的Flutter 应用程序</h3><p>在第一篇文章中已经讲述了如何配置Flutter开发环境，并且创建一个示例Flutter项目,现在将会修改这个示例程序来完成我们的项目。</p>
<p>本次操作，主要编辑Dart代码中的<strong>lib/main.dart</strong>。</p>
<blockquote>
<p><strong>提示</strong>: 将代码粘贴到您的应用中时，缩进可能会变形。您可以使用Flutter工具自动修复此问题</p>
<ul>
<li>Android Studio / IntelliJ IDEA：右键单击Dart代码，然后选择使用dartfmt重新格式化代码。</li>
<li>VS代码：右键单击并选择格式化文档</li>
<li>Terminal: 运行 flutter format <filename></filename></li>
</ul>
</blockquote>
<p>1.替换 lib/main.dart.<br>  删除lib / main.dart中的所有代码。替换为下面的代码，它在屏幕的中心显示“Hello World”<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">  import &apos;package:flutter/material.dart&apos;;</div><div class="line"></div><div class="line">void main() =&gt; runApp(new MyApp());</div><div class="line"></div><div class="line">class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    return new MaterialApp(</div><div class="line">      title: &apos;Welcome to Flutter&apos;,</div><div class="line">      home: new Scaffold(</div><div class="line">        appBar: new AppBar(</div><div class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</div><div class="line">        ),</div><div class="line">        body: new Center(</div><div class="line">          child: new Text(&apos;Hello World&apos;),</div><div class="line">        ),</div><div class="line">      ),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.运行工程，将会看到下面的屏幕截图</p>
<p><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1fpkpgk43ycj31401z4wfx.jpg" alt=""></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>本示例创建一个Material应用程序。 Material是一种在移动设备和web端是统一标准的视觉设计语言。 Flutter提供了一套丰富的Material小部件</li>
<li>主要方法指定箭头（=&gt;）表示法，它是用于单行函数或方法的简写</li>
<li>该应用程序扩展了使应用程序本身成为小部件的StatelessWidget。在Flutter中，几乎所有东西都是一个小部件，包括对齐，填充和布局</li>
<li>小部件的主要工作是提供一个build（）方法，该方法描述如何根据其他较低级别的小部件显示小部件</li>
<li><p>此示例的小部件树由包含Text小部件的中心小部件组成。中心小部件将其小部件子树对齐到屏幕中心</p>
<hr>
<h3 id="第2步：使用外部包"><a href="#第2步：使用外部包" class="headerlink" title="第2步：使用外部包"></a>第2步：使用外部包</h3><p>在这一步中，您将开始使用名为<strong>english_words</strong>的开源软件包，其中包含数千个最常用的英文单词以及一些实用功能<br> 1.pubspec文件管理Flutter应用程序的资源。在<strong>pubspec.yaml</strong>中，将<strong>english_words</strong>（3.1.0或更高版本）添加到依赖项列表。新行强调如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies:</div><div class="line">flutter:</div><div class="line">  sdk: flutter</div><div class="line"></div><div class="line">cupertino_icons: ^0.1.0</div><div class="line">english_words: ^3.1.0</div></pre></td></tr></table></figure>
<p> 2.在Android Studio的编辑器视图，单击右上角<strong>Packages get</strong>。将该包引入您的项目。将会在控制台中看到以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">flutter packages get</div><div class="line">Running &quot;flutter packages get&quot; in flutter_app...</div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<p> 3.在<strong>lib / main.dart</strong>中，将<strong>english_words</strong>导入,如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &apos;package:flutter/material.dart&apos;;</div><div class="line">import &apos;package:english_words/english_words.dart&apos;;</div></pre></td></tr></table></figure>
<p>在输入过程中，Android Studio会为您提供有关库导入的建议。然后它将呈现灰色的导入字符串，让您知道导入的库未使用（到目前为止）</p>
<p>4.使用English words 包来生成文本取代字符串“Hello World”<br>   进行以下更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import &apos;package:flutter/material.dart&apos;;</div><div class="line">import &apos;package:english_words/english_words.dart&apos;;</div><div class="line"></div><div class="line">void main() =&gt; runApp(new MyApp());</div><div class="line"></div><div class="line">class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line"> Widget build(BuildContext context) &#123;</div><div class="line">   final wordPair = new WordPair.random();</div><div class="line">   return new MaterialApp(</div><div class="line">      title: &apos;Welcome to Flutter&apos;,</div><div class="line">     home: new Scaffold(</div><div class="line">       appBar: new AppBar(</div><div class="line">         title: new Text(&apos;Welcome to Flutter&apos;),</div><div class="line">        ),</div><div class="line">       body: new Center(</div><div class="line">         //child: new Text(&apos;Hello World&apos;), // Replace the   highlighted text...</div><div class="line">         child: new Text(wordPair.asPascalCase),  // With this  highlighted text.</div><div class="line">        ),</div><div class="line">      ),</div><div class="line">    );</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.如果应用程序正在运行，使用热重载按钮（⚡️）更新正在运行的应用程序，每次点击热重载或者保存项目时，都会在正在运行的应用程序中随机显示一个不同的单词，这是单词配对是在构建方法内部生成的，每次MaterialApp需要渲染时都会运行它，或在检查器中切换平台时。<br><img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fpkpf7fzrvj30mz14uq49.jpg" alt=""></p>
<hr>
<h3 id="第3步：添加一个有状态的组件"><a href="#第3步：添加一个有状态的组件" class="headerlink" title="第3步：添加一个有状态的组件"></a>第3步：添加一个有状态的组件</h3></li>
</ul>
<p>无状态组件是不可变的，意味着他们的属性不能被改变–所有的值都是最终值</p>
<p>有状态的小部件保持在小部件的生命周期中可能改变的状态，实现一个有状态的小部件至少需要两个类：1）一个StatefulWidget类，它创建一个取代 2）一个State类的实例。 StatefulWidget类本身是不可变的，但State类在整个构件的生命周期中保持不变</p>
<p>在这一步中，您将添加一个有状态的小部件RandomWords，它创建其状态类RandomWordsState<br>   1.将有状态的RandomWords小部件添加到main.dart，它可以在MyApp之外的文件中的任何位置使用，但解决方案将它放在文件的底部。 RandomWords小部件除了创建其状态类之外无其他作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class RandomWords extends StatefulWidget &#123;</div><div class="line">  @override</div><div class="line">  createState() =&gt; new RandomWordsState();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   2.添加RandomWordsState类。该应用程序的大部分代码都驻留在该类中，该类保持RandomWords小部件的状态,这个类将保存随着用户滚动而无限增长的生成的单词对，以及最喜欢的单词对，因为用户通过切换红心图标来将它们从列表中添加或删除。</p>
<p>   你会一点一点地建立这个类。首先，通过添加突出显示的文本创建一个最小类：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   3.在添加状态类后，IDE会抱怨该类缺少构建方法,接下来，您将添加一个基本构建方法，该方法通过将单词生成代码从MyApp移动到RandomWordsState来生成单词对</p>
<p>  将构建方法添加到RandomWordState中，如突出显示的文本所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    final wordPair = new WordPair.random();</div><div class="line">    return new Text(wordPair.asPascalCase);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  4.通过下面突出显示的更改从MyApp中删除单词生成代码：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">  </div><div class="line">    return new MaterialApp(</div><div class="line">      title: &apos;Welcome to Flutter&apos;,</div><div class="line">      home: new Scaffold(</div><div class="line">        appBar: new AppBar(</div><div class="line">          title: new Text(&apos;Welcome to Flutter&apos;),</div><div class="line">        ),</div><div class="line">        body: new Center(</div><div class="line">          //child: new Text(wordPair.asPascalCase), // Change the highlighted text to...</div><div class="line">          child: new RandomWords(), // ... this highlighted text</div><div class="line">        ),</div><div class="line">      ),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  重新启动应用程序。如果您尝试重新加载热点，则可能会看到警告：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  Reloading...</div><div class="line">Not all changed program elements ran during view reassembly; consider</div><div class="line">restarting.</div></pre></td></tr></table></figure></p>
<p>  这可能是误报，但考虑重新启动以确保您的更改反映在应用的用户界面中。</p>
<p>  应用程序应该像以前一样运行，每次热重新加载或保存应用程序时都会显示一个字对。</p>
<p>  <img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fpkpenbynrj30mz14uabd.jpg" alt=""></p>
<hr>
<h3 id="第4步：创建一个无限的滚动ListView"><a href="#第4步：创建一个无限的滚动ListView" class="headerlink" title="第4步：创建一个无限的滚动ListView"></a>第4步：创建一个无限的滚动ListView</h3><p>在这一步中，您将展开RandomWordsState以生成并显示单词配对列表。当用户滚动时，ListView小部件中显示的列表将无限增长。 ListView的构建器工厂构造函数允许您根据需要懒惰地构建列表视图。</p>
<p>  1.将一个<code>_suggestions</code>列表添加到RandomWordsState类以保存建议的词对。该变量以下划线（_）开头 - 在下划线前加上一个带有下划线的标识符可以强化Dart语言的隐私。</p>
<p>  另外，添加一个largerFont变量来使字体变大。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  final _suggestions = &lt;WordPair&gt;[];</div><div class="line">  </div><div class="line">  final _biggerFont = const TextStyle(fontSize: 18.0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  2.将一个<code>_buildSuggestions（）</code>函数添加到RandomWordsState类。此方法构建显示建议词对的ListView。</p>
<p>ListView类提供了一个构建器属性itemBuilder，一个指定为匿名函数的工厂构建器和回调函数,两个参数传递给函数 - BuildContext和行迭代器.迭代器从0开始，每次调用该函数时递增，每次建议的单词配对一次.该模型允许建议的列表在用户滚动时无限增长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  Widget _buildSuggestions() &#123;</div><div class="line">    return new ListView.builder(</div><div class="line">      padding: const EdgeInsets.all(16.0),</div><div class="line">      // The itemBuilder callback is called once per suggested word pairing,</div><div class="line">      // and places each suggestion into a ListTile row.</div><div class="line">      // For even rows, the function adds a ListTile row for the word pairing.</div><div class="line">      // For odd rows, the function adds a Divider widget to visually</div><div class="line">      // separate the entries. Note that the divider may be difficult</div><div class="line">      // to see on smaller devices.</div><div class="line">      itemBuilder: (context, i) &#123;</div><div class="line">        // Add a one-pixel-high divider widget before each row in theListView.</div><div class="line">        if (i.isOdd) return new Divider();</div><div class="line"></div><div class="line">        // The syntax &quot;i ~/ 2&quot; divides i by 2 and returns an integer result.</div><div class="line">        // For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2.</div><div class="line">        // This calculates the actual number of word pairings in the ListView,</div><div class="line">        // minus the divider widgets.</div><div class="line">        final index = i ~/ 2;</div><div class="line">        // If you&apos;ve reached the end of the available word pairings...</div><div class="line">        if (index &gt;= _suggestions.length) &#123;</div><div class="line">          // ...then generate 10 more and add them to the suggestions list.</div><div class="line">          _suggestions.addAll(generateWordPairs().take(10));</div><div class="line">        &#125;</div><div class="line">        return _buildRow(_suggestions[index]);</div><div class="line">      &#125;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.<code>_buildSuggestions</code>函数每个字对调用<code>_buildRow</code>一次。这个函数在ListTile中显示每个新对，这允许您在下一步中使行更具吸引力</p>
<p>向<code>RandomWordsState</code>添加<code>_buildRow</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  Widget _buildRow(WordPair pair) &#123;</div><div class="line">    return new ListTile(</div><div class="line">      title: new Text(</div><div class="line">        pair.asPascalCase,</div><div class="line">        style: _biggerFont,</div><div class="line">      ),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.更新RandomWordsState的构建方法以使用_buildSuggestions（），而不是直接调用单词生成库。进行突出显示的更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line"></div><div class="line">    //final wordPair = new WordPair.random(); // Delete these two lines.</div><div class="line">    //return new Text(wordPair.asPascalCase);</div><div class="line">    </div><div class="line">    return new Scaffold (</div><div class="line">      appBar: new AppBar(</div><div class="line">        title: new Text(&apos;Startup Name Generator&apos;),</div><div class="line">      ),</div><div class="line">      body: _buildSuggestions(),  </div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.更新MyApp的构建方法。从MyApp中删除Scaffold和AppBar实例。这些将由RandomWordsState管理，当用户在下一步中从一个屏幕导航到另一个屏幕时，可以更轻松地更改应用栏中的路由名称。</p>
<p>用下面突出显示的构建方法替换原始方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    return new MaterialApp(</div><div class="line">      title: &apos;Startup Name Generator&apos;,</div><div class="line">      home: new RandomWords(),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新启动应用程序。你应该看到一个单词配对清单。尽可能向下滚动，您将继续看到新的单词配对。</p>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fpkpe6jufgj30mz14udi6.jpg" alt=""></p>
<hr>
<h3 id="第5步：添加交互性"><a href="#第5步：添加交互性" class="headerlink" title="第5步：添加交互性"></a>第5步：添加交互性</h3><p>在这一步中，您将为每一行添加可点击的心形图标。当用户点击列表中的条目，切换其“收藏”状态时，该单词配对被添加到一组保存的收藏夹中或从中删除</p>
<p>1.将一个<code>_saved</code>集合添加到RandomWordsState。这个集合存储用户最喜欢的单词配对。 Set比List更受欢迎，因为正确实施的Set不允许重复输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  final _suggestions = &lt;WordPair&gt;[];</div><div class="line"></div><div class="line">  final _saved = new Set&lt;WordPair&gt;();  //添加 saved 集合</div><div class="line"></div><div class="line">  final _biggerFont = const TextStyle(fontSize: 18.0);</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.在<code>_buildRow</code>函数中，添加<code>alreadySaved</code>检查以确保单词配对尚未添加到收藏夹.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Widget _buildRow(WordPair pair) &#123;</div><div class="line">  final alreadySaved = _saved.contains(pair);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.同样在_buildRow（）中，将心形图标添加到ListTiles以启用收藏。稍后，您将添加与心形图标进行交互的功能。</p>
<p>添加下面突出显示的行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Widget _buildRow(WordPair pair) &#123;</div><div class="line">  final alreadySaved = _saved.contains(pair);</div><div class="line">  return new ListTile(</div><div class="line">    title: new Text(</div><div class="line">      pair.asPascalCase,</div><div class="line">      style: _biggerFont,</div><div class="line">    ),</div><div class="line">    //添加心形图标以添加收藏功能</div><div class="line">    trailing: new Icon(</div><div class="line">      alreadySaved ? Icons.favorite : Icons.favorite_border,</div><div class="line">      color: alreadySaved ? Colors.red : null,</div><div class="line">    ),</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.重新启动应用程序。你现在应该在每一行看到开放的心，但它们还没有互动。</p>
<p>5.在<code>_buildRow</code>函数中让心形图标可点击。如果单词条目已经添加到收藏夹中，再次点击它将其从收藏夹中删除。当心形图标被轻敲时，函数调用setState（）来通知框架状态已经改变。</p>
<p>添加下列代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Widget _buildRow(WordPair pair) &#123;</div><div class="line">  final alreadySaved = _saved.contains(pair);</div><div class="line">  return new ListTile(</div><div class="line">    title: new Text(</div><div class="line">      pair.asPascalCase,</div><div class="line">      style: _biggerFont,</div><div class="line">    ),</div><div class="line">    trailing: new Icon(</div><div class="line">      alreadySaved ? Icons.favorite : Icons.favorite_border,</div><div class="line">      color: alreadySaved ? Colors.red : null,</div><div class="line">    ),</div><div class="line">    //修改心形图标的状态</div><div class="line">    onTap: () &#123;</div><div class="line">      setState(() &#123;</div><div class="line">        if (alreadySaved) &#123;</div><div class="line">          _saved.remove(pair);</div><div class="line">        &#125; else &#123;</div><div class="line">          _saved.add(pair);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;,</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>热重载应用程序。你应该能够点击任何一行以获得最喜欢的，或不适合的条目。注意，点击一行会生成从心形图标散发的涟漪动画。</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fpkpdim8dhj30mz14uju1.jpg" alt=""></p>
<hr>
<h3 id="第6步：导航到新的屏幕"><a href="#第6步：导航到新的屏幕" class="headerlink" title="第6步：导航到新的屏幕"></a>第6步：导航到新的屏幕</h3><p>在这一步中，您将添加一个显示收藏夹的新屏幕（在Flutter中称为路线）。您将学习如何在主路线和新路线之间导航。</p>
<p>在Flutter中，导航器管理包含应用程序路线的堆栈。将路线推入导航器的堆栈，将显示更新为该推入的路线。从导航器的堆栈中弹出路径，将显示返回到上一个路线。</p>
<p>1.向RandomWordsState的构建方法中的AppBar添加列表图标。当用户点击列表图标时，包含收藏夹项目的新路线被推送到导航器，显示该图标。</p>
<blockquote>
<p>提示：某些小部件属性采用单个小部件（子级），而其他属性（如操作）则采用小部件（子级）数组，如方括号（[]）所示。</p>
<p>将该图标及其相应的操作添加到构建方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    return new Scaffold(</div><div class="line">      appBar: new AppBar(</div><div class="line">        title: new Text(&apos;Startup Name Generator&apos;),</div><div class="line">        //添加actions</div><div class="line">        actions: &lt;Widget&gt;[</div><div class="line">          new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved),</div><div class="line">        ],</div><div class="line">      ),</div><div class="line">      body: _buildSuggestions(),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>2.将一个<code>_pushSaved（）</code>函数添加到RandomWordsState类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</div><div class="line">  ...</div><div class="line">  void _pushSaved() &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>热重新加载应用程序。列表图标出现在应用程序栏中。点击它什么也没做，因为<code>_pushSaved</code>函数是空的。</p>
<p>3.当用户点击应用栏中的列表图标时，建立一条路线并将其推送到导航器的堆栈。此操作会更改屏幕以显示新路线。</p>
<p>新页面的内容是使用匿名函数在MaterialPageRoute的构建器属性中构建的。</p>
<p>将呼叫添加到Navigator.push，如突出显示的代码所示，将路线推送到导航器的堆栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void _pushSaved() &#123;</div><div class="line">  Navigator.of(context).push(</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.添加MaterialPageRoute及其构建器。现在，添加生成ListTile行的代码。ListTile<code>的divideTiles（）</code>方法在每个ListTile之间添加水平间距。<code>divided</code>的变量保存最后的行，通过便利函数toList（）转换为列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void _pushSaved() &#123;</div><div class="line">  Navigator.of(context).push(</div><div class="line">    new MaterialPageRoute(</div><div class="line">      builder: (context) &#123;</div><div class="line">        final tiles = _saved.map(</div><div class="line">          (pair) &#123;</div><div class="line">            return new ListTile(</div><div class="line">              title: new Text(</div><div class="line">                pair.asPascalCase,</div><div class="line">                style: _biggerFont,</div><div class="line">              ),</div><div class="line">            );</div><div class="line">          &#125;,</div><div class="line">        );</div><div class="line">        final divided = ListTile</div><div class="line">          .divideTiles(</div><div class="line">            context: context,</div><div class="line">            tiles: tiles,</div><div class="line">          )</div><div class="line">          .toList();</div><div class="line">      &#125;,</div><div class="line">    ),</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.构建器属性返回一个Scaffold，其中包含名为“Saved Suggestions”的新路线的应用程序栏。新路由的主体由包含ListTiles行的ListView组成;每行由一个分隔符分隔。</p>
<p>添加下面突出显示的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">void _pushSaved() &#123;</div><div class="line">  Navigator.of(context).push(</div><div class="line">    new MaterialPageRoute(</div><div class="line">      builder: (context) &#123;</div><div class="line">        final tiles = _saved.map(</div><div class="line">          (pair) &#123;</div><div class="line">            return new ListTile(</div><div class="line">              title: new Text(</div><div class="line">                pair.asPascalCase,</div><div class="line">                style: _biggerFont,</div><div class="line">              ),</div><div class="line">            );</div><div class="line">          &#125;,</div><div class="line">        );</div><div class="line">        final divided = ListTile</div><div class="line">          .divideTiles(</div><div class="line">            context: context,</div><div class="line">            tiles: tiles,</div><div class="line">          )</div><div class="line">          .toList();</div><div class="line"></div><div class="line">        //添加 Scaffold 名为 Saved Suggestions</div><div class="line">      </div><div class="line">        return new Scaffold(</div><div class="line">          appBar: new AppBar(</div><div class="line">            title: new Text(&apos;Saved Suggestions&apos;),</div><div class="line">          ),</div><div class="line">          body: new ListView(children: divided),</div><div class="line">        );</div><div class="line">      &#125;,</div><div class="line">    ),</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.热重载应用程序。最喜欢的一些选择，并点击应用栏中的列表图标。新路线显示包含收藏夹。请注意，导航器会在应用栏中添加一个“返回”按钮。你不必显式实现Navigator.pop。点击后退按钮返回到主页路线。</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fpkpbfidmoj30mz14u766.jpg" alt=""></p>
<hr>
<h3 id="第7步：使用主题更改UI"><a href="#第7步：使用主题更改UI" class="headerlink" title="第7步：使用主题更改UI"></a>第7步：使用主题更改UI</h3><p>在最后一步中，您将使用该应用的主题,主题控制你的应用的外观和感觉。您可以使用默认主题，该主题取决于物理设备或模拟器，也可以自定义主题以反映您的品牌。</p>
<p>1.您可以通过配置ThemeData类轻松更改应用程序的主题。您的应用程序目前使用默认主题，但您将更改主要颜色为白色。</p>
<p>将突出显示的代码添加到MyApp，将应用程序的主题更改为蓝色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class MyApp extends StatelessWidget &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    return new MaterialApp(</div><div class="line">      title: &apos;Startup Name Generator&apos;,</div><div class="line">      //修改主题颜色</div><div class="line">      theme: new ThemeData(</div><div class="line">        primaryColor: Colors.blue,</div><div class="line">      ),</div><div class="line">      home: new RandomWords(),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.热重新加载应用程序。请注意，整个背景是白色的，甚至是应用栏。</p>
<p>3.作为读者的练习，使用ThemeData来改变用户界面的其他方面。材质库中的Colors类提供了许多可以使用的颜色常量，而热重载使得用户界面的试验变得快速而简单。</p>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fpkpar0zv2j31401z4jtf.jpg" alt=""></p>
<hr>
<h3 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h3><p>我们编写了一个在iOS和Android上运行的交互式Flutter应用程序。在这个codelab中，你有：</p>
<ul>
<li>从头开始创建一个Flutter应用程序。</li>
<li>书写Dart代码。</li>
<li>利用外部的第三方库。</li>
<li>使用热重载加快开发周期。</li>
<li>实现一个有状态的小部件，为你的应用增加交互性。</li>
<li>用ListView和ListTiles创建一个延迟加载的无限滚动列表。</li>
<li>创建了一条路线并添加了在主路线和新路线之间移动的逻辑。</li>
<li>了解如何使用主题更改应用UI的外观。</li>
</ul>
<hr>
<p>第一篇文章：<a href="http://blog.csdn.net/dazhaodai/article/details/79526401" target="_blank" rel="external"> Flutter初体验（一）—Mac 安装配置</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 daidai
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>