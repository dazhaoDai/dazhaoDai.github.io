<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java进阶," />










<meta name="description" content="1. 垃圾回收机制 垃圾回收的意义当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾，JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。  垃圾收集的算法分析1.为什么会有年轻代 我们先来屡屡">
<meta name="keywords" content="Java进阶">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 进阶  ------ 垃圾回收机制">
<meta property="og:url" content="http://outofmemory.top/2018/08/24/Java 进阶  ------ 垃圾回收机制/index.html">
<meta property="og:site_name" content="T9&#39;S Develop Blog">
<meta property="og:description" content="1. 垃圾回收机制 垃圾回收的意义当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾，JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。  垃圾收集的算法分析1.为什么会有年轻代 我们先来屡屡">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ifeve.com/wp-content/uploads/2014/07/young_gc.png">
<meta property="og:updated_time" content="2018-08-24T07:15:25.786Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 进阶  ------ 垃圾回收机制">
<meta name="twitter:description" content="1. 垃圾回收机制 垃圾回收的意义当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾，JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。  垃圾收集的算法分析1.为什么会有年轻代 我们先来屡屡">
<meta name="twitter:image" content="http://ifeve.com/wp-content/uploads/2014/07/young_gc.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://outofmemory.top/2018/08/24/Java 进阶  ------ 垃圾回收机制/"/>





  <title>Java 进阶  ------ 垃圾回收机制 | T9'S Develop Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">T9'S Develop Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不仅有工作，更有生活</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://outofmemory.top/2018/08/24/Java 进阶  ------ 垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daidai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T9'S Develop Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 进阶  ------ 垃圾回收机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-24T15:15:25+08:00">
                2018-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h3><ul>
<li><p>垃圾回收的意义<br>当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾，JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。</p>
</li>
<li><p>垃圾收集的算法分析<br>1.为什么会有年轻代</p>
<p>我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p>  2.年轻代中的GC</p>
<p>  HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p>
<p>  因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>  在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p>  <img src="http://ifeve.com/wp-content/uploads/2014/07/young_gc.png" alt=""></p>
<p>  3.一个对象的这一辈子<br>我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p>
</li>
</ul>
<hr>
<pre><code>JVM 新生代老年代
https://www.cnblogs.com/E-star/p/5556188.html
</code></pre><hr>
<h3 id="2-常见编码方式"><a href="#2-常见编码方式" class="headerlink" title="2. 常见编码方式"></a>2. 常见编码方式</h3><ul>
<li>1.ASCII<br>共有128个，用一个字节的低7位表示<br>0~31 控制字符 如换行、回车、删除<br>32~126 打印字符</li>
<li>2.GB2312</li>
<li>3.GBK</li>
<li>4.UTF-16</li>
<li>5.UTF-8</li>
</ul>
<h3 id="3-静态代理和动态代理的区别，以及使用场景"><a href="#3-静态代理和动态代理的区别，以及使用场景" class="headerlink" title="3. 静态代理和动态代理的区别，以及使用场景"></a>3. 静态代理和动态代理的区别，以及使用场景</h3><p>原因是采用代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部</p>
<ul>
<li>1.静态代理<br>静态代理是在编译时就将接口、实现类、代理类一股脑儿全部手动完成，但如果我们需要很多的代理，每一个都这么手动的去创建实属浪费时间，而且会有大量的重复代码，此时我们就可以采用动态代理，动态代理可以在程序运行期间根据需要动态的创建代理类及其实例，来完成具体的功能</li>
<li>2.动态代理<br>动态代理类：在程序运行时，运用反射机制动态创建而成。</li>
</ul>
<p>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。<br>静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。</p>
<p>静态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>动态代理Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public interface Iuser &#123;</div><div class="line"> 　　void eat(String s);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"></div><div class="line">public class UserImpl implements Iuser &#123;</div><div class="line">　　@Override</div><div class="line">　　public void eat(String s) &#123;</div><div class="line">　　　　System.out.println(&quot;我要吃&quot;+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class DynamicProxy implements InvocationHandler &#123;</div><div class="line">　　private Object object;//用于接收具体实现类的实例对象</div><div class="line">　　//使用带参数的构造器来传递具体实现类的对象</div><div class="line">　　public DynamicProxy(Object obj)&#123;</div><div class="line">　　　　this.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　@Override</div><div class="line">　　public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;</div><div class="line">　　　　System.out.println(&quot;前置内容&quot;);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(&quot;后置内容&quot;);</div><div class="line">　　　　return null;</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ProxyTest &#123;</div><div class="line">　　public static void main(String[] args) &#123;</div><div class="line">　　　　Iuser user = new UserImpl();</div><div class="line">　　　　InvocationHandler h = new DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(&quot;苹果&quot;);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-如何将一个Java对象序列化到文件"><a href="#4-如何将一个Java对象序列化到文件" class="headerlink" title="4. 如何将一个Java对象序列化到文件"></a>4. 如何将一个Java对象序列化到文件</h3><p>让对象实现Serializable接口或者Parcelable接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public void saveObjToFile(Person p)&#123;  </div><div class="line">     try &#123;  </div><div class="line">         //写对象流的对象  </div><div class="line">         ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(fileName));  </div><div class="line">           </div><div class="line">         oos.writeObject(p);                 //将Person对象p写入到oos中  </div><div class="line">           </div><div class="line">         oos.close();                        //关闭文件流  </div><div class="line">     &#125; catch (FileNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (IOException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125;   </div><div class="line"> &#125;  </div><div class="line">   </div><div class="line"> /* </div><div class="line">  * 从文件中读出对象，并且返回Person对象 </div><div class="line">  */  </div><div class="line"> public Person getObjFromFile()&#123;  </div><div class="line">     try &#123;  </div><div class="line">         ObjectInputStream ois=new ObjectInputStream(new FileInputStream(fileName));  </div><div class="line">           </div><div class="line">         Person person=(Person)ois.readObject();              //读出对象  </div><div class="line">           </div><div class="line">         return person;                                       //返回对象  </div><div class="line">     &#125; catch (FileNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (IOException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125; catch (ClassNotFoundException e) &#123;  </div><div class="line">         // TODO Auto-generated catch block  </div><div class="line">         e.printStackTrace();  </div><div class="line">     &#125;  </div><div class="line">       </div><div class="line">     return null;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-Java反射的理解"><a href="#5-Java反射的理解" class="headerlink" title="5. Java反射的理解"></a>5. Java反射的理解</h3><h4 id="反射的含义"><a href="#反射的含义" class="headerlink" title="反射的含义"></a>反射的含义</h4><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性</p>
<p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br> 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类；</li>
<li>2.在运行时构造任意一个类的对象；</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>4.在运行时调用任意一个对象的方法<blockquote>
<p>重点：是运行时而不是编译时</p>
</blockquote>
</li>
</ul>
<h4 id="反射的运用"><a href="#反射的运用" class="headerlink" title="反射的运用"></a>反射的运用</h4><p>1、获得Class对象</p>
<hr>
<p>方法有三种</p>
<ul>
<li><p>(1)使用Class类的forName静态方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static Class&lt;?&gt; forName(String className)</div></pre></td></tr></table></figure>
<ul>
<li>(2)直接获取某一个对象的class，比如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> Class&lt;?&gt; klass = int.class;</div><div class="line">Class&lt;?&gt; classInt = Integer.TYPE;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(3)调用某个对象的getClass()方法,比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuilder str = new StringBuilder(&quot;123&quot;);</div><div class="line">Class&lt;?&gt; klass = str.getClass();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>2、判断是否为某个类的实例</p>
<hr>
<p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public native boolean isInstance(Object obj);</div></pre></td></tr></table></figure></p>
<p>3、创建实例</p>
<hr>
<p>通过反射来生成对象主要有两种方式。</p>
<ul>
<li><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">Object str = c.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//获取String所对应的Class对象</div><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">//获取String类带一个String参数的构造器</div><div class="line">Constructor constructor = c.getConstructor(String.class);</div><div class="line">//根据构造器创建实例</div><div class="line">Object obj = constructor.newInstance(&quot;23333&quot;);</div><div class="line">System.out.println(obj);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>4、获取方法</p>
<hr>
<p>获取某个Class对象的方法集合，主要有以下几个方法：<br>getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public Method[] getDeclaredMethods() throws SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Method[] getMethods() throws SecurityException</div></pre></td></tr></table></figure></p>
<p>getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>getMethod 中方法 需要是public，才能获取到</p>
</blockquote>
<p>用例子说明一下，加深理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void testReflect()&#123;</div><div class="line">    try &#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(&quot;hard.uistudy.dai.uifinaltest.main.view.activity.MainActivity6&quot;);</div><div class="line">        try &#123;</div><div class="line">            Object object =  cls.newInstance();</div><div class="line">          Method[] methods =  cls.getMethods();</div><div class="line">          Method[] declaredMethods = cls.getDeclaredMethods();</div><div class="line">            for (Method m: methods) &#123;</div><div class="line">                Log.e(&quot;method&quot;,m.toString());</div><div class="line">            &#125;</div><div class="line">            for (Method m: declaredMethods) &#123;</div><div class="line">                Log.e(&quot;declaredMethods&quot;,m.toString());</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、获取构造器信息</p>
<hr>
<p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public T newInstance(Object ... initargs)</div></pre></td></tr></table></figure></p>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</p>
<p>6、获取类的成员变量（字段）信息</p>
<hr>
<p>主要是这几个方法，在此不再赘述：<br>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void testReflect()&#123;</div><div class="line">       try &#123;</div><div class="line">           Class&lt;?&gt; cls = Class.forName(&quot;hard.uistudy.dai.uifinaltest.main.view.activity.MainActivity6&quot;);</div><div class="line">           try &#123;</div><div class="line">             Object object =  cls.newInstance();</div><div class="line">             Method[] methods =  cls.getMethods();</div><div class="line">             Field[] fields = cls.getDeclaredFields();</div><div class="line">             for (Field field: fields ) &#123;</div><div class="line">                   Log.e(&quot;Field&quot;,field.toString());</div><div class="line">             &#125;</div><div class="line">           &#125; catch (InstantiationException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125; catch (IllegalAccessException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125;</div><div class="line">       &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>7、调用方法</p>
<hr>
<p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Object invoke(Object obj, Object... args)</div><div class="line">        throws IllegalAccessException, IllegalArgumentException,</div><div class="line">           InvocationTargetException</div></pre></td></tr></table></figure></p>
<p>参考下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class test1 &#123;</div><div class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</div><div class="line">        Class&lt;?&gt; klass = methodClass.class;</div><div class="line">        //创建methodClass的实例</div><div class="line">        Object obj = klass.newInstance();</div><div class="line">        //获取methodClass类的add方法</div><div class="line">        Method method = klass.getMethod(&quot;add&quot;,int.class,int.class);</div><div class="line">        //调用method对应的方法 =&gt; add(1,4)</div><div class="line">        Object result = method.invoke(obj,1,4);</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class methodClass &#123;</div><div class="line">    public final int fuck = 3;</div><div class="line">    public int add(int a,int b) &#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">    public int sub(int a,int b) &#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>8、利用反射创建数组</p>
<hr>
<p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void testArray() throws ClassNotFoundException &#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;);</div><div class="line">        Object array = Array.newInstance(cls,25);</div><div class="line">        //往数组里添加内容</div><div class="line">        Array.set(array,0,&quot;hello&quot;);</div><div class="line">        Array.set(array,1,&quot;Java&quot;);</div><div class="line">        Array.set(array,2,&quot;fuck&quot;);</div><div class="line">        Array.set(array,3,&quot;Scala&quot;);</div><div class="line">        Array.set(array,4,&quot;Clojure&quot;);</div><div class="line">        //获取某一项的内容</div><div class="line">        System.out.println(Array.get(array,3));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。<br>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>
<hr>
<pre><code>原文: http://www.sczyh30.com/posts/Java/java-reflection-1/　　作者: sczyh30
</code></pre><hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java进阶/" rel="tag"># Java进阶</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/24/Java 进阶  ------ 时间复杂度对比/" rel="next" title="Java 进阶  ------ 时间复杂度对比">
                <i class="fa fa-chevron-left"></i> Java 进阶  ------ 时间复杂度对比
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/24/Java设计模式  ------ 代理模式/" rel="prev" title="Java设计模式  ------ 代理模式">
                Java设计模式  ------ 代理模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">daidai</p>
              <p class="site-description motion-element" itemprop="description">喜欢探索未知,保持好奇心</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-垃圾回收机制"><span class="nav-number">1.</span> <span class="nav-text">1. 垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-常见编码方式"><span class="nav-number">2.</span> <span class="nav-text">2. 常见编码方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-静态代理和动态代理的区别，以及使用场景"><span class="nav-number">3.</span> <span class="nav-text">3. 静态代理和动态代理的区别，以及使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-如何将一个Java对象序列化到文件"><span class="nav-number">4.</span> <span class="nav-text">4. 如何将一个Java对象序列化到文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Java反射的理解"><span class="nav-number">5.</span> <span class="nav-text">5. Java反射的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反射的含义"><span class="nav-number">5.1.</span> <span class="nav-text">反射的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反射的运用"><span class="nav-number">5.2.</span> <span class="nav-text">反射的运用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项"><span class="nav-number">5.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">daidai</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
